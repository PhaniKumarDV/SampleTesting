diff -urN qca-wifi-org/cmn_dev/dp/inc/cdp_txrx_stats_struct.h qca-wifi-mod/cmn_dev/dp/inc/cdp_txrx_stats_struct.h
--- qca-wifi-org/cmn_dev/dp/inc/cdp_txrx_stats_struct.h	2018-06-08 10:23:13.000000000 +0530
+++ qca-wifi-mod/cmn_dev/dp/inc/cdp_txrx_stats_struct.h	2018-07-03 13:48:45.221216000 +0530
@@ -505,7 +505,13 @@
 	OL_ATH_PARAM_CHAN_FREE  = 366,
 	OL_ATH_PARAM_CHAN_AP_TX_UTIL = 367,
 	OL_ATH_PARAM_CHAN_OBSS_RX_UTIL  =368,
-
+	OL_ATH_PARAM_TXDISTANCE = 369,
+	OL_ATH_PARAM_DYING_GASP = 370,
+	OL_ATH_PARAM_DG_TIMER_INTERVAL = 371,
+	OL_ATH_PARAM_DG_ACK_DISABLE = 372,
+	OL_ATH_PARAM_LINKID = 373,
+	OL_ATH_PARAM_STR_TYPE = 374,
+	OL_ATH_PARAM_KWN_AMSDU = 375
 } ol_ath_param_t;
 
 /*
diff -urN qca-wifi-org/include/ieee80211_defines.h qca-wifi-mod/include/ieee80211_defines.h
--- qca-wifi-org/include/ieee80211_defines.h	2018-06-08 11:00:51.000000000 +0530
+++ qca-wifi-mod/include/ieee80211_defines.h	2018-11-05 13:01:06.283943901 +0530
@@ -14,6 +14,7 @@
 #ifndef _IEEE80211_DEFINES_H_
 #define _IEEE80211_DEFINES_H_
 
+#define SIFY_MGMT_STATS
 #include <ieee80211.h>
 #ifndef EXTERNAL_USE_ONLY
 #include <_ieee80211.h>        /* IEEE80211_ADDR_LEN, iee80211_phymode */
@@ -1913,6 +1914,32 @@
     u_int32_t   chan_tx_power_range;     /* EEPROM Tx power value for Maximum range*/
 };
 
+#ifdef SIFY_MGMT_STATS
+struct ieee80211_mgmt_stats
+{
+	u_int64_t                         bcn_recv;
+	u_int64_t                         assoc_xmit;
+	u_int64_t                         assoc_recv;
+	u_int64_t                         assoc_reject_recv;
+	u_int64_t                         assoc_reject_xmit;    
+	u_int64_t                         assoc_confirm_recv;  
+	u_int64_t                         assoc_confirm_xmit;
+	u_int64_t                         disassoc_xmit;
+	u_int64_t                         disassoc_recv;                                      
+	u_int64_t                         aut_xmit;
+	u_int64_t                         aut_recv;
+	u_int64_t                         aut_confirm_recv;
+	u_int64_t                         aut_confirm_xmit;    
+	u_int64_t                         aut_reject_recv;
+	u_int64_t                         aut_reject_xmit;        
+	u_int64_t                         deaut_xmit;
+	u_int64_t                         deaut_recv;
+	u_int64_t                         reg_fail_last_reason;
+    u_int32_t                         assoc_reason;
+	u_int32_t                         auth_reason;    
+	u_int64_t                         iv_opmode;
+};
+#endif
 struct ieee80211_mac_stats {
     u_int64_t   ims_tx_packets; /* frames successfully transmitted */
     u_int64_t   ims_rx_packets; /* frames successfully received */
@@ -2075,6 +2102,12 @@
     u_int64_t   mlme_auth_success;         /* no of 802.11 MLME Auth Success */
     u_int64_t   authorize_attempt;         /* no of Authorization Attempt */
     u_int64_t   authorize_success;         /* no of Authorization successful */
+    u_int64_t   kwn_tx_tput_mbps;
+    u_int64_t   kwn_tx_tput_last_jiffies;
+    u_int64_t   rx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+    u_int64_t   rx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+    u_int64_t   kwn_rx_tput_mbps;
+    u_int64_t   kwn_rx_tput_last_jiffies;
 };
 
 typedef enum _ieee80211_send_frame_type {
diff -urN qca-wifi-org/include/_ieee80211.h qca-wifi-mod/include/_ieee80211.h
--- qca-wifi-org/include/_ieee80211.h	2018-06-08 11:00:51.000000000 +0530
+++ qca-wifi-mod/include/_ieee80211.h	2018-11-14 14:06:48.946431080 +0530
@@ -208,8 +208,8 @@
 };
 
 #define	IEEE80211_NWID_LEN	32
-#define IEEE80211_CHAN_MAX      1023
-#define IEEE80211_CHAN_BYTES    128      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
+#define IEEE80211_CHAN_MAX      (1023*2)
+#define IEEE80211_CHAN_BYTES    (128*2)      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
 #define IEEE80211_CHAN_ANY      (-1)    /* token for ``any channel'' */
 #define IEEE80211_CHAN_ANYC \
         ((struct ieee80211_channel *) IEEE80211_CHAN_ANY)
@@ -701,6 +701,14 @@
 #endif
 };
 
+struct kwn_chanutil_info {
+    u_int32_t    rx_clear_count;
+    u_int32_t    cycle_count;
+    u_int8_t     value; 
+    u_int32_t    total;
+    u_int32_t    count;
+};
+
 enum ieee80211_vendor_ie_param {
     IEEE80211_VENDOR_IE_PARAM_ADD = 0,
     IEEE80211_VENDOR_IE_PARAM_UPDATE,
diff -urN qca-wifi-org/include/ieee80211.h qca-wifi-mod/include/ieee80211.h
--- qca-wifi-org/include/ieee80211.h	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/include/ieee80211.h	2018-11-14 14:14:52.102492795 +0530
@@ -768,6 +768,12 @@
 #define IEEE80211_ACTION_TPC_REQUEST        2   /* Transmit Power control */
 #define IEEE80211_ACTION_TPC_REPORT         3
 #define IEEE80211_ACTION_CHAN_SWITCH        4   /* 802.11h Channel Switch Announcement */
+#define IEEE80211_ACTION_DYING_GASP         5   /* Dying Gasp */
+#define IEEE80211_ACTION_LINK_PARAM         6   /* Link param */
+#define IEEE80211_ACTION_NODE_STATS         7   /* Node Stats */
+#define IEEE80211_ACTION_TPUT_TEST          8   /* Tput Test */
+#define IEEE80211_ACTION_SCAN_ENTRIES       9   /* Scan Entries */
+#define IEEE80211_ACTION_TX_PARAMS          10  /* Tx params */
 
 /* HT actions */
 #define IEEE80211_ACTION_HT_TXCHWIDTH       0   /* recommended transmission channel width */
@@ -840,6 +846,102 @@
         struct ieee80211_ie_op_mode opmode;
 } __packed;
 
+#define DG_PKT_TYPE_INFORM 1
+#define DG_PKT_TYPE_ACK	   2
+#define KWN_SCAN_ENTRY_MAX 100
+
+struct ieee80211_tx_param {
+    int8_t  	chan;
+    int8_t  	txpower;
+    int8_t  	rate;
+} __packed;
+
+/* VHT - Tx params */
+struct ieee80211_action_vht_tx_params {
+    struct ieee80211_action    at_header;
+    struct ieee80211_tx_param  at_tx_param;
+} __packed;
+
+struct ieee80211_scan_actionentry {
+    u_int8_t  	channel; 
+    u_int16_t  	frequency; 
+    u_int8_t  	rssi; 
+} __packed;
+
+struct ieee80211_scan_actionentries {
+    u_int8_t  	count;
+    struct ieee80211_scan_actionentry entry[ KWN_SCAN_ENTRY_MAX ];
+} __packed;
+
+/* VHT - Scan Entries */
+struct ieee80211_action_vht_scan_entries {
+    struct ieee80211_action    at_header;
+    struct ieee80211_scan_actionentries at_scan_entry;
+} __packed;
+
+struct ieee80211_tput_test {
+    u_int32_t  	ipv4;
+    u_int8_t  	start_stop; 
+    u_int32_t  	duration; 
+    u_int32_t  	pkt_size; 
+    u_int32_t  	cnt; 
+} __packed;
+
+/* VHT - TPUT Test*/
+struct ieee80211_action_vht_tput_test {
+    struct ieee80211_action    at_header;
+    struct ieee80211_tput_test at_tput_test;
+} __packed;
+
+struct ieee80211_node_stats {
+    u_int32_t  	ipv4;
+    u_int8_t    snr_avg[ 2 ];
+    u_int64_t   rx_tput_mbps;
+    u_int32_t  	phy_err; 
+    u_int32_t  	mpdu_err; 
+    u_int32_t  	retries; 
+    int16_t  	noise_floor; 
+} __packed;
+
+/* VHT - Node Stats*/
+struct ieee80211_action_vht_node_stats {
+    struct ieee80211_action     at_header;
+    struct ieee80211_node_stats at_node_stats;
+} __packed;
+
+struct ieee80211_link_param {
+    u_int32_t  	ipv4;
+    u_int32_t  	ul_limit; 
+    u_int32_t  	dl_limit; 
+    u_int8_t	link_id;
+    u_int8_t	customer_name[32];
+    u_int8_t	antenna_gain;
+    u_int8_t    kwn_assem_frag;
+    u_int16_t   kwn_max_pkt_size;
+    u_int16_t   kwn_frag_pkt_size;
+} __packed;
+
+/* VHT - exchange param */
+struct ieee80211_action_vht_link_param {
+    struct ieee80211_action     at_header;
+    struct ieee80211_link_param at_uldl_limit;
+} __packed;
+
+struct ieee80211_dying_gasp_ie {
+    u_int8_t    type;
+    u_int8_t	link_id;
+    u_int16_t	seq_no;
+    u_long   	ts;
+    u_int32_t  	ipv4;
+    u_int8_t	customer_name[32];
+    
+} __packed;
+
+/* VHT - Dying gasp*/
+struct ieee80211_action_vht_dying_gasp {
+    struct ieee80211_action     at_header;
+    struct ieee80211_dying_gasp_ie at_dying_gasp;
+} __packed;
 
 /* VHT - recommended Channel width and Nss */
 struct ieee80211_action_vht_opmode {
@@ -1243,6 +1345,14 @@
 } __packed;
 
 /*
+ * GPS IE
+ */
+struct ieee80211_ie_gps {
+    u_int8_t                         hc_id;      /* element ID */
+    u_int8_t                         hc_len;     /* length in bytes */
+    u_int8_t    		     hc_coordinates[32];
+} __packed;
+/*
  * 802.11n HT Capability IE
  */
 struct ieee80211_ie_htcap {
@@ -2735,6 +2845,7 @@
 // Factor used to convert airtime between user space and driver
 #define ATF_AIRTIME_CONVERSION_FACTOR 10
 #define IEEE80211_MAX_IFNAME 16
+#define KWN_SA_CHAN_MAX      250
 
 struct ieee80211_clone_params {
 	char		icp_name[IEEE80211_MAX_IFNAME];	/* device name */
@@ -2745,6 +2856,17 @@
     u_int8_t icp_mataddr[IEEE80211_ADDR_LEN];    /* optional MAT address */
 };
 
+struct kwn_sa_scan_entries {
+    u_int8_t  channel;
+    u_int16_t frequency;
+    u_int8_t  utility;
+};
+
+struct kwn_sa_scan_result {
+    struct kwn_sa_scan_entries sa_entry[ KWN_SA_CHAN_MAX ];
+    u_int8_t cnt;
+};
+
 #define	    IEEE80211_CLONE_BSSID       0x0001		/* allocate unique mac/bssid */
 #define	    IEEE80211_NO_STABEACONS	    0x0002		/* Do not setup the station beacon timers */
 #define    IEEE80211_CLONE_WDS          0x0004      /* enable WDS processing */
@@ -2813,6 +2935,32 @@
         u_int8_t isi_tx_rate_mcs;
         u_int8_t isi_tx_rate_flags;
 #endif
+        u_int8_t isi_r_latitude[32];
+        u_int8_t isi_r_longitude[32];
+        u_int8_t isi_l_latitude[32];
+        u_int8_t isi_l_longitude[32];
+        u_int64_t isi_tx_tput;             /* Tx Thput */
+        u_int64_t isi_rx_tput;             /* Rx Thput */
+        u_int8_t isi_local_snr_a1;        /* Local SNR A1 */
+        u_int8_t isi_local_snr_a2;        /* Local SNR A2 */
+        u_int8_t isi_remote_snr_a1;        /* Remote SNR A1 */
+        u_int8_t isi_remote_snr_a2;        /* Remote SNR A2 */
+        u_int32_t  isi_ip_addr;
+        u_int32_t isi_local_phy_err;        /* Local Phy Err */
+        u_int32_t isi_remote_phy_err;       /* Remote Phy Err */
+        u_int32_t isi_local_mpdu_err;       /* Local MPDU Err */
+        u_int32_t isi_remote_mpdu_err;      /* Remote MPDU Err */
+        u_int32_t isi_local_retries;        /* Local Retries */
+        u_int32_t isi_remote_retries;       /* Remote Retries */
+        u_int8_t  isi_l_customer_name[32];
+        u_int8_t  isi_r_customer_name[32];
+        u_int8_t  isi_l_link_id;
+        u_int8_t  isi_r_link_id;
+        int16_t   isi_l_noise_floor;
+        int16_t   isi_r_noise_floor;
+        u_int8_t  isi_kwn_tx_rate_mcs;
+        u_int8_t  isi_l_ant_gain;
+        u_int8_t  isi_r_ant_gain;
 
 };
 
diff -urN qca-wifi-org/offload/os/linux/include/ol_ath.h qca-wifi-mod/offload/os/linux/include/ol_ath.h
--- qca-wifi-org/offload/os/linux/include/ol_ath.h	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/os/linux/include/ol_ath.h	2018-11-05 12:55:05.566815512 +0530
@@ -208,9 +208,9 @@
 #define ARXXXX_DEV_OTP_FILE                 "otp.bin"
 
 /* Configuration for statistics pushed by firmware */
-#define PDEV_DEFAULT_STATS_UPDATE_PERIOD    500
-#define VDEV_DEFAULT_STATS_UPDATE_PERIOD    500
-#define PEER_DEFAULT_STATS_UPDATE_PERIOD    500
+#define PDEV_DEFAULT_STATS_UPDATE_PERIOD    100
+#define VDEV_DEFAULT_STATS_UPDATE_PERIOD    100
+#define PEER_DEFAULT_STATS_UPDATE_PERIOD    100
 
 #ifdef CONFIG_AR900B_SUPPORT
 /*
diff -urN qca-wifi-org/offload/os/linux/ol_ath_iw_handler.c qca-wifi-mod/offload/os/linux/ol_ath_iw_handler.c
--- qca-wifi-org/offload/os/linux/ol_ath_iw_handler.c	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/os/linux/ol_ath_iw_handler.c	2018-07-03 13:48:53.081215623 +0530
@@ -1022,6 +1022,30 @@
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "acktimeout" },
     { OL_ATH_PARAM_TXACKTIMEOUT | OL_ATH_PARAM_SHIFT,
         0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_acktimeout" },
+    { OL_ATH_PARAM_TXDISTANCE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "distance" },
+    { OL_ATH_PARAM_TXDISTANCE | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_distance" },
+    { OL_ATH_PARAM_DYING_GASP | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dying_gasp" },
+    { OL_ATH_PARAM_DYING_GASP | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dying_gasp" },
+    { OL_ATH_PARAM_DG_TIMER_INTERVAL | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dgtimeout" },
+    { OL_ATH_PARAM_DG_TIMER_INTERVAL | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dgtimeout" },
+    { OL_ATH_PARAM_DG_ACK_DISABLE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dgackdisable" },
+    { OL_ATH_PARAM_DG_ACK_DISABLE | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dgackdisable" },
+    { OL_ATH_PARAM_LINKID | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "linkid" },
+    { OL_ATH_PARAM_STR_TYPE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "str_type" },
+    { OL_ATH_PARAM_KWN_AMSDU | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "kwn_amsdu" },
+    { OL_ATH_PARAM_KWN_AMSDU | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_kwn_amsdu" },
     { OL_ATH_PARAM_BEST_UL_HYST | OL_ATH_PARAM_SHIFT,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,       "ul_hyst" },
     { OL_ATH_PARAM_BEST_UL_HYST | OL_ATH_PARAM_SHIFT,
diff -urN qca-wifi-org/offload/wlan/include/ol_if_athvar.h qca-wifi-mod/offload/wlan/include/ol_if_athvar.h
--- qca-wifi-org/offload/wlan/include/ol_if_athvar.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/include/ol_if_athvar.h	2018-11-14 14:15:12.482491559 +0530
@@ -36,6 +36,7 @@
 #include "ieee80211_wds.h"
 #include "ieee80211_ique.h"
 #include "ieee80211_acs.h"
+#include "ieee80211_acs_internal.h"
 #include "ieee80211_csa.h"
 #include "asf_amem.h"
 #include "qdf_types.h"
@@ -340,14 +341,14 @@
 #define DEFAULT_PRINT_RATE_LIMIT_VALUE 100
 
 /*
- * Default TX ACK time out value (micro second)
- */
-#define DEFAULT_TX_ACK_TIMEOUT 0x40
-
-/*
  * Max TX ACK time out value (micro second)
  */
 #define MAX_TX_ACK_TIMEOUT 0xFF
+/*
+ * Default TX ACK time out value (micro second)
+ */
+#define DEFAULT_TX_ACK_TIMEOUT 0x40
+//#define DEFAULT_TX_ACK_TIMEOUT MAX_TX_ACK_TIMEOUT
 
 struct mute_error_types {
     u_int32_t  pn_errors;
@@ -1048,6 +1049,10 @@
 void ol_ath_vap_tx_lock(void *ptr);
 void ol_ath_vap_tx_unlock(void *ptr);
 
+
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap,u_int32_t send_ack,struct ieee80211_node *ni);
+void kwn_sa_set_channel( struct ieee80211com *ic );
+void kwn_beacon_chanutil_update( struct ieee80211vap *vap );
 int
 ol_transfer_target_eeprom_caldata(struct ol_ath_softc_net80211 *scn, u_int32_t address, bool compressed);
 
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath.c	2018-11-15 11:18:19.298277696 +0530
@@ -4488,7 +4488,7 @@
     param.cfreq1 = 0;
     param.cfreq2 = 0;
     if((chan_mode == IEEE80211_MODE_11AC_VHT80) ||(chan_mode == IEEE80211_MODE_11AC_VHT160) || (chan_mode == IEEE80211_MODE_11AC_VHT80_80)) {
-            if (chan->ic_ieee < 20)
+            if (chan->ic_freq < 4000)
                 param.cfreq1 = ieee80211_ieee2mhz(&scn->sc_ic,
                                                           chan->ic_vhtop_ch_freq_seg1, IEEE80211_CHAN_2GHZ);
             else
@@ -5221,7 +5221,7 @@
                 return ((freq * 10) +
                     (((freq % 5) == 2) ? 5 : 0) - 49400)/5;
             } else if (freq > 4900) {
-                return (freq - 4000) / 5;
+                return (freq - 3920) / 5;
             } else {
                 return 15 + ((freq - 2512) / 20);
             }
@@ -6743,6 +6743,149 @@
     OS_SET_TIMER(&ic->ic_inact_timer, IEEE80211_SESSION_WAIT*1000);
 }
 
+void kwn_calculate_best_channel( struct ieee80211com *ic, struct ieee80211vap *vap )
+{
+    u_int8_t i, utility = ic->kwn_scan.sa_result.sa_entry[0].utility;
+    u_int16_t best_freq = ic->kwn_scan.sa_result.sa_entry[0].frequency;
+    struct ieee80211_channel *c;
+
+    printk(": ACS: Calculate best channel\n");
+    for( i = 0; i < ic->kwn_scan.sa_result.cnt; i++ )
+    {
+        if( utility > ic->kwn_scan.sa_result.sa_entry[i].utility ) {
+            utility = ic->kwn_scan.sa_result.sa_entry[i].utility;
+            best_freq = ic->kwn_scan.sa_result.sa_entry[i].frequency;
+        }
+    }
+    c = kwn_find_channel( ic, vap, best_freq );
+    if( c != NULL ) {
+        printk(": ACS: Best channel %d %d \n",c->ic_ieee, c->ic_freq);
+        ic->ic_curchan = c;
+        kwn_sa_set_channel( ic );
+    }
+}
+
+static OS_TIMER_FUNC( ol_chan_util_timer_fun )
+{
+	wlan_dev_t ic;
+	wlan_if_t vap;
+	struct ol_ath_softc_net80211 *scn ;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+	ic = &scn->sc_ic;
+    vap = ic->kwn_scan.scan_vap;
+    kwn_beacon_chanutil_update( vap );
+    OS_SET_TIMER(&ic->kwn_scan.util_timer, ic->kwn_scan.util_time);
+}
+
+static OS_TIMER_FUNC( ol_scan_timer_fun )
+{
+	wlan_dev_t ic;
+	wlan_if_t vap;
+	struct ol_ath_softc_net80211 *scn ;
+    struct ieee80211_channel *c;
+    u_int16_t  curr_freq;
+    u_int8_t i, utility;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+    ic = &scn->sc_ic;
+    vap = ic->kwn_scan.scan_vap;
+  
+    if( !ic->enable_acs && !ic->enable_sa_scan ) {
+        printk(": SPECTRAL: ACS or Spectral scan is not enabled ");
+        return;
+    }
+    if( ic->kwn_scan.next_chan == KWN_SA_CHAN_MAX ) {
+        printk(": SPECTRAL: Channel list exceeds sa max list 250\n");
+        return;
+    }
+    curr_freq = ic->kwn_scan.curr_freq;
+    if( curr_freq == 0 ) {
+        printk(": SPECTRAL: SA scan is started\n");
+        curr_freq = ic->kwn_scan.start_freq;
+    }
+    else {
+        curr_freq = ic->kwn_scan.curr_freq + 5;
+    }
+    if( curr_freq > ic->kwn_scan.end_freq ) {
+        if( vap->kwnchanutil_info.total > 0 ) {
+            utility = ( u_int8_t ) ( vap->kwnchanutil_info.total / vap->kwnchanutil_info.count );
+            ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].utility = ( u_int8_t ) ( ( utility * 100 ) / 255 );
+        }
+        ic->kwn_scan.sa_result.cnt = ic->kwn_scan.next_chan;
+        ic->kwn_scan.scan_vap = NULL;
+        OS_CANCEL_TIMER(&ic->kwn_scan.util_timer);
+        OS_CANCEL_TIMER(&ic->kwn_scan.scan_timer);
+        printk(": SPECTRAL: SA scan is stopped\n");
+        printk("#######################################\n");
+        printk("Frequency Channel Utility\n");
+        for( i = 0; i < ic->kwn_scan.sa_result.cnt; i++ )
+        {
+            printk("%d       %d       %d \n",ic->kwn_scan.sa_result.sa_entry[i].frequency,ic->kwn_scan.sa_result.sa_entry[i].channel,ic->kwn_scan.sa_result.sa_entry[i].utility);
+        }
+        printk("#######################################\n");
+        if( ic->enable_acs )
+            kwn_calculate_best_channel( ic, vap );
+        if( ic->enable_sa_scan ) {
+            printk(": SPECTRAL: Revert back to operating frequnecy %d \n",ic->kwn_scan.oper_freq);
+            c = kwn_find_channel(ic, vap, ic->kwn_scan.oper_freq );
+            ic->ic_curchan = c;
+            kwn_sa_set_channel( ic );
+        }
+        ic->kwn_scan.start_scan = 0;
+        ic->enable_sa_scan = 0;
+        ic->enable_acs = 0;
+        return;
+    }
+    if( ic->kwn_scan.next_chan != 0 ) {
+        if( vap->kwnchanutil_info.total > 0 ) {
+            utility = ( u_int8_t ) ( vap->kwnchanutil_info.total / vap->kwnchanutil_info.count );
+            ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].utility = ( u_int8_t ) ( ( utility * 100 ) / 255 );
+        }
+    }
+    ic->kwn_scan.curr_freq = curr_freq;
+    memset( &vap->kwnchanutil_info, 0, sizeof( struct kwn_chanutil_info ) );
+    c = kwn_find_channel( ic, vap, ic->kwn_scan.curr_freq );
+    if( c != NULL ) {
+        ic->ic_curchan = c;
+        ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan].channel = ic->ic_curchan->ic_ieee;
+        ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan].frequency = ic->ic_curchan->ic_freq;
+        printk(": SPECTRAL: Set Channel %d %d \n",ic->ic_curchan->ic_ieee, ic->ic_curchan->ic_freq);
+        kwn_sa_set_channel( ic );
+    }
+    ic->kwn_scan.next_chan++;
+    ic->kwn_scan.sa_result.cnt = ic->kwn_scan.next_chan;
+    OS_SET_TIMER(&ic->kwn_scan.util_timer, ic->kwn_scan.util_time);
+    OS_SET_TIMER(&ic->kwn_scan.scan_timer, ic->kwn_scan.scan_time);
+}
+
+void kwn_get_ol_stats( struct ieee80211vap *vap, struct ieee80211com *ic )
+{
+    struct ol_ath_softc_net80211 *scn;
+	struct ol_stats *stats;
+
+    scn = OL_ATH_SOFTC_NET80211(ic);
+
+	stats = OS_MALLOC(&scn->sc_osdev,
+			sizeof(struct ol_stats), GFP_KERNEL);
+	if (stats == NULL)
+		return;
+	TAILQ_FOREACH(vap, &ic->ic_vaps, iv_next) {
+        if (vap != NULL) {
+            ol_get_wlan_dbg_stats( scn, &stats->stats );
+            ol_get_radio_stats( scn, &stats->interface_stats );
+            vap->kwn_local_snr_a1 = stats->interface_stats.rx_rssi_chain0.rx_rssi_pri20 > 128 ? 0 : stats->interface_stats.rx_rssi_chain0.rx_rssi_pri20;
+            vap->kwn_local_snr_a2 = stats->interface_stats.rx_rssi_chain1.rx_rssi_pri20 > 128 ? 0 : stats->interface_stats.rx_rssi_chain1.rx_rssi_pri20;
+            vap->kwn_local_noise_floor = stats->interface_stats.chan_nf;
+            vap->kwn_local_phy_err = stats->stats.rx.phy_errs;
+            vap->kwn_local_mpdu_err = stats->stats.rx.mpdu_errs;
+            vap->kwn_local_retries = stats->stats.tx.mpdus_requed;
+            break;
+        }
+	}
+	OS_FREE(stats);
+}
+
 static int
 ol_ath_set_mgmt_retry_limit(struct ieee80211com *ic , u_int8_t limit)
 {
@@ -7156,6 +7299,7 @@
     ic->ic_atf_logging = 0;
 
     ic->ic_bestUL_hyst = BEST_UL_HYST_DEF;
+    ic->ic_kwn_get_ol_stats = kwn_get_ol_stats;
 
     return EOK;
 }
@@ -8133,6 +8277,8 @@
                                                 ol_ath_esp_estimate_event_handler, WMI_RX_UMAC_CTX);
 #endif
 
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_scan.scan_timer, ol_scan_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_scan.util_timer, ol_chan_util_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
 #if OL_ATH_SUPPORT_LED
         if (scn->target_version == AR9888_REV2_VERSION || scn->target_version == AR9887_REV1_VERSION) {
             scn->scn_led_gpio = PEREGRINE_LED_GPIO ;
@@ -8475,6 +8621,8 @@
     u_int32_t num_mem_chunks;
     ic = &scn->sc_ic;
 
+    OS_FREE_TIMER(&ic->kwn_scan.scan_timer);
+    OS_FREE_TIMER(&ic->kwn_scan.util_timer);
 #if ATH_DATA_TX_INFO_EN
     /*Free buffer for data TX info*/
     qdf_mem_free(scn->tx_status_buf);
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath_config.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath_config.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath_config.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath_config.c	2018-07-03 13:49:28.129213945 +0530
@@ -53,6 +53,8 @@
 #endif
 void ol_ath_reset_vap_stat(struct ieee80211com *ic);
 uint32_t promisc_is_active (struct ieee80211com *ic);
+extern void (*intimate_dying_gasp)(void *arg);
+extern void dying_gasp_fn ( void * arg ) ;
 
 extern int ol_ath_target_start(struct ol_ath_softc_net80211 *scn);
 extern void ol_ath_dump_target(struct ol_ath_softc_net80211 *scn);
@@ -1839,7 +1841,67 @@
             }
             break;
 #endif /* OL_ATH_CE_DEBUG */
-        case OL_ATH_PARAM_TXACKTIMEOUT:
+	case OL_ATH_PARAM_DYING_GASP:
+            {
+                if (value < 1 || value > 2) {
+                    retval = -EINVAL;
+                }
+                ic->dying_gasp = value;
+    		/*Dying gasp initialization only when enabled */
+		if ( value == 1) {
+    			intimate_dying_gasp = dying_gasp_fn;
+			printk("%s:Dying gasp enabled---->HZ: %d \n",__func__,HZ);
+		}
+		else if ( value == 2) {
+    			intimate_dying_gasp = NULL;
+			printk("%s:Dying gasp disabled---->HZ: %d \n",__func__,HZ);
+		}
+            }
+	    break;
+        case OL_ATH_PARAM_DG_TIMER_INTERVAL:
+            {
+            	ic->ic_dg_timer_interval = value;
+            }
+            break;
+        case OL_ATH_PARAM_DG_ACK_DISABLE:
+            {
+            	ic->ic_dg_ack_disable = value;
+            }
+            break;
+        case OL_ATH_PARAM_LINKID:
+            {
+            	ic->ic_link_id = value;
+            }
+            break;
+        case OL_ATH_PARAM_STR_TYPE:
+            {
+            	ic->ic_str_type = value;
+            }
+            break;
+	case OL_ATH_PARAM_KWN_AMSDU:
+            {
+                if (value < 1 || value > 2) {
+                    retval = -EINVAL;
+                }
+                ic->kwn_amsdu = value;
+            }
+            break;
+	case OL_ATH_PARAM_TXDISTANCE: 
+	    value = value * 1000; //Distance in meters
+	    if ( value >= 0 && value < 53100 ) {
+		    u_int32_t acktimeout = (9+(value/300) + ((value % 300)?1:0));
+		    acktimeout = acktimeout * 2 + 3;
+
+		    if (acktimeout < DEFAULT_TX_ACK_TIMEOUT )
+			    acktimeout = DEFAULT_TX_ACK_TIMEOUT;
+		    else if (acktimeout > MAX_TX_ACK_TIMEOUT)
+			    acktimeout = MAX_TX_ACK_TIMEOUT;
+		    (void)ol_ath_pdev_set_param(scn,
+				    wmi_pdev_param_tx_ack_timeout, acktimeout, 0);
+		    scn->tx_ack_timeout = acktimeout;
+	    } 
+	    break;
+	case OL_ATH_PARAM_TXACKTIMEOUT:
             {
                 if ((scn->target_type == TARGET_TYPE_AR900B) || (scn->target_type == TARGET_TYPE_QCA9984) ||
                    (scn->target_type == TARGET_TYPE_QCA9888) || (scn->target_type == TARGET_TYPE_IPQ4019))
@@ -2374,6 +2436,25 @@
             }
             break;
 #endif /* OL_ATH_CE_DEBUG */
+        case OL_ATH_PARAM_DYING_GASP:
+                *(int *)buff = ic->dying_gasp;
+	    break;
+        case OL_ATH_PARAM_DG_TIMER_INTERVAL:
+            {
+            	*(int *)buff = ic->ic_dg_timer_interval;
+            }
+            break;
+        case OL_ATH_PARAM_KWN_AMSDU:
+                *(int *)buff = ic->kwn_amsdu;
+	    break;
+        case OL_ATH_PARAM_DG_ACK_DISABLE:
+            {
+            	*(int *)buff = ic->ic_dg_ack_disable ;
+            }
+            break;
+        case OL_ATH_PARAM_TXDISTANCE:
+                *(int *)buff = scn->tx_ack_timeout;
+	    break;
         case OL_ATH_PARAM_TXACKTIMEOUT:
             if ((scn->target_type == TARGET_TYPE_AR900B) || (scn->target_type == TARGET_TYPE_QCA9984) ||
                (scn->target_type == TARGET_TYPE_QCA9888) || (scn->target_type == TARGET_TYPE_IPQ4019))
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_vap.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_vap.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_vap.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_vap.c	2018-11-15 11:19:32.486305148 +0530
@@ -32,6 +32,7 @@
 #if ATH_SUPPORT_GREEN_AP
 #include "ath_green_ap.h"
 #endif
+#include <linux/inetdevice.h>
 
 #define DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS  (IEEE80211_INACT_RUN * IEEE80211_INACT_WAIT)
 #define DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_IDLE_TIME_SECS          (DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS - 5)
@@ -65,6 +66,8 @@
 #define MAX_UNRESPONSIVE_TIME_MIN_THRESHOLD_SECS  5
 #define MAX_UNRESPONSIVE_TIME_MAX_THRESHOLD_SECS  (u_int16_t)~0
 
+struct timer_list       dg_timer;
+extern int dg_ack_rcvd;
 extern int ol_ath_set_vap_dscp_tid_map(struct ieee80211vap *vap);
 extern int ol_ath_ucfg_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
 static int wlan_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid)
@@ -728,6 +731,42 @@
 }
 #endif
 
+static int
+ol_kwn_ath_vap_set_param( struct ieee80211vap *vap,
+        ieee80211_param param, u_int32_t val )
+{
+    struct ieee80211com *ic = vap->iv_ic;
+    struct ol_ath_softc_net80211 *scn = OL_ATH_SOFTC_NET80211( ic );
+    struct ol_ath_vap_net80211 *avn = OL_ATH_VAP_NET80211( vap );
+    int retval = 0;
+
+    switch ( param ) {
+        case IEEE80211_FIXED_RATE:
+            {
+                if( vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_NONE ) {
+                    val = WMI_HOST_FIXED_RATE_NONE;
+                }
+                //printk(": WMI: HT Rate set val %d\n",val);
+                retval = ol_ath_wmi_send_vdev_param( scn, avn->av_if_id,
+                        wmi_vdev_param_fixed_rate, val );
+            }
+            break;
+        case IEEE80211_FIXED_VHT_MCS:
+            {
+                if( vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_NONE ) {
+                    val = WMI_HOST_FIXED_RATE_NONE;
+                }
+                //printk(": WMI: VHT Rate Set val %d \n",val);
+                retval = ol_ath_wmi_send_vdev_param( scn,avn->av_if_id,
+                        wmi_vdev_param_fixed_rate, val );
+            }
+            break;
+        default:
+            break;
+    }
+    return retval;
+}
+
 /* Vap interface functions */
 static int
 ol_ath_vap_set_param(struct ieee80211vap *vap,
@@ -852,6 +891,7 @@
                     }
                     val = (preamble << 6) | (nss << 4) | rix;
                 }
+                //printk(": WMI: HT Rate Set preamble %d nss %d rix %d val %d \n",preamble,nss,rix,val);
                 retval = ol_ath_wmi_send_vdev_param(scn,avn->av_if_id,
                                               wmi_vdev_param_fixed_rate, val);
            }
@@ -860,6 +900,9 @@
            {
                 if (vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_VHT) {
                     val = (WMI_HOST_RATE_PREAMBLE_VHT << 6) | ((vap->iv_nss -1) << 4) | vap->iv_vht_fixed_mcs;
+                    //printk(": WMI: VHT Rate set val %d \n",val);
+                    ol_ath_wmi_send_vdev_param( scn, avn->av_if_id,
+                            wmi_vdev_param_nss, vap->iv_nss);
                 }
                 else {
                     /* Note: Event though val is 32 bits, only the lower 8 bits matter */
@@ -3254,7 +3297,18 @@
     vap->iv_256qam = 1;
 
     vap->iv_no_cac = 0;
-
+    /* Reset link profile tx parameters */
+    vap->kwn_txparam.spatial_stream = KWN_STREAM_AUTO;
+    vap->kwn_txparam.min_rate = 0;
+    vap->kwn_txparam.max_rate = 0;
+    vap->kwn_txparam.inc_timer = 2;
+    vap->kwn_txparam.dec_timer = 1;
+    vap->kwn_txparam.atpc_status = 0;
+    vap->kwn_txparam.power = 26;
+
+    /* Initialize SCAN Parameters */
+    ic->kwn_scan.sa_scan_time = 1000;
+    ic->kwn_scan.acs_scan_time = 1000;
     /* Intialize VAP interface functions */
     vap->iv_up = ol_ath_vap_up;
     vap->iv_join = ol_ath_vap_join;
@@ -3534,12 +3588,16 @@
 {
     struct ol_ath_vap_net80211 *avn = OL_ATH_VAP_NET80211(vap);
     struct ol_ath_softc_net80211 *scn = avn->av_sc;
+    struct ieee80211com *ic;
 
     if (!vap) {
         qdf_print("VAP is NULL!!!\n");
         return;
     }
 
+    ic = vap->iv_ic;
+    OS_FREE_TIMER(&ic->kwn_scan.scan_timer);
+    OS_FREE_TIMER(&ic->kwn_scan.util_timer);
     /* delete key before vdev delete */
     delete_default_vap_keys(vap);
 
@@ -3717,6 +3775,69 @@
     return 0;
 }
 
+void dying_gasp_fn ( void * arg ) {
+#define IEEE80211_EV_BASE_DYING_GASP 46
+    struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+
+    if ( dev != NULL ) {
+        osif_dev  *osdev = ath_netdev_priv(dev);
+        wlan_if_t vap = osdev->os_if;
+
+        if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP ) {
+            struct ieee80211com *ic = vap->iv_ic;
+            struct net_device *dev_br;
+            struct ieee80211_node   *ni = NULL; 
+            union iwreq_data wreq = {{0}};
+            u_int32_t ip;
+
+            ni = vap->iv_bss;
+            /* find netdev by name, increment refcnt */
+            dev_br = dev_get_by_name(&init_net,"br-lan");
+            if (!dev_br) { 
+                printk("Unable to fetch IP Address\n");
+                return;
+            }
+            /* get ip addr from rtable (global scope) */
+            ip = inet_select_addr(dev_br, 0, RT_SCOPE_UNIVERSE);
+            /* decrement netdev refcnt */
+            dev_put(dev_br);
+            /* Send an event to apl as dying gasp packet */
+            if( ni->dg_count == 0 ) 
+            {
+                memset(&wreq, 0, sizeof(wreq));
+                wreq.addr.sa_family = ARPHRD_ETHER;
+                memcpy(wreq.addr.sa_data, ni->ni_macaddr, 6);
+                wreq.addr.sa_data[6] = IEEE80211_EV_BASE_DYING_GASP;
+                wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+            }
+            printk("Outdoor Base [Time stamp : %9lu][Cus name:%s][Link id:%d][%d.%d.%d.%d] --> pkt count %d \n",
+                    jiffies, ic->ic_customer_name,ic->ic_link_id,
+                    (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF,
+                    ni->dg_count++);
+        }
+        ieee80211_send_dying_gasp( vap , 0, NULL );
+        //printk("dg_ack_rcvd : %d \n",dg_ack_rcvd);	
+        //printk("vap->iv_ic->ic_dg_timer_interval = %d,HZ = %d,jiffies = %9lu , Next jiffies = %9lu \n",vap->iv_ic->ic_dg_timer_interval,HZ,jiffies, 
+        //	jiffies+(vap->iv_ic->ic_dg_timer_interval*HZ/1000));
+        if(!dg_ack_rcvd) {
+            //printk("Reset timer\n");
+            mod_timer(&dg_timer,jiffies+(vap->iv_ic->ic_dg_timer_interval*HZ/1000));
+        }
+        else {
+            //printk("Delete timer\n");
+            del_timer(&dg_timer);
+        }
+
+        dev_put(dev);
+    }
+    return ;
+}
+
+void dying_gasp_timer ( unsigned long  arg )
+{
+	struct ol_ath_softc_net80211 *scn = ( struct ol_ath_softc_net80211 *)arg;
+	dying_gasp_fn(scn);
+}
 /* Intialization functions */
 void
 ol_ath_vap_attach(struct ieee80211com *ic)
@@ -3728,6 +3849,7 @@
     ic->ic_vap_alloc_macaddr = ol_ath_vap_alloc_macaddr;
     ic->ic_vap_free_macaddr = ol_ath_vap_free_macaddr;
     ic->ic_vap_set_param = ol_ath_vap_set_param;
+    ic->ic_kwn_vap_set_param = ol_kwn_ath_vap_set_param;
     ic->ic_vap_sifs_trigger = ol_ath_vap_sifs_trigger;
     ic->ic_vap_set_ratemask = ol_ath_vap_set_ratemask;
     ic->ic_vap_dyn_bw_rts = ol_ath_vap_dyn_bw_rts;
@@ -3754,6 +3876,7 @@
         ath_green_ap_start(ic);
     }
 #endif  /* ATH_SUPPORT_GREEN_AP */
+   setup_timer(&dg_timer, dying_gasp_timer, (unsigned long)scn );
 }
 
 
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain.c qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.c
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.c	2018-07-22 10:56:39.796784660 +0530
@@ -1525,12 +1525,21 @@
     if (regdmn == OVERRIDE_RD && ol_regdmn_duplicate_channel(icv, chans, *next+1))
         return;
     icv->ic_ieee = ol_ath_mhz2ieee(ic, icv->ic_freq, icv->ic_flags);
+#if 0
     if(vht_ch_freq_seg1) {
         icv->ic_vhtop_ch_freq_seg1 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg1, icv->ic_flags);
     }
     else {
         icv->ic_vhtop_ch_freq_seg1 = 0;
     }
+#else
+    if( cm->mode == REGDMN_MODE_11AC_VHT80 ) {
+        icv->ic_vhtop_ch_freq_seg1 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg1, icv->ic_flags);
+    }
+    else {
+        icv->ic_vhtop_ch_freq_seg1 = 0;
+    }
+#endif
     if(vht_ch_freq_seg2) {
         icv->ic_vhtop_ch_freq_seg2 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg2, icv->ic_flags);
     }
@@ -1566,13 +1575,14 @@
     u_int16_t chanSep;
     ol_scn_t scn_handle;
     struct ieee80211com *ic;
-    u_int32_t ch144, ch144_eppr_ovrd;
+    //int i;
+    //u_int32_t ch144, ch144_eppr_ovrd;
 
     struct ol_ath_softc_net80211 *scn = NULL;
     scn_handle = ol_regdmn_handle->scn_handle;
     ic = &scn_handle->sc_ic;
     sec_channel_count = 0;
-    ch144_eppr_ovrd = 0;
+    //ch144_eppr_ovrd = 0;
 
     scn = OL_ATH_SOFTC_NET80211(ic);
     /*
@@ -1898,6 +1908,7 @@
         // Walk through the 5G band to find 80 Mhz channel
         else  if ((cm->mode == REGDMN_MODE_11AC_VHT80) && (rd == &rd5GHz))
         {
+#if 0
             ol_regdmn_init_vht80_chan(&vht80_chans);
 
             if (regdmn != OVERRIDE_RD) {
@@ -1925,6 +1936,10 @@
                 ol_regdmn_add_vht80_chan(&vht80_chans, 5690);
                 ol_regdmn_add_vht80_chan(&vht80_chans, 5775);
             }
+#else
+                hi_adj = -30;
+                low_adj = 30;
+#endif
         }
 
         if(rd == &rd2GHz) {
@@ -1959,6 +1974,7 @@
                     (!is_49ghz_cap) && (regdmn != OVERRIDE_RD))
                     continue;
 
+#if 0
                 if (((IS_HT40_MODE(cm->mode)) || (IS_VHT40_MODE(cm->mode))) && (rd == &rd5GHz)) {
                     /* For 5G HT40 mode, channel seperation should be 40. */
                     chanSep = 40;
@@ -1993,7 +2009,9 @@
                         }
                     }
                 }
-
+#else
+                    chanSep = fband->channelSep;
+#endif
                 for (c=fband->lowChannel + low_adj;
                      ((c <= (fband->highChannel + hi_adj)) &&
                       (c >= (fband->lowChannel + low_adj)));
@@ -2069,6 +2087,7 @@
                         QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Skipping HT40 channel (en_jap_dfs_ht40 = 0)\n");
                         continue;
                     }
+#if 0
                     if(rd == &rd5GHz)
                     {
                         /*
@@ -2125,7 +2144,7 @@
                             }
                         }
                     }
-
+#endif
                     OS_MEMZERO(&icv, sizeof(icv));
                     if(cm->mode == REGDMN_MODE_11AC_VHT80_80) {
 
@@ -2188,16 +2207,18 @@
                          * For all 4.9G, VHT80 is not allowed.
                          * Except for CTRY_DEBUG.
                          */
-                        if ((fband->lowChannel < 5180) && (cc != CTRY_DEBUG) && (regdmn != OVERRIDE_RD)) {
+                        if ((fband->lowChannel < 4920) && (cc != CTRY_DEBUG) && (regdmn != OVERRIDE_RD)) {
                             continue;
                         }
-
+#if 0
                         if(!ol_regdmn_find_vht80_chan(&vht80_chans, c, &vht_ch_freq_seg1)) {
                             if (regdmn != OVERRIDE_RD){
                                 QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, KERN_INFO"Skipping VHT80 channel %d\n", c);
                             }
                             continue;
                         }
+#endif
+                        vht_ch_freq_seg1 = c;
                         vht_ch_freq_seg2 = 0;
                         if (ol_validate_restricted_channel(scn_handle, cm, c, vht_ch_freq_seg1, vht_ch_freq_seg2)) {
                             populate_icv(&icv, c, vht_ch_freq_seg1, vht_ch_freq_seg2, fband, 0,  cm, rd, rd5GHz, dfsDomain, scn_handle, regdmn, chans, &next);
@@ -2234,6 +2255,16 @@
 
     ieee80211_set_nchannels(ic, next);
 
+    {
+	    uint32_t m;
+	    for( m = 0; m < ic->ic_nchans; m++ )
+	    {
+		    if( m == 0 )
+			    ic->kwn_start_freq = ic->ic_channels[m].ic_freq;	
+		    ic->kwn_end_freq = ic->ic_channels[m].ic_freq;	
+	    }
+	    ic->kwn_curr_freq = ic->kwn_start_freq;
+    }
     /* save for later query */
     ol_regdmn_handle->ol_regdmn_currentRDInUse = regdmn;
     ol_regdmn_handle->ol_regdmn_currentRD5G = rd5GHz.regDmnEnum;
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain_common.h qca-wifi-mod/offload/wlan/regdmn/ol_regdomain_common.h
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain_common.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain_common.h	2018-07-22 10:56:59.119119498 +0530
@@ -52,6 +52,14 @@
 	NO_ENUMRD	= 0x00,
     OVERRIDE_RD = 0x01,
 	NULL1_WORLD	= 0x03,		/* For 11b-only countries (no 11a allowed) */
+	SF_RUSSIA_49_51 = 0x04,		/* Sify custom  */
+	SF_RUSSIA_51_53 = 0x05,		/* Sify custom */
+	SF_RUSSIA_53_56 = 0x06,		/* Sify custom */
+	SF_RUSSIA_56_58 = 0x09,		/* Sify custom */
+	SF_RUSSIA_58_59 = 0x24,		/* Sify custom */
+	SF_INDIA_UL     = 0x25,		/* Sify custom */
+	SF_INDIA_L      = 0x27,		/* Sify custom */
+
 	NULL1_ETSIB	= 0x07,		/* Israel */
 	NULL1_ETSIC	= 0x08,
 	FCC1_FCCA	= 0x10,		/* USA */
@@ -216,7 +224,14 @@
 
 	NULL1		= 0x0198,
 	WORLD		= 0x0199,
-	DEBUG_REG_DMN	= 0x01ff,
+    DEBUG_REG_DMN	= 0x01ff,
+    RUSSIA01    = 0x0201,   /* Sify custom */ 
+    RUSSIA02    = 0x0202,   /* Sify custom */
+    RUSSIA03    = 0x0203,   /* Sify custom */
+    RUSSIA04    = 0x0204,   /* Sify custom */
+    RUSSIA05    = 0x0205,   /* Sify custom */
+    INDIAUL     = 0x0206,   /* Sify custom */
+    INDIAL      = 0x0207,   /* Sify custom */
     OVER1_OVERA = 0x0200,
 };
 
@@ -354,6 +369,13 @@
 	{WORA_WORLD,	WORA_WORLD,	WORA_WORLD,	DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{WORB_WORLD,	WORB_WORLD,	WORB_WORLD,	DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{WORC_WORLD,	WORC_WORLD,	WORC_WORLD,	NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+	{SF_RUSSIA_49_51,	RUSSIA01,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_51_53,	RUSSIA02,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_53_56,	RUSSIA03,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_56_58,	RUSSIA04,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_58_59,	RUSSIA05,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_INDIA_UL,	    INDIAUL,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },  /* Sify custom */
+	{SF_INDIA_L,	    INDIAL,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }  /* Sify custom */
 };
 
 /*
@@ -561,7 +583,14 @@
     {CTRY_VIRGIN_ISLANDS, FCC3_FCCA,  "VI", "VIRGIN ISLANDS", YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_WALLIS_FUTUNA, ETSI1_WORLD, "WF", "WALLIS AND FUTUNA", YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, NO, NO, 7000 },
-    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  YES,  YES, YES, YES, YES, 7000 }
+    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  YES,  YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_1, SF_RUSSIA_49_51,  "S1", "RUSSIA1",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_2, SF_RUSSIA_51_53,  "S2", "RUSSIA2",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_3, SF_RUSSIA_53_56,  "S3", "RUSSIA3",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_4, SF_RUSSIA_56_58,  "S4", "RUSSIA4",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_5, SF_RUSSIA_58_59,  "S5", "RUSSIA5",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_INDIA_UL,     SF_INDIA_UL,  "S6", "INDIA1",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_INDIA_L,      SF_INDIA_L,   "S7", "INDIA2",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 }
 };
 
 
@@ -705,6 +734,13 @@
 	W1_5260_5320,
 	W1_5745_5825,
 	W1_5500_5700,
+    RU_4920_5925,
+    RU_5150_5350,   /* Sify custom */
+    RU_5350_5600,   /* Sify custom */
+    RU_5600_5850,   /* Sify custom */
+    RU_5850_5925,   /* Sify custom */
+    INUL_5825_5875,   /* Sify custom */
+    INL_5725_5875,   /* Sify custom */
 	A_DEMO_ALL_CHANNELS,
     OVERRIDE_MODE_ALL_CHANNELS_5,
     OVERRIDE_MODE_ALL_CHANNELS_10,
@@ -844,6 +880,15 @@
 	{ 5260, 5320, 30, 0, 20, 20, DFS_FCC3 | DFS_ETSI, PSCAN_WWR, 0 },		/* W1_5260_5320 */
 	{ 5745, 5825, 30, 0, 20, 20, NO_DFS, PSCAN_WWR, 0 },				/* W1_5745_5825 */
 	{ 5500, 5700, 30, 0, 20, 20, DFS_FCC3 | DFS_ETSI, PSCAN_WWR, 0 },		/* W1_5500_5700 */
+
+    { 4920, 5925, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_4920_5925 custom */
+    { 5150, 5350, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5150_5350 custom */
+    { 5350, 5600, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5350_5600 custom */
+    { 5600, 5850, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5600_5850 custom */
+    { 5850, 5925, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5850_5925 custom */
+    { 5825, 5875, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* INUL_5825_5875 custom */
+    { 5725, 5875, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* INL_5725_5875 custom */
+
 	{ 4920, 6100, 30, 6, 20, 20, NO_DFS, NO_PSCAN, 0 },				/* A_DEMO_ALL_CHANNELS */
     { 4920, 6100, 50, 20, 20, 5,  DFS_FCC3 | DFS_ETSI | DFS_MKK4, NO_PSCAN, 0 },             /* OVERRIDE_MODE_ALL_CHANNELS_5 */
     { 4920, 6100, 50, 20, 20, 10, DFS_FCC3 | DFS_ETSI | DFS_MKK4, NO_PSCAN, 0 },             /* OVERRIDE_MODE_ALL_CHANNELS_10 */
@@ -1221,6 +1266,70 @@
      CHAN_TURBO_G_BMZERO
      },
 
+    {RUSSIA01, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_4920_5925, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA02, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5150_5350, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA03, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5350_5600, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA04, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5600_5850, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA05, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5850_5925, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIAUL, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(INUL_5825_5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIAL, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(INL_5725_5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+
 #ifndef ATH_NO_5G_SUPPORT
 	{APL1, FCC, NO_DFS, NO_PSCAN, NO_REQ,
 	 BM(F4_5745_5825, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain.h qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.h
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.h	2018-07-03 10:12:53.956984596 +0530
@@ -1063,7 +1063,14 @@
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
     CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
     CTRY_ARGENTINA2           = 5003,    /* Argentina for AP only */
-    CTRY_INDIA2               = 5006     /* India with 5.9GHz support */
+    CTRY_INDIA2               = 5006,    /* India with 5.9GHz support */
+    CTRY_RUSSIA_1             = 5011,    /* Russia 4920-5150 support */
+    CTRY_RUSSIA_2             = 5012,    /* Russia 5150-5350 support */
+    CTRY_RUSSIA_3             = 5013,    /* Russia 5350-5600 support */
+    CTRY_RUSSIA_4             = 5014,    /* Russia 5600-5850 support */
+    CTRY_RUSSIA_5             = 5015,    /* Russia 5850-5925 support */
+    CTRY_INDIA_UL             = 5016,    /* India 5825-5875 support */
+    CTRY_INDIA_L              = 5017     /* India 5725-5875 support */
 };
 
 
diff -urN qca-wifi-org/offload/wlan/txrx/ol_rx.c qca-wifi-mod/offload/wlan/txrx/ol_rx.c
--- qca-wifi-org/offload/wlan/txrx/ol_rx.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/txrx/ol_rx.c	2018-10-31 18:37:41.938775099 +0530
@@ -1377,7 +1377,48 @@
         }
     }
 #endif
+#if 0
+    /* Updating Local SNR per node */
+    {
+        struct ieee80211_node *ni = NULL;
+        struct ieee80211vap *vap = NULL;
+        u_int8_t i;
+        void *rx_desc = htt_rx_msdu_desc_retrieve( pdev->htt_pdev, deliver_list_head );
+        uint32_t ppdu_start;
+        uint32_t *ppdu;
+
+        ppdu_start = pdev->htt_pdev->ar_rx_ops->get_ppdu_start_word( rx_desc );
+        ppdu = &ppdu_start;
 
+        vap = ol_ath_getvap( vdev );
+        ni = ieee80211_vap_find_node( vap, peer->mac_addr.raw );
+        if( ni ) {
+            if( ni->kwn_snr_avg.snr_indx > KWN_SNR_SAMPLES_MAX )
+                ni->kwn_snr_avg.snr_indx = 0;
+            if( ni->kwn_snr_avg.sample_count < KWN_SNR_SAMPLES_MAX )
+                ni->kwn_snr_avg.sample_count++;
+            //printk(" ppdu %x %x %x %x %x %x %x %x %x %x %x \n",ppdu[0],ppdu[1],ppdu[2],ppdu[3],ppdu[4],ppdu[5],ppdu[6],ppdu[7],ppdu[8],ppdu[9],ppdu[10]);
+            for (i = 0; i < IEEE80211_MAX_ANTENNA; i++) {
+                switch(i) {
+                    case 0:
+                        ni->kwn_snr_avg.local_snr[i][ni->kwn_snr_avg.snr_indx] = (ppdu[1] & 0x000000ff ); /* rssi ctl0 */
+                        break;
+                    case 1:
+                        ni->kwn_snr_avg.local_snr[i][ni->kwn_snr_avg.snr_indx] = ( ppdu[2] & 0x000000ff ); /* rssi ctl1 */
+                        break;
+                    case 2:
+                        ni->kwn_snr_avg.local_snr[i][ni->kwn_snr_avg.snr_indx] = ( ppdu[3] & 0x000000ff ); /* rssi ctl2 */;
+                        break;
+                    default:
+                        break;
+                }
+            }
+            ni->kwn_snr_avg.snr_indx++;
+            /* remove extra node ref count added by find_node above */
+            ieee80211_free_node(ni);
+        }
+    }
+#endif
     vdev->osif_rx(vdev->osif_vdev, deliver_list_head);
 #if OL_ATH_SUPPORT_LED
     {
diff -urN qca-wifi-org/offload/wlan/umac_offload_if/ol_if_mgmt.c qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_mgmt.c
--- qca-wifi-org/offload/wlan/umac_offload_if/ol_if_mgmt.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_mgmt.c	2018-10-31 18:37:55.558713653 +0530
@@ -204,6 +204,7 @@
     if (IEEE80211_VAP_IS_SAFEMODE_ENABLED(ni->ni_vap)) {
         param.safe_mode_enabled = TRUE;
     }
+#if 0
       /* Disable AMSDU for station transmit, if user configures it */
     if ((vap->iv_opmode == IEEE80211_M_STA) && (ic->ic_sta_vap_amsdu_disable) &&
         !(ni->ni_flags & IEEE80211_NODE_VHT)) {
@@ -214,6 +215,13 @@
         (ni->ni_flags & IEEE80211_NODE_HT) && (!(IEEE80211_NODE_USE_VHT(ni))) ) {
         param.amsdu_disable = TRUE;
     }
+#endif
+    if( ic-> kwn_amsdu == 1 ) {
+        param.amsdu_disable = FALSE;
+    }
+    else {
+        param.amsdu_disable = TRUE;
+    }
     param.peer_caps = ni->ni_capinfo;
     param.peer_listen_intval = ni->ni_lintval;
     param.peer_ht_caps = ni->ni_htcap;
diff -urN qca-wifi-org/offload/wlan/umac_offload_if/ol_if_scan.c qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_scan.c
--- qca-wifi-org/offload/wlan/umac_offload_if/ol_if_scan.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_scan.c	2018-07-26 18:32:49.533035382 +0530
@@ -975,7 +975,7 @@
     return EINVAL;
 
 }
-
+#if 0
 static const u_int16_t default_scan_order[] = {
     /* 2.4Ghz ch: 1,6,11,7,13 */
     2412, 2437, 2462, 2442, 2472,
@@ -1007,7 +1007,36 @@
     /* Add MKK quarter-rates */
     4912, 4917, 4922, 4927, 4932, 4937, 5032, 5037, 5042, 5047, 5052, 5057,
 };
-
+#else
+static const u_int16_t default_scan_order[] = {
+    2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 
+    2462, 2467, 2472, 2477, 2482, 2487, 2492, 2497,
+    4920, 4925, 4930, 4935, 4940, 4945, 4950, 4955, 4960, 4965,
+    4970, 4975, 4980, 4985, 4990, 4995, 5000, 5005, 5010, 5015,
+    5020, 5025, 5030, 5035, 5040, 5045, 5050, 5055, 5060, 5065,
+    5070, 5075, 5080, 5085, 5090, 5095, 5100, 5105, 5110, 5115,
+    5120, 5125, 5130, 5135, 5140, 5145, 5150, 5155, 5160, 5165,
+    5170, 5175, 5180, 5185, 5190, 5195, 5200, 5205, 5210, 5215, 
+    5220, 5225, 5230, 5235, 5240, 5245, 5250, 5255, 5260, 5265, 
+    5270, 5275, 5280, 5285, 5290, 5295, 5300, 5305, 5310, 5315, 
+    5320, 5325, 5330, 5335, 5340, 5345, 5350, 5355, 5360, 5365, 
+    5370, 5375, 5380, 5385, 5390, 5395, 5400, 5405, 5410, 5415, 
+    5420, 5425, 5430, 5435, 5440, 5445, 5450, 5455, 5460, 5465, 
+    5470, 5475, 5480, 5485, 5490, 5495, 5500, 5505, 5510, 5515, 
+    5520, 5525, 5530, 5535, 5540, 5545, 5550, 5555, 5560, 5565, 
+    5570, 5575, 5580, 5585, 5590, 5595, 5600, 5605, 5610, 5615, 
+    5620, 5625, 5630, 5635, 5640, 5645, 5650, 5655, 5660, 5665, 
+    5670, 5675, 5680, 5685, 5690, 5695, 5700, 5705, 5710, 5715, 
+    5720, 5725, 5730, 5735, 5740, 5745, 5750, 5755, 5760, 5765, 
+    5770, 5775, 5780, 5785, 5790, 5795, 5800, 5805, 5810, 5815, 
+    5820, 5825, 5830, 5835, 5840, 5845, 5850, 5855, 5860, 5865, 
+    5870, 5875, 5880, 5885, 5890, 5895, 5900, 5905, 5910, 5915, 
+    5920, 5925, 5930, 5935, 5940, 5945, 5950, 5955, 5960, 5965, 
+    5970, 5975, 5980, 5985, 5990, 5995, 6000, 6005, 6010, 6015, 
+    6020, 6025, 6030, 6035, 6040, 6045, 6050, 6055, 6060, 6065, 
+    6070, 6075, 6080, 6085, 6090, 6095, 6100
+};
+#endif
 /*
  * get all the channels to scan .
  * can be called whenever the set of supported channels are changed.
@@ -1021,8 +1050,10 @@
     struct ol_ath_softc_net80211 *scn = OL_ATH_SOFTC_NET80211(ic);
     u_int16_t *scan_order = (u_int16_t *)default_scan_order;
     u_int32_t scan_order_size = IEEE80211_N(default_scan_order);
-    int i = 0;
+    int i = 0, j =0;
+    int fixed_chan;
     struct scan_chan_list_params *param;
+    struct ieee80211_acs *acs = ic->ic_acs;
 
     param = (struct scan_chan_list_params *)
         kmalloc((sizeof(struct scan_chan_list_params) +
@@ -1035,6 +1066,30 @@
 
     ss->ss_nallchans = 0;
     ss->ss_nchans = 0;
+    /* Fixed channel support in client mode */
+    if( ic->sta_freq > 0 ) {
+       scan_order_size = 1;
+       fixed_chan = ic->sta_freq;
+    }
+    else {
+        /* In case of ACS, Sending 40 channels for scanning to firmware in one iteration */
+        for( i=ic->kwn_curr_freq; i<=ic->kwn_end_freq; i+=5 ) {
+            if( j > 40 )
+                break;
+            scan_order[j] = i;
+            acs->acs_ieee_chan[j] = ieee80211_mhz2ieee(ic, i, 0);
+            j++;
+        }
+        acs->acs_nchans_scan = j;
+	    scan_order_size = j;
+            /* Moving current freq to next iteration first freq,
+	       if current freq > end freq, move current freq to start freq */
+	    ic->kwn_curr_freq = scan_order[j-1] + 5;
+	    if( ic->kwn_curr_freq > ic->kwn_end_freq )
+		ic->kwn_curr_freq = ic->kwn_start_freq;
+            /* If scan order size is 1, updating fixed channel as this parameter is used for scanning below */
+		fixed_chan = scan_order[0];
+    }
 
     if (ic->ic_custom_scan_order_size > 0) {
         QDF_PRINT_INFO(QDF_PRINT_IDX_SHARED, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Using custom scan order\n"),
@@ -1045,7 +1100,12 @@
     spin_lock(&ss->ss_lock);
 
     for (i = 0; i < scan_order_size; ++i) {
-        c = ol_ath_find_full_channel(ic,scan_order[i]);
+        if( scan_order_size == 1 ) {
+            c = ol_ath_find_full_channel(ic,fixed_chan);
+        }
+        else {
+            c = ol_ath_find_full_channel(ic,scan_order[i]);
+        }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1060,12 +1120,18 @@
     /* Iterate again adding half-rate and quarter-rate channels */
     for (i = 0; i < scan_order_size; ++i) {
 
-        if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD)
+        if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD && scan_order_size != 1)
             continue;
 
         c = NULL;
-        c = ieee80211_find_channel(ic, scan_order[i], 0,
-                                   (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        if( scan_order_size == 1 ) {
+            c = ieee80211_find_channel(ic, fixed_chan, 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        }
+        else {
+            c = ieee80211_find_channel(ic, scan_order[i], 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        }
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
 #else
@@ -1075,8 +1141,14 @@
         }
 
         c = NULL;
-        c = ieee80211_find_channel(ic, scan_order[i], 0,
-                                   (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        if( scan_order_size == 1 ) {
+            c = ieee80211_find_channel(ic, fixed_chan, 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        }
+        else {
+            c = ieee80211_find_channel(ic, scan_order[i], 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1087,16 +1159,21 @@
         }
     }
 
-    if (ss->ss_flags & IEEE80211_SCAN_80MHZ) {
+    if (ss->ss_flags & IEEE80211_SCAN_80MHZ) 
+    {
         /* Iterate again adding VHT40 & VHT80 channels */
         for (i = 0,c = NULL; i < scan_order_size; ++i) {
-
-            if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD)
+            if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD && scan_order_size != 1)
                 continue;
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT40PLUS)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                }
             }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
@@ -1109,7 +1186,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT80)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT80);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80);
+                }
             }
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
             if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1121,7 +1203,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT160)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT160);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT160);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT160);
+                }
             }
             if (c != NULL) {
                 ss->ss_all_chans[ss->ss_nallchans++] = c;
@@ -1129,7 +1216,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT80_80)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80_80);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT80_80);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80_80);
+                }
             }
             if (c != NULL) {
                 ss->ss_all_chans[ss->ss_nallchans++] = c;
diff -urN qca-wifi-org/os/linux/include/ieee80211_ioctl.h qca-wifi-mod/os/linux/include/ieee80211_ioctl.h
--- qca-wifi-org/os/linux/include/ieee80211_ioctl.h	2018-06-08 11:00:42.000000000 +0530
+++ qca-wifi-mod/os/linux/include/ieee80211_ioctl.h	2018-11-15 11:20:24.582323528 +0530
@@ -1530,6 +1530,54 @@
     IEEE80211_PARAM_TIMEOUTIE                  = 550,   /* set/get assoc comeback timeout value */
     IEEE80211_PARAM_PMF_ASSOC                  = 551,   /* enable/disable pmf support */
     IEEE80211_PARAM_DFS_INFO_NOTIFY_APP        = 552,   /* Enable the feature to notify dfs info to app */
+    IEEE80211_PARAM_UPLINK_LIMIT               = 553,   /* Uplink Limit */
+    IEEE80211_PARAM_DOWNLINK_LIMIT             = 554,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST              = 555,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_DUR          = 556,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS   = 557,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE     = 558,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_DIR          = 559,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_VLAN_MODE              = 560,   /* Vlan Mode */
+    IEEE80211_PARAM_KWN_VID_ADD                = 561,   /* Vlan Add */
+    IEEE80211_PARAM_KWN_VID_DEL                = 562,   /* Vlan Del */
+    IEEE80211_PARAM_KWN_ALLOW_UNTAGGED         = 563,   /* Allow UnTagged */
+    IEEE80211_PARAM_KWN_SET_ACCESS_VLANID      = 564,   /* Access VlanID */
+    IEEE80211_PARAM_KWN_SET_NATIVE_VLANID      = 565,   /* Native VlanID */
+    IEEE80211_PARAM_KWN_SET_MGMT_VLANID        = 566,   /* Mgmt VlanID */
+    IEEE80211_PARAM_KWN_ETH_TX_PKTS            = 567,   /* Eth Tx Pkts */
+    IEEE80211_PARAM_KWN_ETH_TX_BYTES           = 568,   /* Eth Tx Bytes */
+    IEEE80211_PARAM_KWN_ETH_TX_ERRORS          = 569,   /* Eth Tx Errors */
+    IEEE80211_PARAM_KWN_ETH_RX_PKTS            = 570,   /* Eth Rx Pkts */
+    IEEE80211_PARAM_KWN_ETH_RX_BYTES           = 571,   /* Eth Rx Bytes */
+    IEEE80211_PARAM_KWN_ETH_RX_ERRORS          = 572,   /* Eth Rx Errors */
+    IEEE80211_PARAM_KWN_SET_SVLAN_ID           = 573,   /* SVLAN ID */
+    IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE    = 574,   /* SVLAN EtherType */
+    IEEE80211_PARAM_KWN_SET_PBB_B_VLANID       = 575,   /* PBB B-VLANID */
+    IEEE80211_PARAM_KWN_SET_PBB_B_ISID 	       = 576,	/* PBB B-ISID */
+    IEEE80211_PARAM_KWN_SET_FLAG               = 577,	/* PBB B-MAC Flag */
+    IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET     = 578,	/* Noise Floor Offset */
+    IEEE80211_PARAM_KWN_TX_RATE                = 579,	/* KWN TxRate */
+    IEEE80211_PARAM_KWN_TX_PWR                 = 580,	/* KWN TxPwr */
+    IEEE80211_PARAM_KWN_RX_RATE                = 581,	/* KWN RxRate */
+    IEEE80211_PARAM_KWN_RX_PWR                 = 582,	/* KWN RxPwr */
+    IEEE80211_PARAM_KWN_SPATIAL_STREAM         = 583,	/* KWN Spatial Stream */
+    IEEE80211_PARAM_KWN_DDRS_MIN_RATE          = 584,	/* KWN Min Rate */
+    IEEE80211_PARAM_KWN_DDRS_MAX_RATE          = 585,	/* KWN Max Rate */
+    IEEE80211_PARAM_KWN_DDRS_INCR_TIMER        = 586,	/* KWN Incr Timer */
+    IEEE80211_PARAM_KWN_DDRS_DECR_TIMER        = 587,	/* KWN Decr Timer */
+    IEEE80211_PARAM_KWN_ATPC_STATUS            = 588,	/* KWN ATPC */
+    IEEE80211_PARAM_KWN_ATPC_POWER             = 589,	/* KWN ATPC Power */
+    IEEE80211_PARAM_KWN_ANTENNA_GAIN           = 590,	/* KWN Antenna gain */
+    IEEE80211_PARAM_KWN_START_SCAN             = 591,	/* KWN Start Scan */
+    IEEE80211_PARAM_KWN_START_FREQ             = 592,	/* KWN Start freq */
+    IEEE80211_PARAM_KWN_END_FREQ               = 593,	/* KWN End freq */
+    IEEE80211_PARAM_KWN_SA_SCAN_TIME           = 594,	/* KWN Scan Time */
+    IEEE80211_PARAM_KWN_ACS_SCAN_TIME          = 595,	/* KWN Scan Time */
+    IEEE80211_PARAM_KWN_UTIL_TIME              = 596,	/* KWN Util Time */
+    IEEE80211_PARAM_KWN_ALLOW_TAG_MGMT         = 597,   /* Allow Tag Mgmt */
+    IEEE80211_PARAM_KWN_ASSEM_FRAG             = 598,   /* Assemble Fragment */
+    IEEE80211_PARAM_KWN_MAX_PKT_SIZE           = 599,   /* Max Pkt size */
+    IEEE80211_PARAM_KWN_FRAG_PKT_SIZE          = 600    /* Frag Pkt size */
 };
 #define WOW_CUSTOM_PKT_LEN 102
 #define WOW_SYNC_PATTERN 0xFF
@@ -2328,4 +2376,22 @@
 };
 #endif
 
+struct kwn_link_txparam {
+    u_int8_t  spatial_stream;
+    u_int8_t  min_rate;
+    u_int8_t  max_rate;
+    u_int8_t  inc_timer;
+    u_int8_t  dec_timer;
+    u_int8_t  atpc_status;
+    u_int8_t  power;
+};
+
+typedef struct kwn_link_profile {
+    struct kwn_link_txparam txparam;
+    int8_t    curr_rate;
+    u_int64_t ddrs_last_jiffies;
+    u_int8_t  ddrs_last_action;
+    int8_t    atpc_power;
+}kwn_link_profile_t;
+
 #endif /* _NET80211_IEEE80211_IOCTL_H_ */
diff -urN qca-wifi-org/os/linux/src/ieee80211_wireless.c qca-wifi-mod/os/linux/src/ieee80211_wireless.c
--- qca-wifi-org/os/linux/src/ieee80211_wireless.c	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/src/ieee80211_wireless.c	2018-11-15 12:19:50.246469836 +0530
@@ -106,6 +106,10 @@
 int ieee80211_authorise_local_peer(wlan_if_t vap, char *params);
 #endif
 
+/* KWN: PBB: B_DA_MAC & B_SA_MAC */
+extern int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac );
+extern int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac );
+
 #if 0
 /*
  * Common folder is coming from qca_main and
@@ -524,7 +528,9 @@
 {
     osif_dev *osnetdev = ath_netdev_priv(dev);
     wlan_if_t vap = osnetdev->os_if;
+    struct ieee80211com *ic = vap->iv_ic;
     int i;
+    u_int16_t start_freq = 0, end_freq = 0;
 
     debug_print_ioctl(dev->name, SIOCSIWFREQ, "siwfreq") ;
     QDF_PRINT_INFO(vap->iv_ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "siwfreq\n");
@@ -534,6 +540,43 @@
     /*
     * Necessary to cast, to properly interpret negative channel numbers
     */
+    /* To enable fixed channel on Client mode, writing -1 to station freq in case of acs enabled */
+    ic->sta_freq = 0;
+    if( freq->m == 0 )
+      ic->sta_freq = -1;
+
+    if( ic->ic_is_mode_offload(ic) && vap->iv_opmode == IEEE80211_M_HOSTAP && freq->m == 0 )
+    {
+        for (i = 0; i < ic->ic_nchans; i++) {
+            const struct ieee80211_channel *c = &ic->ic_channels[i];
+            if( start_freq == 0 )
+                start_freq = c->ic_freq;
+            else
+                end_freq = c->ic_freq;
+        }
+        printk(": ACS: start freq %d end freq %d \n",start_freq,end_freq);
+        if( start_freq > 4000 ) {
+            if( ic->enable_sa_scan == 1 ) {
+               printk(": ACS: SA Scan is in progress\n");
+               return 0;
+            }
+            printk(": ACS: Scanning module enabled \n");
+            memset( &ic->kwn_scan.sa_result, 0, sizeof( struct kwn_sa_scan_result ) );
+            ic->kwn_scan.scan_vap = vap;
+            ic->kwn_scan.start_freq = start_freq;
+            ic->kwn_scan.end_freq = end_freq;
+            ic->kwn_scan.curr_freq = 0;
+            ic->kwn_scan.next_chan = 0;
+            ic->kwn_scan.scan_time = ic->kwn_scan.acs_scan_time;
+            ic->kwn_scan.util_time = 400;
+            ic->kwn_scan.start_scan = 1;
+            ic->enable_acs = 1;
+            OS_SET_TIMER(&ic->kwn_scan.scan_timer, 10000);
+            i = (u_int8_t)wlan_mhz2ieee(osnetdev->os_devhandle, start_freq, 0);
+            freq->m = i;
+        }
+    }
+
     if (freq->e == 1)
         i = (u_int8_t)wlan_mhz2ieee(osnetdev->os_devhandle, freq->m / 100000, 0);
     else
@@ -600,6 +643,40 @@
 }
 
 static int
+ieee80211_ioctl_siwnickname(struct net_device *dev,
+    struct iw_request_info *info,
+    struct iw_point *data, char *ssid)
+{
+#define CUSTOMER_NAME 1
+#define LONGITUDE     2
+#define LATITUDE      3
+    osif_dev *osifp = ath_netdev_priv(dev);
+    wlan_if_t vap = osifp->os_if; 
+
+    if (data->length > IEEE80211_NWID_LEN)
+	    data->length = IEEE80211_NWID_LEN;
+    if ( vap->iv_ic->ic_str_type == CUSTOMER_NAME ) {
+	    OS_MEMZERO(vap->iv_ic->ic_customer_name, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_customer_name, ssid, data->length);
+	    printk("Cusname: %s \n",vap->iv_ic->ic_customer_name);
+    }
+    else if ( vap->iv_ic->ic_str_type == LONGITUDE ) {
+	    OS_MEMZERO(vap->iv_ic->ic_longitude, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_longitude, ssid, data->length);
+	    printk("langitude: %s \n",vap->iv_ic->ic_longitude);
+	    vap->appie_buf_updated = 1;
+    }
+    else if ( vap->iv_ic->ic_str_type == LATITUDE ) {
+	    OS_MEMZERO(vap->iv_ic->ic_latitude, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_latitude, ssid, data->length);
+	    printk("latitude: %s \n",vap->iv_ic->ic_latitude);
+	    vap->appie_buf_updated = 1;
+    }
+    vap->iv_ic->ic_str_type = 0;
+    return 0;
+}
+
+static int
 ieee80211_ioctl_giwessid(struct net_device *dev,
     struct iw_request_info *info,
     struct iw_point *data, char *essid)
@@ -1148,6 +1225,9 @@
     wlan_if_t vap;
     struct sockaddr addr[IW_MAX_AP];
     struct iw_quality qual[IW_MAX_AP];
+    struct iw_ssid ssid[IW_MAX_AP];
+    uint8_t chan[IW_MAX_AP];
+    uint16_t freq[IW_MAX_AP];
     int i;
 };
 
@@ -1161,6 +1241,9 @@
     u_int8_t *se_macaddr = wlan_scan_entry_macaddr(se);
     u_int8_t *se_bssid = wlan_scan_entry_bssid(se);
     u_int8_t se_rssi = wlan_scan_entry_rssi(se);
+    u_int8_t se_ssid_len;
+    u_int8_t *se_ssid = wlan_scan_entry_ssid(se, &se_ssid_len);
+    wlan_chan_t se_chan = wlan_scan_entry_channel(se);
 
     if (i >= IW_MAX_AP)
         return 0;
@@ -1171,6 +1254,9 @@
         IEEE80211_ADDR_COPY(req->addr[i].sa_data, se_bssid);
 
     set_quality(&req->qual[i], se_rssi);
+    memcpy( req->ssid[i].essid, se_ssid, se_ssid_len);
+    req->chan[i] = se_chan->ic_ieee;
+    req->freq[i] = se_chan->ic_freq;
 
     req->i = i+1;
 
@@ -1199,12 +1285,39 @@
     data->flags = 1;        /* signal quality present (sort of) */
     OS_MEMCPY(extra + req->i*sizeof(req->addr[0]), &req->qual,
         req->i*sizeof(req->qual[0]));
+    OS_MEMCPY(extra + (req->i*sizeof(req->addr[0] )) + ( req->i * sizeof(req->qual[0] ) ), &req->ssid,
+        req->i*sizeof(req->ssid[0]));
     OS_FREE(req);
 
     return 0;
 
 }
 
+int
+ieee80211_get_scanentries( struct net_device *dev, struct ieee80211_action_vht_scan_entries *entries )
+{
+    osif_dev *osifp = ath_netdev_priv(dev);
+    wlan_if_t vap = osifp->os_if;
+    struct waplistreq *req;
+    int i;
+
+    req = (struct waplistreq *)OS_MALLOC(osifp->os_handle, sizeof(*req), GFP_KERNEL);
+    if (req == NULL)
+        return -ENOMEM;
+    req->vap = vap;
+    req->i = 0;
+    wlan_scan_table_iterate(vap, waplist_cb, req);
+    entries->at_scan_entry.count = req->i;
+    for( i=0; i<req->i; i++ ) {
+        entries->at_scan_entry.entry[i].channel = req->chan[i];
+        entries->at_scan_entry.entry[i].frequency = req->freq[i];
+        entries->at_scan_entry.entry[i].rssi = req->qual[i].level - req->qual[i].noise;
+    }
+    OS_FREE(req);
+
+    return 0;
+}
+
 #ifdef SIOCGIWSCAN
 static int
 ieee80211_ioctl_siwscan(struct net_device *dev,
@@ -10106,7 +10219,7 @@
  */
 static int
 ieee80211_ioctl_addmac(struct net_device *dev, struct iw_request_info *info,
-    void *w, char *extra)
+        void *w, char *extra)
 {
     osif_dev *osifp = ath_netdev_priv(dev);
     wlan_if_t vap = osifp->os_if;
@@ -10115,8 +10228,38 @@
 
     debug_print_ioctl(dev->name, IEEE80211_IOCTL_ADDMAC, "addmac") ;
 
-    rc = wlan_set_acl_add(vap, sa->sa_data, IEEE80211_ACL_FLAG_ACL_LIST_1);
-    return rc;
+    switch( vap->kwn_flag ) {
+        case TPUT_TEST_MAC:
+            IEEE80211_ADDR_COPY(vap->kwn_tput_test_mac, sa->sa_data);
+            break;
+        case PBB_DA_MAC:
+            {
+                struct net_device *eth_dev;
+                eth_dev = dev_get_by_name(&init_net, "eth0");
+                if ( eth_dev ) {
+                    edma_set_pbb_da_mac( eth_dev, sa->sa_data );
+                    dev_put(eth_dev);
+                }
+            }
+            break;
+        case PBB_SA_MAC:
+            {
+                struct net_device *eth_dev;
+                eth_dev = dev_get_by_name(&init_net, "eth0");
+                if ( eth_dev ) {
+                    edma_set_pbb_sa_mac( eth_dev, sa->sa_data );
+                    dev_put(eth_dev);
+                }
+            }
+            break;
+        case RATE_NODE_MAC:
+            IEEE80211_ADDR_COPY(vap->kwn_rate_node_mac, sa->sa_data);
+            break;
+        default:
+            rc = wlan_set_acl_add(vap, sa->sa_data, IEEE80211_ACL_FLAG_ACL_LIST_1);
+            return rc;
+    }
+    return 0;
 }
 
 /**
@@ -11208,6 +11351,29 @@
 
     debug_print_ioctl(dev->name, 0xffff, "getscanresults");
 
+    if( vap->kwn_flag == SA_RESULTS )
+    {
+        uint32_t data_length = 0;
+        int status;
+
+        data_length = iwr->u.data.length;
+        data_length = sizeof( struct kwn_sa_scan_result );
+        if (data_length == 0)
+            return -EINVAL;
+
+        if ((data_length > iwr->u.data.length) && (iwr->u.data.flags == 0)) {
+            return -EINVAL;
+        }
+
+        if (data_length > 0) {
+            iwr->u.data.length = data_length;
+            error = _copy_to_user(iwr->u.data.pointer, &ic->kwn_scan.sa_result, data_length);
+            status = error ? -EFAULT : 0;
+        } else {
+            iwr->u.data.length = 0;
+        }
+        return 0;
+    }
     if (!(dev->flags & IFF_UP)) {
         return -EINVAL;
     }
@@ -14947,6 +15113,161 @@
     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dfs_notify" },
     { IEEE80211_PARAM_DFS_INFO_NOTIFY_APP,
     0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_dfs_notify" },
+    { IEEE80211_PARAM_UPLINK_LIMIT,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "ul_limit" },
+    { IEEE80211_PARAM_UPLINK_LIMIT,
+    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_ul_limit" },
+    { IEEE80211_PARAM_DOWNLINK_LIMIT,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dl_limit" },
+    { IEEE80211_PARAM_DOWNLINK_LIMIT,
+    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_dl_limit" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_test" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_test" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DUR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_dur" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DUR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_dur" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_cnt" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_cnt" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_size" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_size" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DIR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_dir" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DIR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_dir" },
+    { IEEE80211_PARAM_KWN_VLAN_MODE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vlan_mode" },
+    { IEEE80211_PARAM_KWN_VID_ADD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vid_add" },
+    { IEEE80211_PARAM_KWN_VID_DEL,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vid_del" },
+    { IEEE80211_PARAM_KWN_ALLOW_UNTAGGED,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_allowuntag" },
+    { IEEE80211_PARAM_KWN_SET_ACCESS_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_acc_vid" },
+    { IEEE80211_PARAM_KWN_SET_NATIVE_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_nat_vid" },
+    { IEEE80211_PARAM_KWN_SET_MGMT_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_mgmt_vid" },
+    { IEEE80211_PARAM_KWN_SET_SVLAN_ID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_svlan_id" },
+    { IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_setherType" },
+    { IEEE80211_PARAM_KWN_ETH_TX_PKTS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxpkt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_BYTES,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxbyt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_ERRORS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxerr" },
+    { IEEE80211_PARAM_KWN_ETH_RX_PKTS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxpkt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_BYTES,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxbyt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_ERRORS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxerr" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_bvid" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_ISID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_bisid" },
+    { IEEE80211_PARAM_KWN_SET_FLAG,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_flag" },
+    { IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnnoiseoff" },
+    { IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnnoiseoff" },
+    { IEEE80211_PARAM_KWN_TX_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwntxrate" },
+    { IEEE80211_PARAM_KWN_TX_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwntxrate" },
+    { IEEE80211_PARAM_KWN_TX_PWR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwntxpwr" },
+    { IEEE80211_PARAM_KWN_TX_PWR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwntxpwr" },
+    { IEEE80211_PARAM_KWN_RX_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnrxrate" },
+    { IEEE80211_PARAM_KWN_RX_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrxrate" },
+    { IEEE80211_PARAM_KWN_RX_PWR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnrxpwr" },
+    { IEEE80211_PARAM_KWN_RX_PWR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrxpwr" },
+    { IEEE80211_PARAM_KWN_SPATIAL_STREAM,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnstream" },
+    { IEEE80211_PARAM_KWN_SPATIAL_STREAM,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnstream" },
+    { IEEE80211_PARAM_KWN_DDRS_MIN_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsmin" },
+    { IEEE80211_PARAM_KWN_DDRS_MIN_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsmin" },
+    { IEEE80211_PARAM_KWN_DDRS_MAX_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsmax" },
+    { IEEE80211_PARAM_KWN_DDRS_MAX_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsmax" },
+    { IEEE80211_PARAM_KWN_DDRS_INCR_TIMER,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsinc" },
+    { IEEE80211_PARAM_KWN_DDRS_INCR_TIMER,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsinc" },
+    { IEEE80211_PARAM_KWN_DDRS_DECR_TIMER,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsdec" },
+    { IEEE80211_PARAM_KWN_DDRS_DECR_TIMER,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsdec" },
+    { IEEE80211_PARAM_KWN_ATPC_STATUS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnatpc" },
+    { IEEE80211_PARAM_KWN_ATPC_STATUS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnatpc" },
+    { IEEE80211_PARAM_KWN_ATPC_POWER,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnatpcpow" },
+    { IEEE80211_PARAM_KWN_ATPC_POWER,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnatpcpow" },
+    { IEEE80211_PARAM_KWN_ANTENNA_GAIN,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnantgain" },
+    { IEEE80211_PARAM_KWN_ANTENNA_GAIN,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnantgain" },
+    { IEEE80211_PARAM_KWN_START_SCAN,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnstartscan" },
+    { IEEE80211_PARAM_KWN_START_SCAN,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnstartscan" },
+    { IEEE80211_PARAM_KWN_START_FREQ,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnstartfreq" },
+    { IEEE80211_PARAM_KWN_START_FREQ,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnstartfreq" },
+    { IEEE80211_PARAM_KWN_END_FREQ,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnendfreq" },
+    { IEEE80211_PARAM_KWN_END_FREQ,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnendfreq" },
+    { IEEE80211_PARAM_KWN_SA_SCAN_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnsatime" },
+    { IEEE80211_PARAM_KWN_SA_SCAN_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnsatime" },
+    { IEEE80211_PARAM_KWN_ACS_SCAN_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnacstime" },
+    { IEEE80211_PARAM_KWN_ACS_SCAN_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnacstime" },
+    { IEEE80211_PARAM_KWN_UTIL_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnutiltime" },
+    { IEEE80211_PARAM_KWN_UTIL_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnutiltime" },
+    { IEEE80211_PARAM_KWN_ALLOW_TAG_MGMT,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tagmgmt" },
+    { IEEE80211_PARAM_KWN_ASSEM_FRAG,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnassemfrag" },
+    { IEEE80211_PARAM_KWN_ASSEM_FRAG,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnassemfrag" },
+    { IEEE80211_PARAM_KWN_MAX_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnpktsize" },
+    { IEEE80211_PARAM_KWN_MAX_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnpktsize" },
+    { IEEE80211_PARAM_KWN_FRAG_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnfragsize" },
+    { IEEE80211_PARAM_KWN_FRAG_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnfragsize" }
+
 };
 
 static const iw_handler ieee80211_handlers[] = {
@@ -14992,7 +15313,7 @@
 #endif /* SIOCGIWSCAN */
     (iw_handler) ieee80211_ioctl_siwessid,      /* SIOCSIWESSID */
     (iw_handler) ieee80211_ioctl_giwessid,      /* SIOCGIWESSID */
-    (iw_handler) NULL,      /* SIOCSIWNICKN */
+    (iw_handler) ieee80211_ioctl_siwnickname,      /* SIOCSIWNICKN */
     (iw_handler) NULL,      /* SIOCGIWNICKN */
     (iw_handler) NULL,              /* -- hole -- */
     (iw_handler) NULL,              /* -- hole -- */
@@ -15309,11 +15630,26 @@
     {
 
     case SIOCG80211STATS:
-        return _copy_to_user(ifr->ifr_data, &vap->iv_stats,
-            sizeof (vap->iv_stats) +
-            sizeof(vap->iv_unicast_stats) +
-            sizeof(vap->iv_multicast_stats)) ? -EFAULT : 0;
-
+        if (*((char*)ifr->ifr_data))
+        {
+            memset (&(vap->iv_stats), 0x00, sizeof(struct ieee80211_stats));
+            memset (&(vap->iv_unicast_stats), 0x00, sizeof(struct ieee80211_mac_stats));
+            memset (&(vap->iv_multicast_stats), 0x00, sizeof(struct ieee80211_mac_stats));
+            memset (&(vap->iv_mgmt_stats), 0x00, sizeof(struct ieee80211_mgmt_stats));
+            return 0;
+        }
+        else
+        {
+            vap->iv_mgmt_stats.iv_opmode = vap->iv_opmode;
+            return _copy_to_user(ifr->ifr_data, &vap->iv_stats,
+                    sizeof (vap->iv_stats) +
+                    sizeof(vap->iv_unicast_stats) +
+                    sizeof(vap->iv_multicast_stats)
+#ifdef SIFY_MGMT_STATS                               
+                    + sizeof (vap->iv_mgmt_stats)
+#endif
+                    ) ? -EFAULT : 0;
+        }
     case SIOC80211IFDESTROY:
         if (!capable(CAP_NET_ADMIN))
             return -EPERM;
diff -urN qca-wifi-org/os/linux/src/osif_umac.c qca-wifi-mod/os/linux/src/osif_umac.c
--- qca-wifi-org/os/linux/src/osif_umac.c	2018-06-08 11:00:41.000000000 +0530
+++ qca-wifi-mod/os/linux/src/osif_umac.c	2018-08-14 17:29:25.045491751 +0530
@@ -2425,7 +2425,7 @@
     struct ev_msg msg;
 
     if (osifp->os_opmode != IEEE80211_M_P2P_GO) {
-        if (!wlan_get_param(vap, IEEE80211_TRIGGER_MLME_RESP))
+        //if (!wlan_get_param(vap, IEEE80211_TRIGGER_MLME_RESP))
         {
         	OS_MEMSET(&wreq, 0, sizeof(wreq));
 	        IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
@@ -2508,6 +2508,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DEAUTH_IND_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
     ald_assoc_notify(((osif_dev *)osif)->os_if, macaddr, ALD_ACTION_DISASSOC);
 #if ATH_SUPPORT_WAPI
@@ -2641,6 +2642,7 @@
     memset(&wrqu, 0, sizeof(wrqu));
     IEEE80211_ADDR_COPY(wrqu.addr.sa_data, macaddr);
     wrqu.addr.sa_family = ARPHRD_ETHER;
+    wrqu.addr.sa_data[6] = IEEE80211_EV_DEAUTH_COMPLETE_STA;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wrqu, NULL);
 
 #if UMAC_SUPPORT_ACFG
@@ -3089,6 +3091,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DISASSOC_IND_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
     ald_assoc_notify(((osif_dev *)osif)->os_if, macaddr, ALD_ACTION_DISASSOC);
 #if ATH_SUPPORT_WAPI
@@ -3160,6 +3163,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DISASSOC_COMPLETE_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
 
     IEEE80211_ADDR_COPY(msg.addr, macaddr);
diff -urN qca-wifi-org/os/linux/src/umac_exports.c qca-wifi-mod/os/linux/src/umac_exports.c
--- qca-wifi-org/os/linux/src/umac_exports.c	2018-06-08 11:00:41.000000000 +0530
+++ qca-wifi-mod/os/linux/src/umac_exports.c	2018-11-14 14:17:26.058491172 +0530
@@ -77,6 +77,7 @@
 EXPORT_SYMBOL(ieee80211_chan2mode);
 EXPORT_SYMBOL(ieee80211_ieee2mhz);
 EXPORT_SYMBOL(ieee80211_find_channel);
+EXPORT_SYMBOL(kwn_find_channel);
 EXPORT_SYMBOL(ieee80211_doth_findchan);
 EXPORT_SYMBOL(ieee80211_find_dot11_channel);
 EXPORT_SYMBOL(wlan_get_desired_phymode);
@@ -203,6 +204,8 @@
 #endif
 
 EXPORT_SYMBOL(ieee80211_send_rcsa);
+EXPORT_SYMBOL(ieee80211_send_dying_gasp);
+EXPORT_SYMBOL(kwn_sa_set_channel);
 EXPORT_SYMBOL(ieee80211_dfs_cac_cancel);
 EXPORT_SYMBOL(ieee80211_update_dfs_next_channel);
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
@@ -560,3 +563,4 @@
 EXPORT_SYMBOL(osif_set_primary_radio_event);
 #endif
 EXPORT_SYMBOL(wlan_get_stats);
+EXPORT_SYMBOL(kwn_beacon_chanutil_update);
diff -urN qca-wifi-org/os/linux/tools/80211stats.c qca-wifi-mod/os/linux/tools/80211stats.c
--- qca-wifi-org/os/linux/tools/80211stats.c	2018-06-08 11:00:39.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/80211stats.c	2018-08-22 16:30:44.607885776 +0530
@@ -68,6 +68,70 @@
 #ifndef SIOCG80211STATS
 #define	SIOCG80211STATS	(SIOCDEVPRIVATE+2)
 #endif
+typedef struct 
+{
+	int code;
+	char *str;
+}ieee80211_reason_t;
+ieee80211_reason_t ieee80211_reason[] =
+{
+	{1,"unspecified"},
+	{2,"auth expire"},
+	{3,"auth leave"},
+	{4,"assoc expire"},
+	{5,"assoc toomany"},
+	{6,"not authed"},
+	{7,"not assoced"},
+	{8,"assoc leave"},
+	{9,"assoc not authed"},
+	{11,"rsn required"},
+	{12,"rsn inconsistent"},
+	{13,"ie invalid"},
+	{14,"mic failure"},
+	{32,"qos"},
+	{33,"qos bandwitdh"},
+	{34,"qos ch conditions"},
+	{35,"qos txop"},
+	{36,"qos leave"},
+	{37,"qos declined"},
+	{38,"qos setup required"},
+	{39,"qos timeout"},
+	{45,"qos cipher"},
+	{0,"success"},
+	{1,"unspecified"},
+	{10,"capinfo"},
+	{11,"not assoced"},
+	{12,"other"},
+	{13,"alg"},
+	{14,"sequence"},
+	{15,"challenge"},
+	{16,"timeout"},
+	{17,"toomany"},
+	{18,"basic rate"},
+	{19,"sp required"},
+	{20,"pbcc required"},
+	{21,"ca required"},
+	{22,"too many stations"},
+	{23,"rates"},
+	{25,"shortslot required"},
+	{26,"dsssofdm required"},
+	{27,"no ht"},
+	{37,"refused"},
+	{38,"invalid param"}
+};
+
+static char *ieee80211_reason_get (int code)
+{
+	int  i = 0;
+	for (i = 0; i< sizeof(ieee80211_reason);i++)
+	{
+		if (ieee80211_reason[i].code == code)
+		{
+			return ieee80211_reason[i].str;
+		}
+	}
+	return "none";
+}
 
 static void
 printstats(FILE *fd, const struct ieee80211_stats *stats)
@@ -295,15 +359,159 @@
 int
 main(int argc, char *argv[])
 {
-	int c, len;
+    const char *ifname = "ath0";
+	int c = 0 , len, index;
 	struct ieee80211req_sta_info *si;
 	u_int8_t buf[24*1024], *cp;
 	struct iwreq iwr;
-	int allnodes = 0;
+	int allnodes = 0,mgmtstats = 0;
+    int clear = 0;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 	if (s < 0)
 		err(1, "socket");
+#if 1
+    while ((c = getopt(argc, argv, "e:i:")) != -1)
+        switch (c)
+        { 
+            case 'i':
+                ifname = optarg; 
+                break; 
+            case 'e':
+                clear = atoi(optarg);
+                break;
+            case '?':
+                if (optopt == 'i')
+                    fprintf(stderr, "Option -%c requires an argument.\n", optopt);
+                close(s);
+                return -1;
+            default:
+                abort();
+        }
+	strlcpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
+	if (clear == 1)
+	{
+		char data[2] = {1};
+		ifr.ifr_data = data;
+
+		if (ioctl(s, SIOCG80211STATS, &ifr) < 0)
+		{
+			printf("error opening socket");
+			err(1, ifr.ifr_name);
+		}
+		return 0;
+	}
+	{
+		struct ieee80211_stats      *stats = NULL;
+		struct ieee80211_mac_stats  *unicast_stats = NULL;
+		struct ieee80211_mac_stats  *multicast_stats = NULL;
+		struct ieee80211_mgmt_stats *mgmt_stats = NULL;
+
+		/* no args, just show global stats */
+        /* fetch both ieee80211_stats, and mac_stats, including multicast and unicast stats */
+        stats = malloc(sizeof(struct ieee80211_stats)+ 2* sizeof(struct ieee80211_mac_stats) + sizeof (struct ieee80211_mgmt_stats));
+        if (!stats) {
+            fprintf (stderr, "Unable to allocate memory for stats\n");
+            return -1;
+        }
+		ifr.ifr_data = (caddr_t) stats;
+		if (ioctl(s, SIOCG80211STATS, &ifr) < 0)
+			err(1, ifr.ifr_name);
+		unicast_stats = (struct ieee80211_mac_stats*)(((unsigned char*)stats)+sizeof(struct ieee80211_stats));
+		multicast_stats = (struct ieee80211_mac_stats *)(((unsigned char*)stats)+sizeof(struct ieee80211_stats)+ sizeof(struct ieee80211_mac_stats));
+		mgmt_stats = (struct ieee80211_mgmt_stats*)(((unsigned char*)stats)+sizeof(struct ieee80211_stats)+2*sizeof(struct ieee80211_mac_stats));
+		
+		/* AP */
+		if (mgmt_stats->iv_opmode != 1)
+		{
+			printf(" Authentication requests received:   %llu\n",mgmt_stats->aut_recv);
+			printf(" Authentication confirms:            %llu\n",mgmt_stats->aut_confirm_xmit);
+			printf(" Authentication rejects:             %llu\n",mgmt_stats->aut_reject_xmit);
+			printf(" Deauthentication requests sent:     %llu\n",mgmt_stats->deaut_xmit);
+#if 0			
+			printf(" Deauthentication requests received: %llu\n",mgmt_stats->deaut_recv);
+#endif			
+			if (mgmt_stats->aut_recv > 0)
+			{
+				printf(" Authentication result last:         %s\n",ieee80211_reason_get(mgmt_stats->auth_reason));
+			}
+			else
+			{
+				printf(" Authentication result last:         %s\n","not available");
+			}
+#if 1	
+			printf(" Association requests received:      %llu\n",mgmt_stats->assoc_recv);
+			printf(" Association rejects:                %llu\n",mgmt_stats->assoc_reject_xmit);
+			printf(" Association confirms:               %llu\n",mgmt_stats->assoc_confirm_xmit);
+			printf(" Disassociation requests received:   %llu\n",mgmt_stats->disassoc_recv);
+			if (mgmt_stats->assoc_recv > 0)
+			{
+				printf(" Association result last:            %s\n",ieee80211_reason_get(mgmt_stats->assoc_reason));
+			}
+			else
+			{
+				printf(" Association result last:            %s\n","not available");
+			}
+#endif			
+
+		}
+		else
+		{
+
+			/* SU */
+			
+			printf(" Beacons received:                   %llu\n",mgmt_stats->bcn_recv);
+			printf(" Authentication requests sent:       %llu\n",mgmt_stats->aut_xmit);
+			printf(" Authentication confirms:            %llu\n",mgmt_stats->aut_confirm_recv);
+			printf(" Authentication rejects:             %llu\n",mgmt_stats->aut_reject_recv);
+			printf(" Deauthentication requests received: %llu\n",mgmt_stats->deaut_recv);
+			if (mgmt_stats->aut_confirm_recv || mgmt_stats->aut_reject_recv)
+			{
+				printf(" Authentication result last:         %s\n",ieee80211_reason_get(mgmt_stats->auth_reason));
+			}
+			else
+			{
+				printf(" Authentication result last:         %s\n","not available");
+			}
+#if 1
+			printf(" Association requests sent:          %llu\n",mgmt_stats->assoc_xmit);
+			printf(" Association rejects:                %llu\n",mgmt_stats->assoc_reject_recv);
+			printf(" Association confirms:               %llu\n",mgmt_stats->assoc_confirm_recv);
+			printf(" Disassociation requests sent:       %llu\n",mgmt_stats->disassoc_xmit);
+			if (mgmt_stats->assoc_reject_recv || mgmt_stats->assoc_confirm_recv)
+			{
+				printf(" Association result last:            %s\n",ieee80211_reason_get(mgmt_stats->assoc_reason));
+
+			}
+			else
+			{
+				printf(" Association result last:            %s\n","not available");
+			}
+#endif			
+
+		}
+		printf("----------------------------\r\n");
+		printf(" Multicast packets sent:             %llu\n",multicast_stats->ims_tx_packets);
+		printf(" Multicast packets received:         %llu\n",multicast_stats->ims_rx_packets);
+		printf(" Multicast data packets sent:        %llu\n",multicast_stats->ims_tx_data_packets);
+		printf(" Multicast data packets received:    %llu\n",multicast_stats->ims_rx_data_packets);
+		printf(" Multicast data bytes sent:          %llu\n",multicast_stats->ims_tx_data_bytes);
+		printf(" Multicast data bytes received:      %llu\n",multicast_stats->ims_rx_data_bytes);
+		printf(" Broadcast data packets sent:        %llu\n",multicast_stats->ims_tx_bcast_data_packets);
+		printf(" Broadcast data packets received:    %llu\n",multicast_stats->ims_rx_bcast_data_packets);
+		printf(" Unicast packets sent:               %llu\n",unicast_stats->ims_tx_packets);
+		printf(" Unicast packets received:           %llu\n",unicast_stats->ims_rx_packets);
+		printf(" Unicast data packets sent:          %llu\n",unicast_stats->ims_tx_data_packets);
+		printf(" Unicast data packets received:      %llu\n",unicast_stats->ims_rx_data_packets);
+		printf(" Unicast data bytes sent:            %llu\n",unicast_stats->ims_tx_data_bytes);
+		printf(" Unicast data bytes received:        %llu\n",unicast_stats->ims_rx_data_bytes);
+		printf(" Broadcast data packets sent:        %llu\n",unicast_stats->ims_tx_bcast_data_packets);
+		printf(" Broadcast data packets received:    %llu\n",unicast_stats->ims_rx_bcast_data_packets);
+
+		free(stats);
+		return 0;
+	}
+#else
 	strlcpy(ifr.ifr_name, "ath0", sizeof (ifr.ifr_name));
 	while ((c = getopt(argc, argv, "ai:")) != -1)
 		switch (c) {
@@ -376,4 +584,5 @@
 		}
 	}
         return 0;       	
+#endif
 }
diff -urN qca-wifi-org/os/linux/tools/apstats.c qca-wifi-mod/os/linux/tools/apstats.c
--- qca-wifi-org/os/linux/tools/apstats.c	2018-06-08 11:00:39.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/apstats.c	2018-11-14 14:17:47.222492319 +0530
@@ -95,7 +95,7 @@
 #endif
 
 /* Options processing */
-static const char *optString = "arvsi:m:RMh?";
+static const char *optString = "arvsci:m:RMh?";
 int display_mesh_stats = 0;
 
 static const struct option longOpts[] = {
@@ -103,6 +103,7 @@
     { "radiolevel", no_argument, NULL, 'r' },
     { "vaplevel", no_argument, NULL, 'v' },
     { "stalevel", no_argument, NULL, 's' },
+    { "scanresult", no_argument, NULL, 'c' },
     { "ifname", required_argument, NULL, 'i' },
     { "stamacaddr", required_argument, NULL, 'm' },
     { "recursive", no_argument, NULL, 'R' },            /* Default */
@@ -2246,6 +2247,40 @@
 
 }
 
+static int display_sa_scan()
+{
+    int ret = -1;
+    int sockfd;
+    struct iwreq iwr;
+    u_int8_t *buf;
+    int buflen = 0;
+    struct kwn_sa_scan_result sa_result;
+    int i;
+
+    buflen = sizeof( struct kwn_sa_scan_result );
+    buf = (u_int8_t*)malloc(buflen);
+    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+
+    if (sockfd < 0) {
+        perror("socket");
+        return -1;
+    }
+    memset(&iwr, 0, sizeof(iwr));
+    strlcpy(iwr.ifr_name, "ath1", IFNAMSIZ);
+    iwr.u.data.pointer = (void *)buf;
+    iwr.u.data.length = buflen;
+    if ((ret = ioctl(sockfd, IEEE80211_IOCTL_SCAN_RESULTS, &iwr)) < 0) {
+        printf(" Error : ret %d \n",ret);
+        free(buf);
+        return ret;
+    }
+    memcpy( &sa_result, ( struct kwn_sa_scan_result *)buf, sizeof( struct kwn_sa_scan_result ) );
+    for( i = 0; i< sa_result.cnt; i++ )
+    {
+        printf("%d=%d=%d,",sa_result.sa_entry[i].channel,sa_result.sa_entry[i].frequency,sa_result.sa_entry[i].utility);
+    }
+    return 0;
+}
 
 static int apstats_main(apstats_config_t *config)
 {
@@ -2567,6 +2602,9 @@
                 is_level_set  = 1;
                 is_option_selected = 1;
                 break;
+            case 'c':
+                display_sa_scan();
+                return 0;
 
             case 'i':
                 if (is_ifname_set) {
diff -urN qca-wifi-org/os/linux/tools/athstats.c qca-wifi-mod/os/linux/tools/athstats.c
--- qca-wifi-org/os/linux/tools/athstats.c	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/athstats.c	2018-08-22 16:30:50.671885994 +0530
@@ -633,9 +633,11 @@
 {
     fprintf(fd, "txrx stats:\n");
     if (stats_level == TXRX_STATS_LEVEL_BASIC) {
-        fprintf(fd,"  tx: %u msdus (%u B)\n",
+        fprintf(fd,"tx:%u\n",
+            stats->tx.delivered.pkts);
+        /* fprintf(fd,"  tx: %u msdus (%u B)\n",
             stats->tx.delivered.pkts,
-            stats->tx.delivered.bytes);
+            stats->tx.delivered.bytes); */
     } else { /* full */
         fprintf(fd,
             "  tx: sent %u msdus (%u B), "
@@ -661,10 +663,12 @@
             stats->tx.dropped.no_ack.pkts,
             stats->tx.dropped.no_ack.bytes);
     }
-    fprintf(fd,
+    fprintf(fd,"rx:%u\n",
+        stats->rx.delivered.pkts);
+    /*fprintf(fd,
         "  rx: %u msdus, %u bytes\n",
         stats->rx.delivered.pkts,
-        stats->rx.delivered.bytes);
+        stats->rx.delivered.bytes);*/
     if (stats_level == TXRX_STATS_LEVEL_FULL) {
         fprintf(fd,
             "    forwarded %u msdus, %u bytes\n",
@@ -727,11 +731,11 @@
     /* AMSDUs that have more MSDUs than the status ring size */
     fprintf(fd,"oversize_amsdu    :\t%d\n",rx->oversize_amsdu);
     /* Number of PHY errors */
-    fprintf(fd,"phy_errs          :\t%d\n",rx->phy_errs);
+    fprintf(fd,"phy_errors:%d\n",rx->phy_errs);
     /* Number of PHY errors dropped */
     fprintf(fd,"phy_errs dropped  :\t%d\n",rx->phy_err_drop);
     /* Number of mpdu errors - FCS, MIC, ENC etc. */
-    fprintf(fd,"mpdu_errs         :\t%d\n",rx->mpdu_errs);
+    fprintf(fd,"mpdu_errs:%d\n",rx->mpdu_errs);
 
 }
 
@@ -741,11 +745,11 @@
     const struct wlan_dbg_tx_stats *tx = &wlan_pdev_stats->tx;
     int   i;
 
-    fprintf(fd,"ast_be_xmit         :\t%llu\n",radio_stats->tx_beacon);
+    fprintf(fd,"ast_be_xmit:%llu\n",radio_stats->tx_beacon);
     fprintf(fd,"ast_be_nobuf        :\t%d\n",radio_stats->be_nobuf);
     fprintf(fd,"ast_tx_buf_count    :\t%u\n",radio_stats->tx_buf_count);
-    fprintf(fd,"ast_tx_packets      :\t%u\n",radio_stats->tx_mgmt + radio_stats->tx_num_data);
-    fprintf(fd,"ast_rx_packets      :\t%u\n",radio_stats->rx_packets);
+    fprintf(fd,"ast_tx_packets:%u\n",radio_stats->tx_mgmt + radio_stats->tx_num_data);
+    fprintf(fd,"ast_rx_packets:%u\n",radio_stats->rx_packets);
     fprintf(fd,"ast_tx_mgmt         :\t%d\n",radio_stats->tx_mgmt);
     fprintf(fd,"ast_tx_nobuf        :\t%d\n",tx->wmm_drop);
     fprintf(fd,"ast_tx_xretries     :\t%u\n",tx->tx_xretry);
diff -urN qca-wifi-org/qca_ol/osif_ol.c qca-wifi-mod/qca_ol/osif_ol.c
--- qca-wifi-org/qca_ol/osif_ol.c	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/qca_ol/osif_ol.c	2018-11-21 18:38:00.264974853 +0530
@@ -106,6 +106,16 @@
 extern bool osif_pltfrm_deliver_data(os_if_t osif, wbuf_t wbuf);
 #endif
 
+/* KWN Fragmentation structures */
+uint8_t kwn_tput_test_dsap[] = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa };
+uint8_t kwn_frag_dsap[]      = { 0xaa, 0xaa, 0xab, 0xab };
+struct kwn_frag_params {
+    uint16_t kwn_frag_flags;
+    uint16_t kwn_tot_len;
+    uint16_t kwn_pkt_pad;
+};
+#define KWN_LOG_PKT 0
+
 #if UMAC_VOW_DEBUG
 static inline void
 osif_ol_hadrstart_vap_vow_debug(osif_dev  *osdev, struct sk_buff *skb){
@@ -460,7 +470,15 @@
 }
 #endif /*end of ATH_DATA_RX_INFO_EN*/
 
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+};
 
+struct sk_buff *last_skb = NULL;
+struct sk_buff *last_tx_skb = NULL;
 
 #if QCA_NSS_PLATFORM
 void
@@ -469,10 +487,11 @@
     struct net_device *dev = OSIF_TO_NETDEV(osif);
     osif_dev  *osdev = (osif_dev *)osif;
     int nwifi = ((osif_dev *)osif)->nss_nwifi;
+    struct ieee80211_stats *iv_stats;
 
-#if ATH_SUPPORT_WRAP
+//#if ATH_SUPPORT_WRAP
     wlan_if_t vap = osdev->os_if;
-#endif
+//#endif
 
 #if QCA_OL_VLAN_WAR
     struct net_device *comdev;
@@ -482,6 +501,8 @@
     scn = ath_netdev_priv(comdev);
 #endif /* QCA_OL_VLAN_WAR */
 
+    iv_stats = wlan_get_stats(vap);
+
     while (skb_list) {
         struct sk_buff *skb;
         skb = skb_list;
@@ -569,7 +590,129 @@
 	}
 #endif  /* HOST_SW_LRO_ENABLE */
 
-        osif_send_to_nss(osif, skb, nwifi);
+	/* inc Tx packets/bytes offered by kernel to us */
+	iv_stats->rx_offer_pkt_cnt++;
+	iv_stats->rx_offer_pkt_bytes_cnt += skb->len;
+
+	if ( iv_stats->kwn_rx_tput_last_jiffies == 0 ) {
+		iv_stats->kwn_rx_tput_last_jiffies = jiffies;
+	} else {
+		if ( (jiffies - iv_stats->kwn_rx_tput_last_jiffies) >= 1000 )
+		{
+			iv_stats->kwn_rx_tput_mbps = iv_stats->rx_offer_pkt_cnt > 0 ? 
+				( (iv_stats->rx_offer_pkt_bytes_cnt * 8)) : 0;
+			iv_stats->kwn_rx_tput_last_jiffies = jiffies;
+			iv_stats->rx_offer_pkt_cnt = 0;
+			iv_stats->rx_offer_pkt_bytes_cnt = 0;
+			//printk(": RX Tput: %llu\n",iv_stats->kwn_rx_tput_mbps);
+		}
+	}
+
+	/* In case of KWN Tput Packets, then drop them immediately */
+	if ( skb->len > 20 && 
+			(memcmp(&skb->data[sizeof(struct ether_header)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap)) == 0)) {
+		if ( 1 /*vap->kwn_tput_test_in_progress == 0*/ ) {
+			struct kwn_tput_test_params *kparams;
+			int offset = 0;
+
+			offset += sizeof(struct ether_header) + sizeof(kwn_tput_test_dsap);
+			kparams = (struct kwn_tput_test_params *)&skb->data[ offset ];
+			vap->kwn_tput_test_duration = ntohl(kparams->kwn_tput_test_duration);
+			vap->kwn_tput_test_pkt_size = ntohl(kparams->kwn_tput_test_pktsize);
+			vap->kwn_tput_test_pkt_per_ms = ntohl(kparams->kwn_tput_test_pktperms);
+			vap->kwn_tput_test_direction = ntohl(kparams->kwn_tput_test_direction);
+			/*printk(": Dur: %d PktSize: %d PktPerMs: %d Dir: %d\n",
+				vap->kwn_tput_test_duration,
+				vap->kwn_tput_test_pkt_size,
+				vap->kwn_tput_test_pkt_per_ms,
+				vap->kwn_tput_test_direction);
+			if ( vap->kwn_tput_test_direction > 0 &&
+				vap->kwn_tput_test_direction > 1 ) {
+				if ( vap->iv_opmode == IEEE80211_M_HOSTAP )
+                printk("\n DL Tput Test Started....\n");
+                else
+                printk("\n UL Tput Test Started....\n");
+                vap->kwn_tput_test_in_progress = 1;
+                vap->kwn_tput_test_start_time = jiffies;
+                tasklet_schedule( &vap->kwn_tput_tq );
+                }*/
+        }
+        dev_kfree_skb_any ( skb );
+        continue;
+    }
+
+    /* KWN: Extra Padding */
+    if ( vap->kwn_assem_frag == 2 ) {
+        if ( skb->len > 20 &&
+                (memcmp( &skb->data[sizeof(struct ether_header)], kwn_frag_dsap, sizeof(kwn_frag_dsap)) == 0 )) {
+            struct kwn_frag_params *kparams;
+            int elen = sizeof(struct ether_header);
+            int flen = sizeof(struct kwn_frag_params) + sizeof(kwn_frag_dsap);
+            int pull_len = 0;
+
+            kparams = (struct kwn_frag_params *)&skb->data[sizeof(struct ether_header) + sizeof(kwn_frag_dsap)];
+            pull_len += (elen + flen + ntohs(kparams->kwn_pkt_pad));
+            skb_pull(skb, pull_len); 
+        }
+    } else if ( vap->kwn_assem_frag == 1 ) {
+        /* Re-assembly */
+        if ( skb->len > 20 &&
+                (memcmp( &skb->data[sizeof(struct ether_header)], kwn_frag_dsap, sizeof(kwn_frag_dsap)) == 0 )) {
+            struct kwn_frag_params *kparams;
+            kparams = (struct kwn_frag_params *)&skb->data[sizeof(struct ether_header) + sizeof(kwn_frag_dsap)];
+            if ( ntohs(kparams->kwn_frag_flags) == 0 ) {
+                if ( last_skb != NULL ) {
+                    struct sk_buff *nskb;
+                    struct ether_header *neth;
+                    struct ether_header *oeth;
+                    int offset = 0;
+                    int ooffset = 0;
+                    int nskb_reserve = 64;
+                    int elen = sizeof(struct ether_header);
+                    int flen = sizeof(struct kwn_frag_params) + sizeof(kwn_frag_dsap);
+                    int nskb_max_len = last_skb->len + skb->len - elen - (2 * flen);
+
+                    /* Create a packet */
+                    nskb = dev_alloc_skb ( nskb_max_len + nskb_reserve );
+                    if ( nskb == NULL ) {
+                        break;
+                    }
+
+                    /* Fill the skb content */
+                    offset = 0;
+                    skb_reserve( nskb, nskb_reserve );
+                    skb_put( nskb, nskb_max_len );
+
+                    /* Reset to ZERO */
+                    memset( &nskb->data[ offset ], 0, nskb_max_len );
+                    nskb->dev = skb->dev;
+
+                    neth = ( struct ether_header * ) &nskb->data[ offset ];
+                    oeth = ( struct ether_header * )  &skb->data[ offset ];
+                    IEEE80211_ADDR_COPY( neth->ether_dhost, oeth->ether_dhost );
+                    IEEE80211_ADDR_COPY( neth->ether_shost, oeth->ether_shost );
+                    neth->ether_type = oeth->ether_type;
+                    offset += elen;
+                    ooffset += elen;
+
+                    /* Payload : New Offset will be ahead by 6 bytes compared with old Offset */
+                    memcpy(&nskb->data[ offset  ], &last_skb->data[ offset + flen ], (last_skb->len - elen - flen));
+                    offset += (last_skb->len - elen - flen);
+
+                    memcpy(&nskb->data[ offset  ], &skb->data[ ooffset + flen ], (skb->len - elen - flen));
+                    osif_send_to_nss(osif, nskb, nwifi);
+                    dev_kfree_skb_any( last_skb );
+                    last_skb = NULL;
+                    dev_kfree_skb_any( skb );
+                    continue;
+                }
+            } else {
+                last_skb = skb;
+                continue;
+            }
+        }
+    }
+    osif_send_to_nss(osif, skb, nwifi);
     }
 
 #if HOST_SW_LRO_ENABLE
@@ -834,10 +977,25 @@
     osdev = ath_netdev_priv(dev);
     vap = osdev->os_if;
     iv_stats = wlan_get_stats(vap);
+
     /* inc Tx packets/bytes offered by kernel to us */
     iv_stats->tx_offer_pkt_cnt++;
     iv_stats->tx_offer_pkt_bytes_cnt += skb->len;
 
+    if ( iv_stats->kwn_tx_tput_last_jiffies == 0 ) {
+	    iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+    } else {
+	    if ( (jiffies - iv_stats->kwn_tx_tput_last_jiffies) >= 1000 )
+	    {
+		    iv_stats->kwn_tx_tput_mbps = iv_stats->tx_offer_pkt_cnt > 0 ? 
+						( (iv_stats->tx_offer_pkt_bytes_cnt * 8)) : 0;
+		    iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+		    iv_stats->tx_offer_pkt_cnt = 0;
+		    iv_stats->tx_offer_pkt_bytes_cnt = 0;
+		    //printk(": Tx Tput: %llu\n",iv_stats->kwn_tx_tput_mbps);
+	    }
+    }
+
     qdf_nbuf_count_inc(skb);
     if (qdf_unlikely((dev->flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP))) {
 	    goto bad1;
@@ -968,9 +1126,156 @@
     }
 #endif
 
+    /* If Packet started in Local, then Tag the packet with MgmtVLANID*/
+    if ( vap->kwn_mgmt_vlan_id > 0 && vap->kwn_allow_tagged_mgmt ) {
+	    eh = (struct ether_header *)(skb->data);
+	    if ( memcmp ( vap->kwn_eth_mac_addr, eh->ether_shost, 6 ) == 0 ) {
+		    skb = __vlan_put_tag( skb, htons(ETH_P_8021Q), vap->kwn_mgmt_vlan_id );
+		    if ( unlikely ( !skb ) ) {
+			    goto bad1;
+		    }
+	    }
+    }
+
+    /* KWN: AMSDU at Host */
+    if ( vap->kwn_assem_frag == 1 ) {
+        if ( skb->len < vap->kwn_max_pkt_size ) {
+            osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
+            goto out;
+        } else {
+            struct sk_buff *nskb;
+            struct ether_header *neth;
+            struct ether_header *oeth;
+            int offset = 0;
+            int oskb_max_len = 0;
+            int nskb_max_len = vap->kwn_frag_pkt_size;
+            struct kwn_frag_params *kparams;
+            int ecsum = 0;
+            int eth_reserve = 64;
+            int pkt_size = 0;
+            int ooffset = 0;
+            int flen = sizeof(kwn_frag_dsap) + sizeof(struct kwn_frag_params);
+            int elen = sizeof(struct ether_header);
+
+            oskb_max_len = skb->len;
+            for ( ; nskb_max_len > 0 ; ) {
+
+                /* Create a packet */
+                pkt_size = elen + flen + nskb_max_len + ecsum;
+                nskb = dev_alloc_skb ( pkt_size + eth_reserve );
+                if ( nskb == NULL ) {
+                    break;
+                }
+
+                /* Fill the skb content */
+                offset = 0;
+                skb_reserve( nskb, eth_reserve );
+                skb_put( nskb, pkt_size );
+                /* Reset to ZERO */
+                memset( &nskb->data[ offset ], 0, pkt_size );
+                nskb->dev = skb->dev;
+
+                /* Ethernet Header */
+                offset = 0;
+                neth = ( struct ether_header * ) &nskb->data[ offset ];
+                oeth = ( struct ether_header * )  &skb->data[ offset ];
+                IEEE80211_ADDR_COPY( neth->ether_dhost, oeth->ether_dhost );
+                IEEE80211_ADDR_COPY( neth->ether_shost, oeth->ether_shost );
+                neth->ether_type = oeth->ether_type;
+                offset += elen;
+                if ( oskb_max_len > vap->kwn_max_pkt_size ) {
+                    ooffset +=  elen;
+                }
 
-    osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
+                /* DSAP + Flags */
+                memcpy(&nskb->data[ offset ], kwn_frag_dsap, sizeof(kwn_frag_dsap));
+                kparams = (struct kwn_frag_params *)&nskb->data[ offset + sizeof(kwn_frag_dsap) ];
+                if ( oskb_max_len > vap->kwn_max_pkt_size ) {
+                    kparams->kwn_frag_flags = htons(1);
+                    kparams->kwn_tot_len = htons(skb->len);
+                } else {
+                    kparams->kwn_frag_flags = htons(0);
+                    kparams->kwn_tot_len = htons(0);
+                }
 
+                /* Payload : New Offset will be ahead by 6 bytes compared with old Offset */
+                memcpy(&nskb->data[ offset + flen ], &skb->data[ ooffset ], nskb_max_len);
+
+                /* TX Pkt */
+                osdev->iv_vap_send(osdev->iv_txrx_handle, nskb);
+
+                /* Update New Pkt Len */
+                ooffset += nskb_max_len;
+                oskb_max_len = oskb_max_len - nskb_max_len - elen;
+                nskb_max_len = oskb_max_len;
+
+                /* Pull the first 24 bytes */
+                skb_pull( nskb, 24 );
+            }
+            /* Drop the original packet */
+            if (skb != NULL)
+                qdf_nbuf_free(skb);
+        }     
+    } else if ( vap->kwn_assem_frag == 2 ) {
+        /* */
+        struct sk_buff *nskb;
+        struct ether_header *neth;
+        struct ether_header *oeth;
+        struct kwn_frag_params *kparams;
+        int flen = sizeof(kwn_frag_dsap) + sizeof(struct kwn_frag_params);
+        int elen = sizeof(struct ether_header);
+        int pad = vap->kwn_max_pkt_size - skb->len;
+        int offset = 0;
+        int eth_reserve = 64;
+        int pkt_size = 0;
+        
+        if ( pad < 0 ) {
+            pad = 0;
+        }
+        
+        /* Create a packet */
+        pkt_size = elen + flen + skb->len + pad;
+        nskb = dev_alloc_skb ( pkt_size + eth_reserve );
+        if ( nskb == NULL ) {
+            goto bad;
+        }
+
+        /* Fill the skb content */
+        offset = 0;
+        skb_reserve( nskb, eth_reserve );
+        skb_put( nskb, pkt_size );
+        /* Reset to ZERO */
+        memset( &nskb->data[ offset ], 0, pkt_size );
+        nskb->dev = skb->dev;
+
+        /* Ethernet Header */
+        neth = ( struct ether_header * ) &nskb->data[ offset ];
+        oeth = ( struct ether_header * )  &skb->data[ offset ];
+        IEEE80211_ADDR_COPY( neth->ether_dhost, oeth->ether_dhost );
+        IEEE80211_ADDR_COPY( neth->ether_shost, oeth->ether_shost );
+        neth->ether_type = oeth->ether_type;
+        offset += elen;
+
+        /* DSAP + Flags */
+        memcpy(&nskb->data[ offset ], kwn_frag_dsap, sizeof(kwn_frag_dsap));
+        kparams = (struct kwn_frag_params *)&nskb->data[ offset + sizeof(kwn_frag_dsap) ];
+        kparams->kwn_frag_flags = htons(0);
+        kparams->kwn_tot_len = htons(skb->len);
+        kparams->kwn_pkt_pad = htons(pad);
+        
+        offset += flen + pad;
+
+        /* Copy the Original packet into New Packet */
+        memcpy(&nskb->data[ offset ], &skb->data[ 0 ], skb->len);
+
+        /* TX Pkt */
+        osdev->iv_vap_send(osdev->iv_txrx_handle, nskb);
+        /* Drop the original packet */
+        if (skb != NULL)
+            qdf_nbuf_free(skb);
+    } else {
+        osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
+    }
 out:
     OSIF_VAP_TX_UNLOCK(osdev);
     return 0;
diff -urN qca-wifi-org/umac/base/ieee80211_channel.c qca-wifi-mod/umac/base/ieee80211_channel.c
--- qca-wifi-org/umac/base/ieee80211_channel.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_channel.c	2018-11-15 11:29:43.018412290 +0530
@@ -21,6 +21,7 @@
 #include <if_smart_ant.h>
 #include <qdf_lock.h>
 #include <osif_private.h>
+#include <ieee80211_acs_internal.h>
 
 int ieee80211_ucfg_set_chanswitch(wlan_if_t vaphandle, u_int8_t chan, u_int8_t tbtt, u_int16_t ch_width);
 
@@ -353,6 +354,74 @@
     osif_update_info_to_app(ic, buf);
 }
 
+struct ieee80211_channel * kwn_find_channel(struct ieee80211com *ic, struct ieee80211vap *vap, u_int16_t freq )
+{
+    struct ieee80211_channel *c;
+    u_int32_t flags;
+
+    switch( vap->iv_des_mode )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                flags = IEEE80211_CHAN_A;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                flags = IEEE80211_CHAN_11NA_HT20;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                flags = IEEE80211_CHAN_11NA_HT40PLUS;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40MINUS:
+            {
+                flags = IEEE80211_CHAN_11NA_HT40MINUS;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT20;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT40PLUS;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT40;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT40MINUS;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT80;
+                break;
+            }
+        default:
+            return NULL;
+    }
+
+    c = ieee80211_find_channel( ic, freq, 0, flags );
+    return c;
+}
+
+void kwn_sa_set_channel( struct ieee80211com *ic )
+{
+    ic->ic_set_channel( ic );
+}
 
 /*
  * Locate a channel given a frequency+flags.  We cache
@@ -1930,6 +1999,7 @@
 {
     struct ieee80211vap *vap = vaphandle;
     struct ieee80211com *ic = vap->iv_ic;
+    struct ieee80211_acs *acs = ic->ic_acs;
 
     if (!channel) {
         IEEE80211_DPRINTF(vap, IEEE80211_MSG_ACS,
@@ -1989,6 +2059,19 @@
      * TBD: If curchan = channel, still need to set channel again to pass
      * SendRecv_ext in ndistest.
      */
+    /* Fixed channel in client mode: updating configured frequency if acs is disabled */
+    if( ic->sta_freq == 0 )
+       ic->sta_freq = channel->ic_freq;
+
+    /* TODO: Fixed channel in client mode is not working on 80MHz, so enabling ACS on 80MHz*/
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP || vap->iv_des_mode == IEEE80211_MODE_11AC_VHT80 )
+    {
+        /* For Fixed channel in AP, updating the acs chans to 0 */
+        if( ic->sta_freq > 0 ) {
+            acs->acs_nchans_scan = 0;
+        }
+        ic->sta_freq = -1;
+    }
     if (ieee80211_vap_ready_is_set(vap) || ieee80211_vap_dfswait_is_set(vap) ||
         (ic->cw_inter_found)) {// && ic->ic_curchan != channel) {
         ieee80211_set_channel(ic, channel);
diff -urN qca-wifi-org/umac/base/ieee80211_config.c qca-wifi-mod/umac/base/ieee80211_config.c
--- qca-wifi-org/umac/base/ieee80211_config.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_config.c	2018-11-01 15:05:22.844829566 +0530
@@ -478,12 +478,13 @@
              vap->iv_fixed_rate.series = IEEE80211_FIXED_RATE_NONE;
         } else {
              if (val & 0x80) {
-
+#if 0
                 if (!IEEE80211_IS_CHAN_VHT(ic->ic_curchan) && !IEEE80211_IS_CHAN_11N(ic->ic_curchan))
                 {
                     QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Rate is not allowed in current mode\n");
                     return -EINVAL;
                 }
+#endif
                 vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_MCS;
              } else {
                  vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_LEGACY;
@@ -1115,9 +1116,10 @@
          }
          vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_NONE;
 
-         if (val > 9) {
+         if (val == 21) {
             /* Treat this as disabling fixed rate */
-            return EOK;
+             break;
+            //return EOK;
          }
 
 	 if (is2GHz && (val > 7) && (!ieee80211_vap_256qam_is_set(vap))) {
@@ -1125,10 +1127,14 @@
 		 return EOK;
 	 }
 
+         vap->iv_nss = 1;
+         if( val > 9 ) {
+             vap->iv_nss = 2;
+             val = val - 10;
+         }
          vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_VHT;
          vap->iv_vht_fixed_mcs = val;
     break;
-
     case IEEE80211_FIXED_NSS:
          if (val > ieee80211_getstreams(ic, ic->ic_tx_chainmask))
          return -EINVAL;
@@ -2667,7 +2673,6 @@
              val = vap->iv_vht_fixed_mcs;
          }
     break;
-
     case IEEE80211_FIXED_NSS:
          val = vap->iv_nss;
     break;
diff -urN qca-wifi-org/umac/base/ieee80211_node.c qca-wifi-mod/umac/base/ieee80211_node.c
--- qca-wifi-org/umac/base/ieee80211_node.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_node.c	2018-11-06 14:26:21.818335650 +0530
@@ -142,6 +142,86 @@
     struct ieee80211_node *nodes[IEEE80211_512_AID];
 };
 
+struct kwn_power {
+    uint8_t ac_power[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t na_power[ KWN_11NA_RATE_MAX + 1 ];
+    uint8_t a_power[ KWN_11A_RATE_MAX + 1 ];
+};
+
+struct kwn_snr {
+    uint8_t ac_snr[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t na_snr[ KWN_11NA_RATE_MAX + 1 ];
+    uint8_t a_snr[ KWN_11A_RATE_MAX + 1 ];
+};
+
+struct kwn_auto_indx {
+    uint8_t ac_indx[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t na_indx[ KWN_11NA_RATE_MAX + 1 ];
+};
+
+struct kwn_power power_20mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 23, 22, 22, 21, 21, 20, 20, 19, 18, 17, 23, 22, 22, 21, 21, 20, 20, 19, 18, 17 },
+    { 23, 22, 21, 20, 20, 19, 18, 17, 23, 22, 21, 20, 20, 19, 18, 17 },
+    { 23, 22, 21, 20, 20, 19, 18, 17 }
+};
+
+struct kwn_snr minsnr_20mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    {  5,  6,  8, 10, 12, 14, 16, 19, 23, 25,  7, 10, 12, 13, 16, 19, 21, 23, 25, 27 },
+    {  5,  6,  8, 10, 12, 14, 16, 19, 7,  10, 12, 13, 16, 19, 21, 23 },
+    {  5,  6,  8, 10, 12, 14, 16, 19 }
+};
+
+struct kwn_snr minsnr_40mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    {  5,  6,  8, 10, 12, 14, 16, 19, 23, 25,  7, 10, 12, 13, 16, 19, 21, 23, 25, 27 },
+    {  5,  6,  8, 10, 12, 14, 16, 19, 7,  10, 12, 13, 16, 19, 21, 23 },
+    {  5,  6,  8, 10, 12, 14, 16, 19 }
+};
+
+struct kwn_snr minsnr_80mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    {  5,  6,  8, 10, 12, 14, 16, 19, 23, 25,  7, 10, 12, 13, 16, 19, 21, 23, 25, 27 },
+    {  5,  6,  8, 10, 12, 14, 16, 19, 7,  10, 12, 13, 16, 19, 21, 23 },
+    {  5,  6,  8, 10, 12, 14, 16, 19 }
+};
+
+struct kwn_snr maxsnr_20mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 80, 80, 80, 80, 80, 65, 65, 65, 62, 62, 80, 80, 80, 80, 80, 64, 64, 64, 62, 62 },
+    { 80, 80, 80, 80, 80, 65, 65, 65, 80, 80, 80, 80, 80, 64, 64, 64 },
+    { 80, 80, 80, 80, 80, 65, 65, 65 }
+};
+
+struct kwn_snr maxsnr_40mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 80, 80, 80, 80, 80, 65, 65, 65, 63, 63, 80, 80, 80, 80, 80, 63, 63, 63, 62, 62 },
+    { 80, 80, 80, 80, 80, 65, 65, 65, 80, 80, 80, 80, 80, 63, 63, 63 },
+    { 0,  0,  0,  0,  0,  0,  0,  0 }
+};
+
+struct kwn_snr maxsnr_80mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 80, 80, 80, 80, 80, 65, 65, 65, 62, 62, 80, 80, 80, 80, 80, 65, 65, 65, 63, 63 },
+    { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
+    { 0,  0,  0,  0,  0,  0,  0,  0 }
+};
+
+struct kwn_auto_indx auto_indx = 
+{
+  /* 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 */
+  {  0, 10,  1,  2, 11,  3, 12,  4, 13,  5,  6,  7, 14,  8,  9, 15, 16, 17, 18, 19 },
+  {  0,  8,  1,  2,  9,  3, 10,  4, 11,  5,  6,  7, 12, 13, 14, 15 },
+};
+
 #define IEEE80211_NODE_ITER_F_ASSOC_STA     0x1
 #define IEEE80211_NODE_ITER_F_UNASSOC_STA   0x2
 static void
@@ -151,10 +231,559 @@
 ieee80211_node_remove_ipv6_by_node(struct ieee80211_node_table *nt, struct ieee80211_node *ni);
 #endif
 
-
 extern void
 ol_if_mgmt_drain(struct ieee80211_node *ni, int force);
 
+extern void ieee80211_apply_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni, int8_t channel, int8_t pwr, int8_t rate );
+
+uint8_t kwn_get_min_snr( struct ieee80211vap *vap, uint8_t mcs )
+{
+    uint8_t min_snr = 128;
+
+    switch( vap->iv_des_mode )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                min_snr = minsnr_20mhz.a_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                min_snr = minsnr_20mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                min_snr = minsnr_40mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                min_snr = minsnr_20mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                min_snr = minsnr_40mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                min_snr = minsnr_80mhz.ac_snr[ mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return min_snr;
+}
+
+uint8_t kwn_get_max_snr( struct ieee80211vap *vap, uint8_t mcs )
+{
+    uint8_t max_snr = 0;
+
+    switch( vap->iv_des_mode )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                max_snr = maxsnr_20mhz.a_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                max_snr = maxsnr_20mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                max_snr = maxsnr_40mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                max_snr = maxsnr_20mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                max_snr = maxsnr_40mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                max_snr = maxsnr_80mhz.ac_snr[ mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return max_snr;
+}
+
+void kwn_get_maxrate( struct ieee80211vap *vap, uint8_t *max_srate, uint8_t *max_rate )
+{
+    switch( vap->iv_des_mode )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                *max_srate = KWN_11A_SRATE_MAX;
+                *max_rate  = KWN_11A_RATE_MAX;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                *max_srate = KWN_11NA_SRATE_MAX;
+                *max_rate  = KWN_11NA_RATE_MAX;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                *max_srate = KWN_11AC_SRATE_MAX;
+                *max_rate  = KWN_11AC_RATE_MAX;
+                break;
+            }
+        default:
+            return;
+    }
+    return;
+}
+
+uint8_t kwn_get_remote_snr( struct ieee80211com *ic, u_int8_t snr_avg[], uint8_t mcs, uint8_t max_srate )
+{
+    uint8_t txchainmask, min_snr, max_snr;
+
+    /* TODO: Per node remote chainmask */
+    txchainmask = ieee80211com_get_tx_chainmask( ic );
+
+    switch( txchainmask ) {
+        case KWN_CHAINMASK_A1:
+            {
+                min_snr = snr_avg[0];
+                max_snr = snr_avg[0];
+                break;
+            }
+        case KWN_CHAINMASK_A2:
+            {
+                min_snr = snr_avg[1];
+                max_snr = snr_avg[1];
+                break;
+            }
+        case KWN_CHAINMASK_A1A2:
+            {
+                min_snr = min( snr_avg[0], snr_avg[1] );
+                max_snr = max( snr_avg[0], snr_avg[1] );
+                break;
+            }
+    }
+
+    if( mcs > max_srate ) {
+        return max_snr;
+    }
+    return min_snr;
+}
+
+uint8_t kwn_get_auto_mcs_indx( struct ieee80211vap *vap, uint8_t mcs )
+{
+    uint8_t auto_mcs = 0;
+
+    switch( vap->iv_des_mode )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                auto_mcs = auto_indx.na_indx[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                auto_mcs = auto_indx.ac_indx[ mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return auto_mcs;
+}
+
+int kwn_check_snr_at_mcs( struct ieee80211_node *ni, uint8_t mcs )
+{
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    uint8_t max_srate, max_rate;
+    uint8_t remote_snr;
+
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+    /* TODO: Per node max rate */
+    kwn_get_maxrate( vap, &max_srate, &max_rate );
+
+    if( ni->kwn_profile_cfg.txparam.spatial_stream == KWN_STREAM_AUTO ) {
+        mcs = kwn_get_auto_mcs_indx( vap, mcs );
+    }
+    if( mcs > max_rate ) {
+        return -1;
+    }
+    remote_snr = kwn_get_remote_snr( ic, ni->kwn_snr_avg.remote_snr_avg, mcs, max_srate );
+#ifdef KWN_DDRS_PRINT
+    printk(": DDRS: Max SRate %d Max Rate %d Remote SNR %d \n",max_srate,max_rate,remote_snr);
+#endif
+
+    if( remote_snr > kwn_get_min_snr( vap, mcs ) ) {
+        return 0;
+    }
+    return -1;
+}
+
+void kwn_ddrs_check_timer( u_int8_t *inc, u_int8_t *dec, u_int8_t last_action, 
+        u_int64_t last_jiffies, u_int8_t inc_timer, u_int8_t dec_timer )
+{
+    u_int8_t curr_action = ( *inc == 1 ? KWN_DDRS_RATE_INC : KWN_DDRS_RATE_DEC );
+    u_int64_t curr_jiffies = jiffies;
+    unsigned long diff = curr_jiffies - last_jiffies;
+
+    if( last_jiffies == 0 )
+        return;
+
+    *inc = 0;
+    *dec = 0;
+
+    switch( last_action ) {
+        case KWN_DDRS_RATE_INC:
+            {
+                switch( curr_action ) {
+                    case KWN_DDRS_RATE_INC:
+                        {
+                            /* Incr-Incr: Check Rate Inc Timer expired */
+                            if( ( diff / 1000 ) > inc_timer )
+                            {
+#ifdef KWN_DDRS_PRINT
+                                printk(": DDRS: Incr Timer expired. Diff %lu\n",diff);
+#endif
+                                *inc = 1;
+                            }
+                            break;
+                        }
+                    case KWN_DDRS_RATE_DEC:
+                        {
+                            /* Incr-Decr: Decrement Immediately */
+                            *dec = 1;
+                        }
+                        break;
+                    default:
+                        break;
+                }
+            }
+            break;
+        case KWN_DDRS_RATE_DEC:
+            {
+                switch( curr_action ) {
+                    case KWN_DDRS_RATE_INC:
+                        {
+                            /* Decr-Incr: Check Rate Inc Timer expired */
+                            if( ( diff / 1000 ) > inc_timer )
+                            {
+#ifdef KWN_DDRS_PRINT
+                                printk(": DDRS: Incr Timer expired. Diff %lu\n",diff);
+#endif
+                                *inc = 1;
+                            }
+                            break;
+                        }
+                    case KWN_DDRS_RATE_DEC:
+                        {
+                            /* Decr-Decr: Check Rate dec Timer expired */
+                            if( ( diff / 1000 ) > dec_timer )
+                            {
+#ifdef KWN_DDRS_PRINT
+                                printk(": DDRS: Decr Timer expired. Diff %lu\n",diff);
+#endif
+                                *dec = 1;
+                            }
+                            break;
+                        }
+                    default:
+                        break;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    return;
+}
+
+void kwn_ddrs_rate_increment( struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap;
+    uint8_t max_srate, max_rate;
+    int8_t mcs = ni->kwn_profile_cfg.curr_rate + 1;
+
+    vap = ni->ni_vap;
+    kwn_get_maxrate( vap, &max_srate, &max_rate );
+    if( mcs > max_rate || mcs > ni->kwn_profile_cfg.txparam.max_rate ) {
+        return;
+    }
+    ni->kwn_profile_cfg.curr_rate = mcs;
+    ni->kwn_profile_cfg.ddrs_last_action = KWN_DDRS_RATE_INC;
+    ni->kwn_profile_cfg.ddrs_last_jiffies = jiffies;
+}
+
+void kwn_ddrs_rate_decrement( struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap;
+    int8_t mcs = ni->kwn_profile_cfg.curr_rate - 1;
+
+    vap = ni->ni_vap;
+    if( mcs < KWN_RATE_MIN || mcs < ni->kwn_profile_cfg.txparam.min_rate ) {
+        return;
+    }
+    ni->kwn_profile_cfg.curr_rate = mcs;
+    ni->kwn_profile_cfg.ddrs_last_action = KWN_DDRS_RATE_DEC;
+    ni->kwn_profile_cfg.ddrs_last_jiffies = jiffies;
+}
+
+OS_TIMER_FUNC( kwn_node_ddrs_timer_func )
+{
+    struct ieee80211_node *ni;
+    struct ieee80211vap *vap;
+    u_int8_t inc = 0, dec = 0, apply_rate;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    vap = ni->ni_vap;
+#ifdef KWN_DDRS_PRINT
+    printk(": DDRS: Min %d Max %d Cur %d ",ni->kwn_profile_cfg.txparam.min_rate, ni->kwn_profile_cfg.txparam.max_rate, ni->kwn_profile_cfg.curr_rate);
+    printk(": DDRS: Remote SNR A1:%d A2:%d Rate %d\n",ni->remote_snr_a1,ni->remote_snr_a2,ni->kwn_txrate);
+#endif
+    if( ni->kwn_profile_cfg.txparam.min_rate > ni->kwn_profile_cfg.txparam.max_rate ) {
+#ifdef KWN_DDRS_PRINT
+        printk(": DDRS: Min Rate is greater than Max Rate\n");
+#endif
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+    /* Fixed Rate or First rate */
+    if( ni->kwn_profile_cfg.txparam.min_rate == ni->kwn_profile_cfg.txparam.max_rate || 
+            ni->kwn_profile_cfg.curr_rate == -1 ) {
+        ni->kwn_profile_cfg.curr_rate = ni->kwn_profile_cfg.txparam.min_rate;
+        if( ni->kwn_txrate != ni->kwn_profile_cfg.txparam.min_rate ) {
+#ifdef KWN_DDRS_PRINT
+            printk(": DDRS: Fixed Rate or First Rate applied %d \n", ni->kwn_txrate);
+#endif
+            ieee80211_apply_txparams( vap, ni, -1, ni->kwn_profile_cfg.txparam.min_rate, -1 );
+        }
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+
+    if( ni->kwn_profile_cfg.curr_rate < ni->kwn_profile_cfg.txparam.min_rate || 
+            ni->kwn_profile_cfg.curr_rate > ni->kwn_profile_cfg.txparam.max_rate ) {
+        ni->kwn_profile_cfg.curr_rate = -1;
+#ifdef KWN_DDRS_PRINT
+        printk(": DDRS: Resetting algorithm....Start from min rate \n");
+#endif
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+    if( kwn_check_snr_at_mcs( ni, ni->kwn_profile_cfg.curr_rate ) == 0 ) {
+        if( kwn_check_snr_at_mcs( ni, ni->kwn_profile_cfg.curr_rate + 1 ) == 0 ) {
+            inc = 1;
+        }
+    }
+    else {
+        dec = 1;
+    }
+
+    if( inc == 1 || dec == 1 ) {
+        kwn_ddrs_check_timer( &inc, &dec, ni->kwn_profile_cfg.ddrs_last_action, ni->kwn_profile_cfg.ddrs_last_jiffies, 
+                ni->kwn_profile_cfg.txparam.inc_timer, ni->kwn_profile_cfg.txparam.dec_timer );
+        if( inc == 1 ) {
+            kwn_ddrs_rate_increment( ni );
+        }
+        if( dec == 1 ) {
+            kwn_ddrs_rate_decrement( ni );
+        }
+    }
+
+    apply_rate = ni->kwn_profile_cfg.curr_rate;
+    if( ni->kwn_profile_cfg.txparam.spatial_stream == KWN_STREAM_AUTO ) {
+        apply_rate = kwn_get_auto_mcs_indx( vap, apply_rate );
+    }
+    if( ni->kwn_txrate != apply_rate ) {
+#ifdef KWN_DDRS_PRINT
+        printk(": DDRS: Rate applied from %d to %d \n",ni->kwn_txrate, apply_rate);
+#endif
+        ieee80211_apply_txparams( vap, ni, -1, apply_rate, -1 );
+    }
+    OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+}
+
+OS_TIMER_FUNC( kwn_node_snr_timer_func )
+{
+    struct ieee80211_node *ni;
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    u_int8_t i,j;
+    u_int32_t total;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+
+    ic->ic_kwn_get_ol_stats( vap, ic );
+    if( ni->kwn_snr_avg.snr_indx > KWN_SNR_SAMPLES_MAX )
+        ni->kwn_snr_avg.snr_indx = 0;
+    if( ni->kwn_snr_avg.sample_count < KWN_SNR_SAMPLES_MAX )
+        ni->kwn_snr_avg.sample_count++;
+    if (vap->iv_opmode == IEEE80211_M_HOSTAP) {
+        ni->kwn_snr_avg.local_snr[0][ni->kwn_snr_avg.snr_indx] = ni->ni_stats.ns_rssi_chain[0];
+        ni->kwn_snr_avg.local_snr[1][ni->kwn_snr_avg.snr_indx] = ni->ni_stats.ns_rssi_chain[1];
+    }
+    else {
+        ni->kwn_snr_avg.local_snr[0][ni->kwn_snr_avg.snr_indx] = vap->kwn_local_snr_a1;
+        ni->kwn_snr_avg.local_snr[1][ni->kwn_snr_avg.snr_indx] = vap->kwn_local_snr_a2;
+    }
+    ni->kwn_snr_avg.snr_indx++;
+#if 0
+    printk(": SNR Avg: Sample Count %d SNR index %d \n", ni->kwn_snr_avg.sample_count, ni->kwn_snr_avg.snr_indx);
+#endif
+    if( ni->kwn_snr_avg.sample_count > 0 ) {
+        for( i = 0; i < IEEE80211_MAX_ANTENNA; i++ ) {
+            total = 0;
+            for( j = 0; j < ni->kwn_snr_avg.sample_count; j++ ) {
+#if 0
+                printk("%d ",ni->kwn_snr_avg.local_snr[i][j]);
+#endif
+                total += ni->kwn_snr_avg.local_snr[i][j];
+            }
+            ni->kwn_snr_avg.local_snr_avg[i] = total / ni->kwn_snr_avg.sample_count;
+#if 0
+            printk("\n: SNR Avg: Avg SNR %d at chain %d \n",ni->kwn_snr_avg.local_snr_avg[i],i);
+#endif
+        }
+    }
+#if 0
+    printk(": SNR Avg: Local %d %d Remote %d %d \n",ni->kwn_snr_avg.local_snr_avg[0],ni->kwn_snr_avg.local_snr_avg[1],
+            ni->kwn_snr_avg.remote_snr_avg[0],ni->kwn_snr_avg.remote_snr_avg[1]);
+#endif
+    OS_SET_TIMER( &ni->kwn_snr_timer, KWN_SNR_TIMER_INT );
+}
+
+OS_TIMER_FUNC( kwn_node_atpc_timer_func )
+{
+    struct ieee80211_node *ni;
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    uint8_t max_srate, max_rate, min_snr, remote_snr, power;
+    int8_t actual_snr;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+    if( ni->kwn_profile_cfg.txparam.atpc_status != 1 ) {
+#ifdef KWN_ATPC_PRINT
+        printk(": ATPC: Fixed power applied %d \n",ni->kwn_profile_cfg.txparam.power);
+#endif
+        ieee80211_apply_txparams( vap, ni, -1, -1, ni->kwn_profile_cfg.txparam.power );
+        OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+        return;
+    }
+    /* Set initial power */
+    if( ni->kwn_profile_cfg.atpc_power == -1 ) {
+        /* TODO: power rate table per bandwidth per channel */
+        power = power_20mhz.ac_power[ ni->kwn_txrate ];
+#ifdef KWN_ATPC_PRINT
+        printk(": ATPC: Initial Power applied %d \n",power);
+#endif
+    }
+    else {
+        /* TODO: Per node max rate */
+        kwn_get_maxrate( vap, &max_srate, &max_rate );
+        remote_snr = kwn_get_remote_snr( ic, ni->kwn_snr_avg.remote_snr_avg, ni->kwn_txrate, max_srate );
+        actual_snr = kwn_get_max_snr( vap, ni->kwn_txrate ) - KWN_ATPC_LOWER_MARGIN;
+#ifdef KWN_ATPC_PRINT
+        printk(": ATPC: Remote SNR %d Actual SNR %d \n",remote_snr, actual_snr);
+#endif
+        if( remote_snr < actual_snr ) {
+            power = ni->kwn_profile_cfg.atpc_power + 1;
+        }
+        else if( remote_snr > actual_snr ) {
+            min_snr = kwn_get_min_snr( vap, ni->kwn_txrate );
+            if( ni->remote_snr_a1 > ( min_snr + 1 ) && 
+                    ni->remote_snr_a2 > ( min_snr + 1 ) ) {
+                power = ni->kwn_profile_cfg.atpc_power - 1;
+            }
+            else {
+                OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+                return;
+            }
+        }
+        else {
+            OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+            return;
+        }
+    }
+
+    if( power >= KWN_ATPC_POWER_MIN && power <= KWN_ATPC_POWER_MAX ) {
+#ifdef KWN_ATPC_PRINT
+        printk(": ATPC: Power applied from %d to %d \n",ni->kwn_profile_cfg.atpc_power,power);
+#endif
+        ni->kwn_profile_cfg.atpc_power = power;
+        ieee80211_apply_txparams( vap, ni, -1, -1, power );
+    }
+    OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+}
+
+static OS_TIMER_FUNC( kwn_node_stats_timer_func )
+{
+    struct ieee80211_node *ni;
+    wlan_dev_t ic;
+    wlan_if_t vap;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+
+    ieee80211_send_node_stats( vap, ni );
+    OS_SET_TIMER( &ni->kwn_stats_timer, KWN_STATS_TIMER_INT );
+}
+
 static struct ieee80211_node *
 node_alloc(struct ieee80211vap *vap, const u_int8_t *macaddr, bool tmpnode)
 {
@@ -168,7 +797,7 @@
         return NULL;
     }
     OS_MEMZERO(ni, sizeof(struct ieee80211_node));
-
+ 
 #if IEEE80211_DEBUG_REFCNT
     ni->trace = (struct node_trace_all *)OS_MALLOC(ic->ic_osdev, sizeof(struct node_trace_all), GFP_KERNEL);
     if (ni->trace == NULL) {
@@ -266,6 +895,21 @@
     ni->ni_disassoc_tx_xretry = 0;
     ni->ni_deauth_tx_xretry = 0;
 
+    ni->kwn_txrate = 0;
+    ni->kwn_rxrate = 0;
+    ni->kwn_profile_cfg.txparam.spatial_stream = KWN_STREAM_AUTO;
+    ni->kwn_profile_cfg.txparam.min_rate = 0;
+    ni->kwn_profile_cfg.txparam.max_rate = 0;
+    ni->kwn_profile_cfg.txparam.inc_timer = 2;
+    ni->kwn_profile_cfg.txparam.dec_timer = 1;
+    ni->kwn_profile_cfg.txparam.atpc_status = 0;
+    ni->kwn_profile_cfg.txparam.power = 26;
+    ni->kwn_profile_cfg.curr_rate = -1;
+    ni->kwn_profile_cfg.atpc_power = -1;
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_stats_timer, kwn_node_stats_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_snr_timer, kwn_node_snr_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_ddrs_timer, kwn_node_ddrs_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_atpc_timer, kwn_node_atpc_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
 
     ieee80211_ref_node(ni);     /* mark referenced */
 
@@ -442,6 +1086,11 @@
         }
     }
 #endif
+    /* KWN */
+    ni->kwn_txrate = 0;
+    ni->kwn_rxrate = 0;
+    ni->kwn_txpwr = 26;
+    ni->kwn_rxpwr = 26;
     ni->is_extender_client = 0;
 
     ieee80211node_clear_whc_rept_info(ni);
@@ -1975,6 +2624,10 @@
     bool node_reclaimed=false;
     OS_BEACON_DECLARE_AND_RESET_VAR(flags);
 
+    OS_FREE_TIMER( &ni->kwn_stats_timer );
+    OS_FREE_TIMER( &ni->kwn_snr_timer );
+    OS_FREE_TIMER( &ni->kwn_ddrs_timer );
+    OS_FREE_TIMER( &ni->kwn_atpc_timer );
     IEEE80211_NOTE(ni->ni_vap, IEEE80211_MSG_ASSOC, ni,
                    "%s: 0x%x \n", __func__,ni);
     OS_BEACON_WRITE_LOCK(&nt->nt_nodelock, &lock_state, flags);
diff -urN qca-wifi-org/umac/base/ieee80211_ucfg.c qca-wifi-mod/umac/base/ieee80211_ucfg.c
--- qca-wifi-org/umac/base/ieee80211_ucfg.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_ucfg.c	2018-11-15 11:30:55.386419810 +0530
@@ -50,6 +50,28 @@
 #define HIGHEST_BASIC_RATE 24000
 #define THREE_HUNDRED_FIFTY_MBPS 350000
 
+/* KWN: Ethernet EDMA Routines */
+extern int edma_set_vid_bitmap(struct net_device *dev, int16_t vid, int16_t flags);
+extern int edma_clear_vid_bitmap(struct net_device *dev, int16_t vid);
+extern int edma_set_vlan_mode(struct net_device *dev, int8_t vlan_mode);
+extern int edma_set_allow_tagged_mgmt(struct net_device *dev, int8_t allow_tagged_mgmt);
+extern int edma_set_allow_untagged(struct net_device *dev, int8_t allow_untagged);
+extern int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all );
+extern int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType );
+extern uint64_t edma_get_tx_pkts( struct net_device *dev );
+extern uint64_t edma_get_tx_errors( struct net_device *dev );
+extern uint64_t edma_get_tx_bytes( struct net_device *dev );
+extern uint64_t edma_get_rx_pkts( struct net_device *dev );
+extern uint64_t edma_get_rx_errors( struct net_device *dev );
+extern uint64_t edma_get_rx_bytes( struct net_device *dev );
+extern int edma_get_mgmt_vlan_id( struct net_device *dev );
+extern int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id );
+
 extern int ol_ath_ucfg_get_user_postion(wlan_if_t vaphandle, u_int32_t aid);
 extern int ol_ath_ucfg_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
 extern int ol_ath_ucfg_reset_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
@@ -57,6 +79,8 @@
 static struct ieee80211_channel* checkchan(wlan_if_t vaphandle,
                                           int channel, int secChanOffset);
 extern int ieee80211_rate_is_valid_basic(struct ieee80211vap *, u_int32_t);
+extern void ieee80211_apply_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni, int8_t channel, int8_t rate, int8_t pwr );
+extern void ieee80211_send_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni );
 #if MESH_MODE_SUPPORT
 int ieee80211_add_localpeer(wlan_if_t vap, char *params);
 int ieee80211_authorise_local_peer(wlan_if_t vap, char *params);
@@ -985,6 +1009,7 @@
     int i;
 #endif
     uint32_t fils_en_period = 0;
+    struct ieee80211_node *ni;
 
     if (osifp->is_delete_in_progress)
         return -EINVAL;
@@ -2642,7 +2667,10 @@
     case IEEE80211_IOC_SCAN_FLUSH:
         IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL, "set %s\n",
                         "IEEE80211_IOC_SCAN_FLUSH");
-        wlan_scan_table_flush(vap);
+        /* Flush the entries only when user set */
+        if ( vap->kwn_flag == SCAN_ENTRY_FLUSH ) {
+            wlan_scan_table_flush(vap);
+        }
         retv = 0; /* success */
         break;
 
@@ -3974,7 +4002,384 @@
     case IEEE80211_PARAM_DFS_INFO_NOTIFY_APP:
         ic->ic_dfs_info_notify_channel_available = !!value;
         break;
+    case IEEE80211_PARAM_UPLINK_LIMIT:
+        vap->kwn_ul_limit = value;
+        break;
+    case IEEE80211_PARAM_DOWNLINK_LIMIT:
+        vap->kwn_dl_limit = value;
+        break;
+    case IEEE80211_PARAM_KWN_VLAN_MODE: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_vlan_mode(eth_dev, value);
+		printk(": Ethernet VLANMode: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_VID_ADD:
+	{
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_vid_bitmap(eth_dev, value, 0);
+		printk(": Set Vid: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_VID_DEL: 
+	{
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_clear_vid_bitmap(eth_dev, value);
+		printk(": Clear Vid: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_ALLOW_UNTAGGED: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		if ( value == 0 || value == 1 ) {
+			edma_set_allow_untagged(eth_dev, value);
+			edma_set_allow_all_tagged_trunk(eth_dev, 0);
+		}
+		else if ( value == 2 ) {
+			edma_set_allow_untagged(eth_dev, 0);
+			edma_set_allow_all_tagged_trunk(eth_dev, 1);
+		} else {
+			edma_set_allow_untagged(eth_dev, 0);
+			edma_set_allow_all_tagged_trunk(eth_dev, 0);
+		}
+		printk(": Allow Untagged: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_ACCESS_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_access_vlan_id(eth_dev, value);
+		printk(": Access VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_NATIVE_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_native_vlan_id(eth_dev, value);
+		printk(": Native VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_MGMT_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_mgmt_vlan_id(eth_dev, value);
+		vap->kwn_mgmt_vlan_id = value;
+		memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+		printk(": Mgmt VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_SVLAN_ID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_svlan_id(eth_dev, value);
+		printk(": SVlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_svlan_etherType(eth_dev, value);
+		printk(": SVlan EtherType: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST: 
+	if ( value ) {
+		printk("\n Start Test ...\n");
+        vap->kwn_tput_test_start_time = jiffies;
+        vap->kwn_tput_test_in_progress = 1;
+        vap->kwn_tput_test_from_app = 1;
+        if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 2 )
+            ieee80211_send_tput_test(vap);
+        if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 1 )
+            tasklet_schedule(&vap->kwn_tput_tq);
+    } else {
+		printk("\n Stop Test...\n");
+		vap->kwn_tput_test_start_time = 0;
+		vap->kwn_tput_test_in_progress = 0;
+        if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 2 )
+            ieee80211_send_tput_test(vap);
+		vap->kwn_tput_test_from_app = 0;
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DUR:
+	vap->kwn_tput_test_duration = value * 1000;
+	//printk(": Test Duration: %d\n",vap->kwn_tput_test_duration);
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS:
+	vap->kwn_tput_test_pkt_per_ms = value;
+	//printk(": Test PacketPerMs: %d\n",vap->kwn_tput_test_pkt_per_ms);
+	break;
 
+    case IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE:
+	vap->kwn_tput_test_pkt_size = value;
+	//printk(": Test PktSize: %d\n",vap->kwn_tput_test_pkt_size);
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DIR:
+	vap->kwn_tput_test_direction = value;
+	//printk(": Test Direction: %d\n",vap->kwn_tput_test_direction);
+	break;
+
+    case IEEE80211_PARAM_KWN_SET_PBB_B_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_pbb_bvid(eth_dev, value);
+		printk(": PBB B VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_PBB_B_ISID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_pbb_isid(eth_dev, value);
+		printk(": PBB B VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_SET_FLAG: 
+	{
+		vap->kwn_flag = value;
+		break;
+	}
+    case IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET: 
+	{
+		vap->kwn_noise_floor_offset = value;
+		break;
+	}
+    case IEEE80211_PARAM_KWN_TX_RATE: 
+    {
+        int ret1;
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ret1 = ic->ic_node_ext_stats_enable( ni, 1 );
+            printk("########### %s() : %d ret %d \n",__func__,__LINE__,ret1);
+            ieee80211_apply_txparams( vap, ni, -1, value, -1 );
+            ieee80211_free_node(ni);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_TX_PWR: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ieee80211_apply_txparams( vap, ni, -1, -1, value );
+            ieee80211_free_node(ni);
+        }
+		break;
+	}
+    case IEEE80211_PARAM_KWN_RX_RATE: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_rxrate = value;
+            ni->kwn_rxpwr = -1;
+            ieee80211_send_txparams( vap, ni );
+            ieee80211_free_node(ni);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_RX_PWR: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_rxrate = -1;
+            ni->kwn_rxpwr = value;
+            ieee80211_send_txparams( vap, ni );
+            ieee80211_free_node(ni);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SPATIAL_STREAM:
+    {
+        vap->kwn_txparam.spatial_stream = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_MIN_RATE:
+    {
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_profile_cfg.txparam.min_rate = value;
+            ieee80211_free_node(ni);
+        }
+#endif
+        vap->kwn_txparam.min_rate = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_MAX_RATE:
+    {
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_profile_cfg.txparam.max_rate = value;
+            ieee80211_free_node(ni);
+        }
+#endif
+        vap->kwn_txparam.max_rate = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_INCR_TIMER:
+    {
+        vap->kwn_txparam.inc_timer = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_DECR_TIMER:
+    {
+        vap->kwn_txparam.dec_timer = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ATPC_STATUS:
+    {
+        vap->kwn_txparam.atpc_status = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ATPC_POWER:
+    {
+        vap->kwn_txparam.power = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ANTENNA_GAIN:
+    {
+        vap->kwn_antenna_gain = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_START_SCAN:
+    {
+        struct ieee80211_channel *c;
+        u_int16_t start_freq = 0, end_freq = 0;
+        if( value == 1 ) {
+            if( ic->enable_acs || ic->enable_sa_scan ) {
+                printk(": SASCAN: ACS or SA is already in progress\n");
+                break;
+            }
+            ic->enable_sa_scan = 1;
+            memset( &ic->kwn_scan.sa_result, 0, sizeof( struct kwn_sa_scan_result ) );
+            ic->kwn_scan.scan_vap = vap;
+            for (i = 0; i < ic->ic_nchans; i++) {
+                const struct ieee80211_channel *c = &ic->ic_channels[i];
+                if( start_freq == 0 )
+                    start_freq = c->ic_freq;
+                else
+                    end_freq = c->ic_freq;
+            }
+            if( ic->kwn_scan.start_freq < start_freq || ic->kwn_scan.start_freq > end_freq )
+                ic->kwn_scan.start_freq = start_freq;
+            if( ic->kwn_scan.end_freq > end_freq || ic->kwn_scan.end_freq < start_freq )
+                ic->kwn_scan.end_freq = end_freq;
+            ic->kwn_scan.oper_freq = ic->ic_curchan->ic_freq;
+            ic->kwn_scan.scan_time = ic->kwn_scan.sa_scan_time;
+            ic->kwn_scan.start_scan = 1;
+            ic->kwn_scan.curr_freq = 0;
+            ic->kwn_scan.next_chan = 0;
+            OS_SET_TIMER(&ic->kwn_scan.scan_timer, 0);
+        }
+        else {
+            if( !ic->enable_sa_scan ) {
+                printk(": SASCAN: SA is already stopped");
+                break;
+            }
+            printk(": SASCAN: SA is stopped manually\n");
+            ic->enable_sa_scan = 0;
+            ic->kwn_scan.scan_vap = NULL;
+            ic->kwn_scan.start_scan = 0;
+            OS_CANCEL_TIMER(&ic->kwn_scan.util_timer);
+            OS_CANCEL_TIMER(&ic->kwn_scan.scan_timer);
+            printk(": SPECTRAL: Revert back to operating frequnecy %d \n",ic->kwn_scan.oper_freq);
+            c = kwn_find_channel(ic, vap, ic->kwn_scan.oper_freq );
+            ic->ic_curchan = c;
+            kwn_sa_set_channel( ic );
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_START_FREQ:
+    {
+        ic->kwn_scan.start_freq = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_END_FREQ:
+    {
+        ic->kwn_scan.end_freq = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SA_SCAN_TIME:
+    {
+        ic->kwn_scan.sa_scan_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ACS_SCAN_TIME:
+    {
+        ic->kwn_scan.acs_scan_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_UTIL_TIME:
+    {
+        ic->kwn_scan.util_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ALLOW_TAG_MGMT: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+        vap->kwn_allow_tagged_mgmt = value;
+		edma_set_allow_tagged_mgmt(eth_dev, value);
+		printk(": Allow Tagged Mgmt: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_ASSEM_FRAG:
+    {
+        vap->kwn_assem_frag = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_MAX_PKT_SIZE:
+    {
+        vap->kwn_max_pkt_size = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FRAG_PKT_SIZE:
+    {
+        vap->kwn_frag_pkt_size = value;
+        break;
+    }
     }
 
     if (retv == ENETRESET)
@@ -4018,6 +4423,7 @@
     int *txpow_frm_subtype = value;
     u_int8_t frame_subtype;
     u_int8_t frame_type;
+    struct ieee80211_node *ni;
 #if ATH_SUPPORT_DFS
     int tmp;
 #endif
@@ -5586,6 +5992,177 @@
     case IEEE80211_PARAM_DFS_INFO_NOTIFY_APP:
         *value = ic->ic_dfs_info_notify_channel_available;
         break;
+    case IEEE80211_PARAM_UPLINK_LIMIT:
+        *value = vap->kwn_ul_limit;
+        break;
+    case IEEE80211_PARAM_DOWNLINK_LIMIT:
+        *value = vap->kwn_dl_limit;
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_PKTS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_pkts(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_BYTES:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_bytes(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_PKTS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_pkts(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_BYTES:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_bytes(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST: 
+        *value = vap->kwn_tput_test_in_progress;
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DUR: 
+        *value = vap->kwn_tput_test_duration / 1000;
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DIR: 
+        *value = vap->kwn_tput_test_direction;
+        break;
+    case IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET: 
+        *value = vap->kwn_noise_floor_offset;
+        break;
+    case IEEE80211_PARAM_KWN_TX_RATE: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_txrate;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TX_PWR: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_txpwr;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_RX_RATE: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_rxrate;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_RX_PWR: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_rxpwr;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_SPATIAL_STREAM:
+        *value = vap->kwn_txparam.spatial_stream;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_MIN_RATE:
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_profile_cfg.txparam.min_rate;
+            ieee80211_free_node(ni);
+        }
+#endif
+        *value = vap->kwn_txparam.min_rate;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_MAX_RATE:
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_profile_cfg.txparam.max_rate;
+            ieee80211_free_node(ni);
+        }
+#endif
+        *value = vap->kwn_txparam.max_rate;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_INCR_TIMER:
+        *value = vap->kwn_txparam.inc_timer;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_DECR_TIMER:
+        *value = vap->kwn_txparam.dec_timer;
+        break;
+    case IEEE80211_PARAM_KWN_ATPC_STATUS:
+        *value = vap->kwn_txparam.atpc_status;
+        break;
+    case IEEE80211_PARAM_KWN_ATPC_POWER:
+        *value = vap->kwn_txparam.power;
+        break;
+    case IEEE80211_PARAM_KWN_ANTENNA_GAIN:
+        *value = vap->kwn_antenna_gain;
+        break;
+    case IEEE80211_PARAM_KWN_START_SCAN:
+        *value = ic->kwn_scan.start_scan;
+        break;
+    case IEEE80211_PARAM_KWN_START_FREQ:
+        *value = ic->kwn_scan.start_freq;
+        break;
+    case IEEE80211_PARAM_KWN_END_FREQ:
+        *value = ic->kwn_scan.end_freq;
+        break;
+    case IEEE80211_PARAM_KWN_SA_SCAN_TIME:
+        *value = ic->kwn_scan.sa_scan_time;
+        break;
+    case IEEE80211_PARAM_KWN_ACS_SCAN_TIME:
+        *value = ic->kwn_scan.acs_scan_time;
+        break;
+    case IEEE80211_PARAM_KWN_UTIL_TIME:
+        *value = ic->kwn_scan.util_time;
+        break;
+    case IEEE80211_PARAM_KWN_ASSEM_FRAG:
+        *value = vap->kwn_assem_frag;
+        break;
+    case IEEE80211_PARAM_KWN_MAX_PKT_SIZE:
+        *value = vap->kwn_max_pkt_size;
+        break;
+    case IEEE80211_PARAM_KWN_FRAG_PKT_SIZE:
+        *value = vap->kwn_frag_pkt_size;
+        break;
     }
 
     if (retv) {
@@ -6582,12 +7159,15 @@
     wlan_chan_t chan = wlan_node_get_chan(node);
     ieee80211_rate_info rinfo;
     u_int32_t jiffies_now=0, jiffies_delta=0, jiffies_assoc=0;
+    struct ieee80211_stats *iv_stats;
+    struct ieee80211com *ic = vap->iv_ic;
     /* already ignore invalid nodes in UMAC */
 
     if (chan == IEEE80211_CHAN_ANYC) { /* XXX bogus entry */
         return;
     }
 
+    iv_stats = wlan_get_stats(vap);
     len = sta_space(node, &ielen, vap);
     if (len > req->space) {
         return;
@@ -6641,7 +7221,7 @@
         si->isi_tx_rate_mcs = rinfo.mcs;
         si->isi_tx_rate_flags = rinfo.flags;
 #endif
-
+        si->isi_kwn_tx_rate_mcs = node->kwn_txrate;
     }
 
     memset(&rinfo, 0, sizeof(rinfo));
@@ -6685,7 +7265,42 @@
     si->isi_is_256qam = wlan_node_get_256qam_support(node);
     si->isi_rx_nss = wlan_node_get_rx_spatial(node);
     si->isi_tx_nss = wlan_node_get_tx_spatial(node);
-
+#if 0
+    printk("sizeof : %d,r_latitude = %s,r_longitude = %s,l_latitude = %s,l_longitude = %s\n",si->isi_len,node->ni_latitude,
+		node->ni_longitude,vap->iv_ic->ic_latitude,vap->iv_ic->ic_longitude);
+#endif
+    if ( ( strlen(node->ni_latitude) != 0 ) && ( strlen(node->ni_longitude) != 0 ) &&
+		    ( strlen(vap->iv_ic->ic_latitude) != 0 ) && ( strlen(vap->iv_ic->ic_longitude) != 0) ) {
+	    strncpy(si->isi_r_latitude,node->ni_latitude,32);
+	    strncpy(si->isi_r_longitude,node->ni_longitude,32);
+	    strncpy(si->isi_l_latitude,vap->iv_ic->ic_latitude,32);
+	    strncpy(si->isi_l_longitude,vap->iv_ic->ic_longitude,32);
+    }
+#if 0
+    printk("r_latitude = %s,r_longitude = %s,l_latitude = %s,l_longitude = %s\n",si->isi_r_latitude,si->isi_r_longitude,
+			si->isi_l_latitude,si->isi_l_longitude);
+#endif
+    si->isi_tx_tput = node->tx_tput_mbps;
+    si->isi_rx_tput = iv_stats->kwn_rx_tput_mbps;
+    si->isi_local_snr_a1 = node->kwn_snr_avg.local_snr_avg[0];
+    si->isi_local_snr_a2 = node->kwn_snr_avg.local_snr_avg[1];
+    si->isi_remote_snr_a1 = node->kwn_snr_avg.remote_snr_avg[0];
+    si->isi_remote_snr_a2 = node->kwn_snr_avg.remote_snr_avg[1];
+    si->isi_ip_addr = node->ip_addr;
+    si->isi_local_phy_err = vap->kwn_local_phy_err;
+    si->isi_remote_phy_err = node->remote_phy_err;
+    si->isi_local_mpdu_err = vap->kwn_local_mpdu_err;
+    si->isi_remote_mpdu_err = node->remote_mpdu_err;
+    si->isi_local_retries = vap->kwn_local_retries;
+    si->isi_remote_retries = node->remote_retries;
+    memcpy( si->isi_l_customer_name, ic->ic_customer_name, sizeof(ic->ic_customer_name) );
+    memcpy( si->isi_r_customer_name, node->customer_name, sizeof(node->customer_name) );
+    si->isi_l_link_id = ic->ic_link_id;
+    si->isi_r_link_id = node->link_id;
+    si->isi_l_noise_floor = vap->kwn_local_noise_floor + vap->kwn_noise_floor_offset;
+    si->isi_r_noise_floor = node->remote_noise_floor + vap->kwn_noise_floor_offset;
+    si->isi_l_ant_gain = vap->kwn_antenna_gain;
+    si->isi_r_ant_gain = node->kwn_antenna_gain;
     cp = (u_int8_t *)(si+1);
 
     if(!wlan_node_getwpaie(vap, macaddr, ni_ie, &ni_ie_len)) {
diff -urN qca-wifi-org/umac/base/ieee80211_ucfg.h qca-wifi-mod/umac/base/ieee80211_ucfg.h
--- qca-wifi-org/umac/base/ieee80211_ucfg.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_ucfg.h	2018-08-14 17:39:44.969471224 +0530
@@ -56,4 +56,5 @@
 int ieee80211_ucfg_set_otherband_bssid(wlan_if_t vap, int *val);
 int ieee80211_ucfg_send_probereq(wlan_if_t vap, int val);
 int ieee80211_ucfg_get_cap_snr(wlan_if_t vap, int *cap_snr);
+int ieee80211_send_tput_test(wlan_if_t vap);
 #endif //IEEE80211_UCFG_H_
diff -urN qca-wifi-org/umac/base/ieee80211_vap.c qca-wifi-mod/umac/base/ieee80211_vap.c
--- qca-wifi-org/umac/base/ieee80211_vap.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_vap.c	2018-11-15 11:31:21.998422448 +0530
@@ -37,6 +37,73 @@
 void acfg_clean(struct ieee80211com *ic);
 #endif
 
+/* Phani: Tx Tasklet for KWN TPUT Test */
+char kwn_tput_test_dsap[6] = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+};
+void
+ieee80211_send_kwn_tput_tx( void *data )
+{
+	struct ieee80211vap *vap = (struct ieee80211vap *)data;
+	int pkt_per_ms = vap->kwn_tput_test_pkt_per_ms;
+  	int pkt_size = vap->kwn_tput_test_pkt_size;
+	struct ether_header *eth;
+	struct net_device *dev;
+	struct kwn_tput_test_params *kparams;
+	int offset = 0;
+
+	if ( (dev = dev_get_by_name( &init_net, vap->iv_netdev_name )) == NULL )
+		return;
+
+	/* Calculate packet count per ms */
+	for ( ; pkt_per_ms > 0; --pkt_per_ms )
+	{
+		struct sk_buff *skb = NULL;
+		/* Create a packet */
+		skb = dev_alloc_skb ( pkt_size + 64 );
+		if ( skb == NULL ) {
+			return;
+		}
+		/* Fill the skb content */
+		skb_reserve( skb, 64 );
+		skb_put( skb, pkt_size );
+		skb->dev = dev;
+		eth = (struct ether_header *)skb->data;
+		IEEE80211_ADDR_COPY( eth->ether_shost, vap->iv_myaddr );
+		if ( vap->iv_opmode == IEEE80211_M_STA )
+			IEEE80211_ADDR_COPY( eth->ether_dhost, vap->iv_bss->ni_macaddr );
+		else
+			IEEE80211_ADDR_COPY( eth->ether_dhost, vap->kwn_tput_test_mac );
+		eth->ether_type = htons( skb->len - sizeof(*eth) );
+		memcpy(&skb->data[sizeof(*eth)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap));
+		if ( 1 /*vap->kwn_tput_test_from_app*/ ) {
+			offset += sizeof(*eth) + sizeof(kwn_tput_test_dsap);
+			kparams = (struct kwn_tput_test_params *)&skb->data[offset];
+			kparams->kwn_tput_test_duration = htonl(vap->kwn_tput_test_duration);
+			kparams->kwn_tput_test_pktsize = htonl(pkt_size);
+			kparams->kwn_tput_test_pktperms = htonl(pkt_per_ms);
+			kparams->kwn_tput_test_direction = htonl(vap->kwn_tput_test_direction);
+			vap->kwn_tput_test_from_app = 0;
+		}
+		skb_reset_mac_header( skb );
+		dev_queue_xmit( skb );
+	}	
+	/* Schedule Tx Tasklet when test duration is not completed */
+	if ( vap->kwn_tput_test_start_time &&
+			(( jiffies - vap->kwn_tput_test_start_time ) < vap->kwn_tput_test_duration )) {
+		tasklet_schedule( &vap->kwn_tput_tq );
+	} else {
+		vap->kwn_tput_test_in_progress = 0;
+	} 
+	dev_put( dev );	
+	return;
+}
+
+
 #if DYNAMIC_BEACON_SUPPORT
 static OS_TIMER_FUNC(ieee80211_dbeacon_suspend_beacon)
 {
@@ -502,6 +569,9 @@
         }
 #endif
 
+
+    tasklet_init(&vap->kwn_tput_tq, (void *)ieee80211_send_kwn_tput_tx, (unsigned long)vap);
+    vap->kwn_tput_test_start_time = 0;
     vap->offchan_requestor = 0;
     vap->iv_csmode = IEEE80211_CSA_MODE_AUTO; /* csmode will be calculated dynamically */
     vap->iv_enable_ecsaie = true; /* Extended channel switch ie is enabled by default */
@@ -552,7 +622,12 @@
 ieee80211_vap_detach(struct ieee80211vap *vap)
 {
     int i;
+    struct ieee80211com *ic = vap->iv_ic;
 
+    OS_FREE_TIMER(&ic->kwn_scan.scan_timer);
+    OS_FREE_TIMER(&ic->kwn_scan.util_timer);
+    /* Phani */
+    tasklet_kill(&vap->kwn_tput_tq);
     ieee80211_quiet_vdetach(vap);
     ieee80211_vap_ath_info_detach(vap->iv_vap_ath_info_handle);
     ieee80211_node_latevdetach(vap);
diff -urN qca-wifi-org/umac/include/ieee80211_channel.h qca-wifi-mod/umac/include/ieee80211_channel.h
--- qca-wifi-org/umac/include/ieee80211_channel.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_channel.h	2018-11-14 14:18:52.546497912 +0530
@@ -27,6 +27,7 @@
 u_int ieee80211_mhz2ieee(struct ieee80211com *ic, u_int freq, u_int flags);
 u_int ieee80211_ieee2mhz(struct ieee80211com *ic, u_int chan, u_int flags);
 struct ieee80211_channel *ieee80211_find_channel(struct ieee80211com *ic, int freq, u_int8_t des_cfreq2, u_int32_t flags);
+struct ieee80211_channel *kwn_find_channel(struct ieee80211com *ic, struct ieee80211vap *vap, u_int16_t freq );
 
 #if ATH_SUPPORT_PRIMARY_ALLOWED_CHAN
 int ieee80211_check_allowed_prim_chanlist(struct ieee80211com *ic,
diff -urN qca-wifi-org/umac/include/ieee80211_mlme.h qca-wifi-mod/umac/include/ieee80211_mlme.h
--- qca-wifi-org/umac/include/ieee80211_mlme.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_mlme.h	2018-07-03 10:12:53.964984596 +0530
@@ -718,6 +718,7 @@
 };
 
 int ieee80211_parse_beacon(struct ieee80211vap                  *vap,
+			   struct ieee80211_node 		*ni,
                            struct ieee80211_beacon_frame        *beacon_frame,
                            const struct ieee80211_frame         *wh,
                            u_int32_t                            beacon_frame_length,
diff -urN qca-wifi-org/umac/include/ieee80211_node.h qca-wifi-mod/umac/include/ieee80211_node.h
--- qca-wifi-org/umac/include/ieee80211_node.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_node.h	2018-11-06 14:26:39.730272712 +0530
@@ -142,6 +142,46 @@
     u_int64_t  ni_last_ack_jiffies;
 } ni_ctrl_stats_t;
 
+/* DDRS MACROS */
+#define KWN_STATS_TIMER_INT        1000
+#define KWN_SNR_TIMER_INT          200
+#define KWN_DDRS_TIMER_INT         1000
+#define KWN_DDRS_RATE_INC          1
+#define KWN_DDRS_RATE_DEC          2
+#define KWN_RATE_MIN               0
+#define KWN_11A_RATE_MAX           7
+#define KWN_11NA_RATE_MAX          15
+#define KWN_11AC_RATE_MAX          19
+#define KWN_11A_SRATE_MAX          7
+#define KWN_11NA_SRATE_MAX         7
+#define KWN_11AC_SRATE_MAX         9
+#define KWN_SNR_SAMPLES_MAX        10
+/* ATPC MACROS */
+#define KWN_ATPC_TIMER_INT         1000
+#define KWN_ATPC_POWER_MIN         0
+#define KWN_ATPC_POWER_MAX         26
+#define KWN_ATPC_UPPER_MARGIN      10
+#define KWN_ATPC_LOWER_MARGIN      10
+
+enum kwn_chainmask {
+    KWN_CHAINMASK_A1 = 1,
+    KWN_CHAINMASK_A2 = 2,
+    KWN_CHAINMASK_A1A2 = 3
+};
+
+enum kwn_spatialstream {
+    KWN_STREAM_SINGLE = 1,
+    KWN_STREAM_DUAL = 2,
+    KWN_STREAM_AUTO = 3
+};
+
+typedef struct kwn_snravg {
+    u_int8_t local_snr[ IEEE80211_MAX_ANTENNA ][ KWN_SNR_SAMPLES_MAX ];
+    u_int8_t local_snr_avg[ IEEE80211_MAX_ANTENNA ];
+    u_int8_t remote_snr_avg[ IEEE80211_MAX_ANTENNA ];
+    u_int8_t snr_indx;
+    u_int8_t sample_count;
+}kwn_snr_avg_t;
 /*
  * Node information. A node could represents a BSS in infrastructure network,
  * or an ad-hoc station in IBSS mode, or an associated station in HOSTAP mode.
@@ -585,6 +625,32 @@
     bool        is_ft_reassoc;
     ni_mgmt_stats_t ni_mgmt_stats;
     ni_ctrl_stats_t ni_ctrl_stats;
+    u_int32_t   dg_count;
+    char	ni_latitude[32];
+    char	ni_longitude[32];
+    u_int8_t    remote_snr_a1;
+    u_int8_t    remote_snr_a2;
+    uint32_t    ip_addr;
+    u_int64_t   tx_tput_mbps;
+    u_int32_t   remote_phy_err;
+    u_int32_t   remote_mpdu_err;
+    u_int32_t   remote_retries;
+    u_int8_t	customer_name[32];
+    u_int8_t	link_id;
+    int16_t	    remote_noise_floor;
+    int8_t      kwn_txrate;
+    int8_t      kwn_txpwr;
+    int8_t      kwn_rxrate;
+    int8_t      kwn_rxpwr;
+    os_timer_t  kwn_stats_timer;
+    os_timer_t  kwn_ddrs_timer;
+    os_timer_t  kwn_atpc_timer;
+    os_timer_t  kwn_snr_timer;
+    kwn_link_profile_t kwn_profile_cfg;
+    kwn_snr_avg_t kwn_snr_avg;
+    u_int32_t   kwn_ul_limit;
+    u_int32_t   kwn_dl_limit;
+    u_int8_t    kwn_antenna_gain;
 } IEEE80211_NODE, *PIEEE80211_NODE;
 
 
diff -urN qca-wifi-org/umac/include/ieee80211_scan.h qca-wifi-mod/umac/include/ieee80211_scan.h
--- qca-wifi-org/umac/include/ieee80211_scan.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_scan.h	2018-07-03 10:12:53.968984596 +0530
@@ -587,6 +587,7 @@
 
 struct ieee80211_scan_entry *
 ieee80211_scan_table_update(struct ieee80211vap          *vap,
+			    struct ieee80211_node *ni,
                             struct ieee80211_frame *wh,
                             u_int32_t                    frame_length,
                             int                          subtype, 
diff -urN qca-wifi-org/umac/include/ieee80211_vap.h qca-wifi-mod/umac/include/ieee80211_vap.h
--- qca-wifi-org/umac/include/ieee80211_vap.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_vap.h	2018-11-14 14:19:03.354499134 +0530
@@ -177,4 +177,10 @@
  *  Return ieee80211_cwm_width
  */
 enum ieee80211_cwm_width ieee80211_get_vap_max_chwidth (struct ieee80211vap *vap);
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap,u_int32_t send_ack,struct ieee80211_node *ni);
+void ieee80211_send_link_params(struct ieee80211vap *vap);
+void ieee80211_send_scan_entries(struct ieee80211vap *vap);
+void ieee80211_send_node_stats(struct ieee80211vap *vap, struct ieee80211_node *ni );
+void kwn_beacon_chanutil_update(struct ieee80211vap *vap);
+void kwn_sa_set_channel(struct ieee80211com *ic);
 #endif
diff -urN qca-wifi-org/umac/include/ieee80211_var.h qca-wifi-mod/umac/include/ieee80211_var.h
--- qca-wifi-org/umac/include/ieee80211_var.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_var.h	2018-11-15 11:31:38.258424028 +0530
@@ -605,6 +605,23 @@
 
 } chan_util_stats_t;
 
+typedef struct kwn_scan_param {
+    os_timer_t scan_timer;
+    os_timer_t util_timer;
+    wlan_if_t  scan_vap;
+    u_int16_t  oper_freq;
+    u_int16_t  start_freq;
+    u_int16_t  end_freq;
+    u_int16_t  curr_freq;
+    u_int8_t   start_scan;
+    u_int16_t  scan_time;
+    u_int16_t  sa_scan_time;
+    u_int16_t  acs_scan_time;
+    u_int16_t  util_time;
+    u_int8_t   next_chan;
+    struct kwn_sa_scan_result sa_result;
+} kwn_scan_t;
+
 typedef struct ieee80211com {
     osdev_t                       ic_osdev; /* OS opaque handle */
     qdf_device_t                  ic_qdf_dev; /* ADF opaque handle */
@@ -1574,6 +1591,8 @@
     void                                (*ic_beacon_probe_template_update)(struct ieee80211_node *ni);
     int                                 (*ic_vap_set_param)(struct ieee80211vap *vap,
                                          ieee80211_param param, u_int32_t val);
+    int                                 (*ic_kwn_vap_set_param)(struct ieee80211vap *vap,
+                                         ieee80211_param param, u_int32_t val);
     int                                 (*ic_vap_sifs_trigger)(struct ieee80211vap *vap,
                                          u_int32_t val);
     int                                 (*ic_vap_get_param)(struct ieee80211vap *vap,
@@ -1886,6 +1905,23 @@
     u_int32_t                           ic_whc_scaling_factor; /* scaling factor for WHC best uplink algorithm */
     u_int32_t                           device_id;   /* Device id from probe */
     u_int32_t                           vendor_id;   /* Vendor id from probe */
+    int                                 sta_freq;        /* setting in Mhz */
+    u_int32_t                           dying_gasp;
+    u_int32_t                           ic_str_type;
+    u_int8_t                          	ic_link_id;
+    char				ic_customer_name[32];
+    char				ic_longitude[32];
+    char				ic_latitude[32];
+    u_int32_t				ic_dg_timer_interval;
+    u_int32_t				ic_dg_ack_disable;
+    u_int32_t                           kwn_amsdu;
+    u_int16_t                           kwn_start_freq;
+    u_int16_t                           kwn_curr_freq;
+    u_int16_t                           kwn_end_freq;
+    void                                (*ic_kwn_get_ol_stats)(struct ieee80211vap *vap, struct ieee80211com *ic);
+    u_int8_t                            enable_sa_scan;
+    u_int8_t                            enable_acs;
+    kwn_scan_t                          kwn_scan;
 } IEEE80211COM, *PIEEE80211COM;
 
 #define BEST_UL_HYST_DEF        10
@@ -2283,6 +2319,9 @@
     struct ieee80211_stats            iv_stats; /* for backward compatibility */
     struct ieee80211_mac_stats        iv_unicast_stats;   /* mac statistics for unicast frames */
     struct ieee80211_mac_stats        iv_multicast_stats; /* mac statistics for multicast frames */
+#ifdef SIFY_MGMT_STATS
+	struct ieee80211_mgmt_stats       iv_mgmt_stats;
+#endif	
     struct tkip_countermeasure        iv_unicast_counterm;  /* unicast tkip countermeasure */
     struct tkip_countermeasure        iv_multicast_counterm;  /* unicast tkip countermeasure */
 
@@ -2538,6 +2577,7 @@
     u_int8_t						  iv_sko_th;        /* station kick out threshold */
 #endif /*ATH_SUPPORT_QUICK_KICKOUT*/
     struct ieee80211_chanutil_info     chanutil_info; /* Channel Utilization information */
+    struct kwn_chanutil_info           kwnchanutil_info; /* Channel Utilization information */
 #if UMAC_SUPPORT_CHANUTIL_MEASUREMENT
     u_int8_t                           iv_chanutil_enab;
 #endif /* UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
@@ -2673,6 +2713,7 @@
     void                        *iv_txrx_handle;
 #endif
     u_int8_t                   iv_vht_fixed_mcs;        /* VHT Fixed MCS Index */
+    u_int8_t                   iv_ht_fixed_mcs;         /* HT Fixed MCS Index */
     u_int8_t                   iv_nss;                  /* Spatial Stream Count */
     u_int8_t                   iv_tx_stbc;              /* TX STBC Enable:1 Disable:0 */
     u_int8_t                   iv_rx_stbc;              /* RX STBC Enable:(1,2,3) Disable:0 */
@@ -2908,8 +2949,45 @@
     bool                       iv_wps_session;
     csa_deauth_type            iv_csa_deauth_mode; /* if set, sends deauth to all stations after CSA */
     u_int8_t                   iv_filter_ssid[IEEE80211_NWID_LEN+1]; /* Filter SSID from scan results */
+    u_int32_t                  kwn_ul_limit;
+    u_int32_t                  kwn_dl_limit;
+    u_int8_t                   kwn_local_snr_a1;
+    u_int8_t                   kwn_local_snr_a2;
+    struct tasklet_struct      kwn_tput_tq;             /* Holds a hrtimer to send broadcast probe response from a vap */
+    u_int64_t                  kwn_tput_test_start_time;
+    u_int32_t                  kwn_tput_test_duration;
+    u_int32_t                  kwn_tput_test_pkt_size;
+    u_int32_t                  kwn_tput_test_pkt_per_ms;
+    char                       kwn_tput_test_mac[6];
+    u_int8_t                   kwn_tput_test_in_progress;
+    u_int8_t                   kwn_tput_test_direction;
+    u_int8_t                   kwn_tput_test_from_app;
+    u_int32_t                  kwn_local_phy_err;
+    u_int32_t                  kwn_local_mpdu_err;
+    u_int32_t                  kwn_local_retries;
+    u_int32_t                  kwn_mgmt_vlan_id;
+    char                       kwn_eth_mac_addr[6];
+    int16_t                    kwn_local_noise_floor;
+    u_int8_t                   kwn_flag;
+    u_int8_t                   kwn_noise_floor_offset;
+    char                       kwn_rate_node_mac[6];
+    struct kwn_link_txparam    kwn_txparam;
+    u_int8_t                   kwn_antenna_gain;
+    u_int8_t                   kwn_allow_tagged_mgmt;
+    u_int8_t                   kwn_assem_frag;
+    u_int16_t                  kwn_max_pkt_size;
+    u_int16_t                  kwn_frag_pkt_size;
 } IEEE80211VAP, *PIEEE80211VAP;
 
+/* KWN Flag */
+enum kwn_flag {
+    TPUT_TEST_MAC = 1,
+    PBB_DA_MAC = 2,
+    PBB_SA_MAC = 3,
+    SCAN_ENTRY_FLUSH = 4,
+    RATE_NODE_MAC = 5,
+    SA_RESULTS = 6
+};
 #if QCN_IE
 #define EFF_CHAN_TIME(_chantime, _buffer)  (((_chantime) && (_chantime > _buffer)) ? ((_chantime) - (_buffer)) : (0))
 #endif
diff -urN qca-wifi-org/umac/mlme/ieee80211_beacon.c qca-wifi-mod/umac/mlme/ieee80211_beacon.c
--- qca-wifi-org/umac/mlme/ieee80211_beacon.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_beacon.c	2018-07-03 10:12:53.968984596 +0530
@@ -594,6 +594,18 @@
         bo->bo_ibssdfs_trailerlen = 0;
     }
 #endif /* ATH_SUPPORT_IBSS_DFS */
+    /* Update latitude and longitude info if valid*/
+    if ( (strlen(ic->ic_latitude) != 0 ) && (strlen(ic->ic_longitude) != 0 ) ) {
+	    *frm++ = IEEE80211_ELEMID_RESERVED_47;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_latitude,32);
+	    frm += 32;
+	    *frm++ = IEEE80211_ELEMID_RESERVED_133;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_longitude,32);
+	    frm += 32;
+    }
+
 #if UMAC_SUPPORT_WNM
     bo->bo_fms_trailerlen = frm - bo->bo_fms_trailer;
 #endif /* UMAC_SUPPORT_WNM */
@@ -646,6 +658,7 @@
  *       that problem can be solved.
  */
     ieee80211_scan_table_update(vap,
+				NULL,
                                 (struct ieee80211_frame*)wh,
                                 frame_len,
                                 IEEE80211_FC0_SUBTYPE_BEACON,
diff -urN qca-wifi-org/umac/mlme/ieee80211_bssload.c qca-wifi-mod/umac/mlme/ieee80211_bssload.c
--- qca-wifi-org/umac/mlme/ieee80211_bssload.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_bssload.c	2018-11-14 14:19:50.902505495 +0530
@@ -68,6 +68,43 @@
 
 #endif /* UMAC_SUPPORT_BSSLOAD || UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
 
+void kwn_beacon_chanutil_update(struct ieee80211vap *vap)
+{
+    struct ieee80211com *ic = vap->iv_ic;
+    struct ieee80211_mib_cycle_cnts cnts;
+    struct kwn_chanutil_info *cu = &vap->kwnchanutil_info;
+    
+    if (cu->cycle_count == 0) {
+        /* read the cycle counts and return */
+        ic->ic_rmgetcounters(ic, &cnts);
+        cu->cycle_count = cnts.cycle_count;
+        cu->rx_clear_count = cnts.rx_clear_count;
+        return;
+    }
+    //if (cu->beacon_count == CHAN_UTIL_BEACON_INTL_DEF) 
+    {
+        /* get the counter */
+        ic->ic_rmgetcounters(ic, &cnts);
+        if ((cnts.cycle_count > cu->cycle_count) &&
+            (cnts.rx_clear_count > cu->rx_clear_count)) {
+            u_int32_t cc_d = cnts.cycle_count - cu->cycle_count;
+            u_int32_t rc_d = cnts.rx_clear_count - cu->rx_clear_count;
+            if (cc_d > (0x80000000 >> 8)) {
+                cu->value = rc_d / (cc_d >> 8);
+            }
+            else {
+                cu->value = (rc_d << 8) / cc_d;
+            }
+            //printk("############ value %u\n",cu->value);
+            cu->count++;
+            cu->total += cu->value;
+        }
+        cu->cycle_count = cnts.cycle_count;
+        cu->rx_clear_count = cnts.rx_clear_count;
+    }
+    return;
+}
+
 #if UMAC_SUPPORT_BSSLOAD
 
 /*
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_ap.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_ap.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_ap.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_ap.c	2018-07-03 10:12:53.968984596 +0530
@@ -268,6 +268,27 @@
 	case IEEE80211_ELEMID_FT:
             ftcap = frm;
             break;
+        case IEEE80211_ELEMID_RESERVED_133:
+                if ( ni != NULL ) {
+                   printk(" %s:ni->ni_longitude:%s Element id 133, longitude recieved: %s \n",__func__,ni->ni_longitude,
+                        (u_int8_t *) ((struct ieee80211_ie_gps* )frm)->hc_coordinates);
+                   printk("sta MAC addr:%02x:%02x:%02x:%02x:%02x:%02x \n",
+                        ni->ni_macaddr[0],ni->ni_macaddr[1],ni->ni_macaddr[2],
+                        ni->ni_macaddr[3],ni->ni_macaddr[4],ni->ni_macaddr[5]);
+                   strncpy(ni->ni_longitude,((struct ieee80211_ie_gps* )frm)->hc_coordinates,32);
+                }
+            break;
+        case IEEE80211_ELEMID_RESERVED_47:
+                if ( ni != NULL ) {
+                   printk(" %s:ni->ni_latitude : %s Element id 47,latitude recieved: %s \n",__func__,ni->ni_latitude,
+                                (u_int8_t *) ((struct ieee80211_ie_gps* )frm)->hc_coordinates);
+                   printk("sta MAC addr:%02x:%02x:%02x:%02x:%02x:%02x \n",
+                        ni->ni_macaddr[0],ni->ni_macaddr[1],ni->ni_macaddr[2],
+                        ni->ni_macaddr[3],ni->ni_macaddr[4],ni->ni_macaddr[5]);
+                   strncpy(ni->ni_latitude,((struct ieee80211_ie_gps* )frm)->hc_coordinates,32);
+                }
+            break;
+
 
         case IEEE80211_ELEMID_VENDOR:
             if (iswpaoui(frm)) {
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt.c qca-wifi-mod/umac/mlme/ieee80211_mgmt.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt.c	2018-11-15 11:32:56.414431287 +0530
@@ -22,10 +22,21 @@
 #include "ieee80211_wifipos_pvt.h"
 #endif
 #include "dfs_ioctl.h"
+#include <linux/inetdevice.h>
+#include <linux/rtnetlink.h>
+
 /*
  * xmit management processing code.
  */
 
+/* KWN */
+extern int edma_get_mgmt_vlan_id( struct net_device *dev );
+extern int ieee80211_get_scanentries( struct net_device *dev, struct ieee80211_action_vht_scan_entries *entries );
+
+unsigned int dg_ack_rcvd;
+unsigned int dg_seq;
+EXPORT_SYMBOL(dg_ack_rcvd);
+
 /*
  * Set the direction field and address fields of an outgoing
  * non-QoS frame.  Note this should be called early on in
@@ -597,7 +608,9 @@
     if (status == IEEE80211_STATUS_SUCCESS) {
         vap->iv_stats.mlme_auth_success++;
     }
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.aut_xmit++;
+#endif
     return ieee80211_send_mgmt(vap,ni, wbuf,false);
 }
 
@@ -692,7 +705,9 @@
         ieee80211_vap_set_complete_buf_handler(wbuf, handler, (void *)ni);
     }
 #endif
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.deaut_xmit++;
+#endif
     if (vap->iv_vap_is_down)
         return ieee80211_send_mgmt(vap, ni, wbuf, true);
     else
@@ -884,7 +899,9 @@
             frm = res;
         }
     }
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.disassoc_xmit++;
+#endif
     if (vap->iv_mesh_mgmt_txsend_config == 0)
     {
         wbuf_set_pktlen(wbuf, (frm - (u_int8_t *)wbuf_header(wbuf)));
@@ -921,6 +938,280 @@
             return 0;
     }
 }
+int get_default_ipaddr_by_devname(const char *devname)
+{
+	int addr;
+	struct net_device *dev;
+	if (!devname) return 0;
+	/* find netdev by name, increment refcnt */
+	dev=dev_get_by_name(&init_net,devname);
+	if (!dev) return 0;
+	/* get ip addr from rtable (global scope) */
+	addr = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);
+	/* decrement netdev refcnt */
+	dev_put(dev);
+	return addr;
+}
+
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap, u_int32_t send_ack, struct ieee80211_node *ack_ni)
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap) {
+            struct ieee80211_node   *ni = NULL; 
+            if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP && !send_ack) {
+                /* create temporary node for broadcast */
+                ni = ieee80211_tmp_node(vap, IEEE80211_GET_BCAST_ADDR(vap->iv_ic));
+            } else {
+		if ( send_ack ) {
+			ni = ack_ni;
+			//printk("use ack ni\n");
+		}
+		else {
+                	ni = vap->iv_bss;
+		}
+            }
+            if (ni != NULL) {
+                actionargs.category = IEEE80211_ACTION_CAT_VHT;
+                actionargs.action   = IEEE80211_ACTION_DYING_GASP;
+                actionargs.arg1     = send_ack;
+                actionargs.arg2     = 0;
+                actionargs.arg3     = 0;
+                ieee80211_send_action(ni, &actionargs, NULL);
+                if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP && !send_ack) {
+                    /* temporary node - decrement reference count so that the node will be
+                     * automatically freed upon completion */
+                    ieee80211_free_node(ni);
+                }
+            }
+    }
+}
+
+void ieee80211_send_link_params( struct ieee80211vap *vap )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		struct ieee80211_node   *ni = NULL; 
+		if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+			/* create temporary node for broadcast */
+			ni = ieee80211_tmp_node( vap, IEEE80211_GET_BCAST_ADDR( vap->iv_ic ) );
+		}
+		else {
+			ni = vap->iv_bss;
+		}
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_LINK_PARAM;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+			if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+				/* temporary node - decrement reference count so that the node will be
+				 * automatically freed upon completion */
+				ieee80211_free_node( ni );
+			}
+		}
+	}
+}
+
+void ieee80211_send_node_stats( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_NODE_STATS;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+		}
+	}
+}
+
+void ieee80211_send_tput_test( struct ieee80211vap *vap )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		struct ieee80211_node   *ni = NULL; 
+		if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+			/* create temporary node for broadcast */
+			ni = ieee80211_tmp_node( vap, IEEE80211_GET_BCAST_ADDR( vap->iv_ic ) );
+		}
+		else {
+			ni = vap->iv_bss;
+		}
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_TPUT_TEST;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+			if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+				/* temporary node - decrement reference count so that the node will be
+				 * automatically freed upon completion */
+				ieee80211_free_node( ni );
+			}
+		}
+	}
+}
+
+void ieee80211_send_scan_entries( struct ieee80211vap *vap )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        struct ieee80211_node *ni = NULL; 
+        ni = vap->iv_bss;
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_SCAN_ENTRIES;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );	
+            printk(": Link: Established, Started DDRS ATPC Timer\n");
+
+			memcpy( &ni->kwn_profile_cfg.txparam, &vap->kwn_txparam, sizeof( struct kwn_link_txparam ) );
+            OS_SET_TIMER( &ni->kwn_snr_timer, KWN_SNR_TIMER_INT );
+            OS_SET_TIMER( &ni->kwn_stats_timer, KWN_STATS_TIMER_INT );
+            OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+            OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+        }
+    }
+}
+
+void ieee80211_send_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_TX_PARAMS;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );
+        }
+    }
+}
+
+void ieee80211_apply_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni, int8_t chan, int8_t rate, int8_t pwr )
+{
+    struct rate_wmi_val {
+        int a_rate[8];
+        int na_rate[16];
+        int ac_rate[20];
+    };
+    struct rate_wmi_val rate_val = { { 3, 7, 2, 6, 1, 5, 0, 4 },
+                                     { 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151 },
+                                     { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217 } }; 
+    struct ieee80211_channel *channel;
+    struct ieee80211com *ic = vap->iv_ic;
+    int is2GHz = IEEE80211_IS_CHAN_2GHZ( ic->ic_curchan );
+
+    if( ni == NULL ) {
+        printk("%s() : %d : Node pointer is NULL \n",__func__,__LINE__);
+        return;
+    }
+    if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+        if( chan != -1 ) {
+            channel = ieee80211_find_dot11_channel( ic, chan, 0, vap->iv_des_mode | ic->ic_chanbwflag );
+            printk("############### set channel %d %d ############# \n",channel->ic_ieee,channel->ic_freq);
+            ieee80211_set_channel( ic, channel );
+        }
+        if( pwr != -1 ) {
+            ni->kwn_txpwr = pwr;
+            ic->ic_set_node_tpc( ic, ni, pwr );
+        }
+        if( rate != -1 ) {
+            switch( vap->iv_des_mode )
+            {
+                case IEEE80211_MODE_11A:
+                case IEEE80211_MODE_TURBO_A:
+                    {
+                        ni->ni_fixed_rate = rate_val.a_rate[ rate ];
+                        break;
+                    }
+                case IEEE80211_MODE_11NA_HT20:
+                case IEEE80211_MODE_11NA_HT40PLUS:
+                case IEEE80211_MODE_11NA_HT40MINUS:
+                case IEEE80211_MODE_11NA_HT40:
+                    {
+                        ni->ni_fixed_rate = rate_val.na_rate[ rate ];
+                        break;
+                    }
+                case IEEE80211_MODE_11AC_VHT20:
+                case IEEE80211_MODE_11AC_VHT40PLUS:
+                case IEEE80211_MODE_11AC_VHT40MINUS:
+                case IEEE80211_MODE_11AC_VHT40:
+                case IEEE80211_MODE_11AC_VHT80:
+                case IEEE80211_MODE_11AC_VHT160:
+                case IEEE80211_MODE_11AC_VHT80_80:
+                    {
+                        ni->ni_fixed_rate = rate_val.ac_rate[ rate ];
+                        break;
+                    }
+                default:
+                    return;
+            }
+            ni->kwn_txrate = rate;
+            ic->ic_set_sta_fixed_rate( ni );
+        }
+    }
+    else {
+        if( chan != -1 ) {
+            channel = ieee80211_find_dot11_channel( ic, chan, 0, vap->iv_des_mode | ic->ic_chanbwflag );
+            printk("############### set channel %d %d ############# \n",channel->ic_ieee,channel->ic_freq);
+            ieee80211_set_channel( ic, channel );
+        }
+        if( pwr != -1 ) {
+            ni->kwn_txpwr = pwr;
+            ic->ic_set_txPowerLimit( ic, 2 * pwr, 2 * pwr, is2GHz );
+        }
+        if( rate != -1 ) {
+            switch( vap->iv_des_mode )
+            {
+                case IEEE80211_MODE_11A:
+                case IEEE80211_MODE_TURBO_A:
+                    {
+                        ni->kwn_txrate = rate;
+                        ic->ic_kwn_vap_set_param( vap, IEEE80211_FIXED_RATE, rate_val.a_rate[ rate ] );
+                        break;
+                    }
+                case IEEE80211_MODE_11NA_HT20:
+                case IEEE80211_MODE_11NA_HT40PLUS:
+                case IEEE80211_MODE_11NA_HT40MINUS:
+                case IEEE80211_MODE_11NA_HT40:
+                    {
+                        ni->kwn_txrate = rate;
+                        ic->ic_kwn_vap_set_param( vap, IEEE80211_FIXED_RATE, rate_val.na_rate[ rate ] );
+                        break;
+                    }
+                case IEEE80211_MODE_11AC_VHT20:
+                case IEEE80211_MODE_11AC_VHT40PLUS:
+                case IEEE80211_MODE_11AC_VHT40MINUS:
+                case IEEE80211_MODE_11AC_VHT40:
+                case IEEE80211_MODE_11AC_VHT80:
+                case IEEE80211_MODE_11AC_VHT160:
+                case IEEE80211_MODE_11AC_VHT80_80:
+                    {
+                        ni->kwn_txrate = rate;
+                        ic->ic_kwn_vap_set_param( vap, IEEE80211_FIXED_VHT_MCS, rate_val.ac_rate[ rate ] );
+                        break;
+                    }
+                default:
+                    return;
+            }
+        }
+    }
+}
 
 int
 ieee80211_send_action(
@@ -1183,21 +1474,142 @@
     break;
 
     case IEEE80211_ACTION_CAT_VHT: {
-        struct ieee80211_action_vht_opmode *opmode_frame;
+        struct ieee80211_action_vht_opmode *frame_opmode;
+        struct ieee80211_action_vht_dying_gasp *frame;
+        struct ieee80211_action_vht_link_param *frame_lmt;
+        struct ieee80211_action_vht_node_stats *frame_stats;
+        struct ieee80211_action_vht_tput_test *frame_tput;
+        struct ieee80211_action_vht_scan_entries *frame_scan;
+        struct ieee80211_action_vht_tx_params *frame_txparam;
+        struct ieee80211_stats *iv_stats;
+        struct net_device *dev;
         enum ieee80211_cwm_width cw_width = ic->ic_cwm_get_width(ic);
-        IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
-                           "%s: VHT Op Mode Notify action frame. Width %d Nss = %d",
-                            __func__, cw_width, vap->iv_nss);
-        wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
-        if (wbuf == NULL) {
-            error = -ENOMEM;
-            break;
-        }
-        opmode_frame = (struct ieee80211_action_vht_opmode *)frm;
-        opmode_frame->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
-        opmode_frame->at_header.ia_action  = IEEE80211_ACTION_VHT_OPMODE;
-        ieee80211_add_opmode((u_int8_t *)&opmode_frame->at_op_mode, ni, ic, IEEE80211_ACTION_CAT_VHT);
-        frm += sizeof(struct ieee80211_action_vht_opmode);
+       
+	switch (actionargs->action) { 
+		case IEEE80211_ACTION_DYING_GASP:
+			wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
+			if (wbuf == NULL) {
+				error = -ENOMEM;
+				break;
+			}
+			frame = (struct ieee80211_action_vht_dying_gasp *)frm;
+			frame->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame->at_header.ia_action  = IEEE80211_ACTION_DYING_GASP;
+			if ( actionargs->arg1 == 0 ) {
+				frame->at_dying_gasp.type = DG_PKT_TYPE_INFORM;
+				frame->at_dying_gasp.ipv4 = get_default_ipaddr_by_devname("br-lan");
+				frame->at_dying_gasp.ts = jiffies;
+				frame->at_dying_gasp.seq_no = dg_seq++;
+				frame->at_dying_gasp.link_id = ic->ic_link_id;
+				strncpy(frame->at_dying_gasp.customer_name,ic->ic_customer_name,32);
+			}
+			else if ( actionargs->arg1 == 1 ) {
+				frame->at_dying_gasp.type = DG_PKT_TYPE_ACK;
+			}
+			frm += sizeof(struct ieee80211_action_vht_dying_gasp);
+			break;
+		case IEEE80211_ACTION_LINK_PARAM:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_lmt = ( struct ieee80211_action_vht_link_param * )frm;
+			frame_lmt->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_lmt->at_header.ia_action  = IEEE80211_ACTION_LINK_PARAM;
+			frame_lmt->at_uldl_limit.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			frame_lmt->at_uldl_limit.ul_limit = ni->kwn_ul_limit;
+			frame_lmt->at_uldl_limit.dl_limit = ni->kwn_dl_limit;
+			memcpy(frame_lmt->at_uldl_limit.customer_name,ic->ic_customer_name,sizeof(ic->ic_customer_name));
+			frame_lmt->at_uldl_limit.link_id = ic->ic_link_id;
+			frame_lmt->at_uldl_limit.antenna_gain = vap->kwn_antenna_gain;
+			frame_lmt->at_uldl_limit.kwn_assem_frag = vap->kwn_assem_frag;
+			frame_lmt->at_uldl_limit.kwn_max_pkt_size = vap->kwn_max_pkt_size;
+			frame_lmt->at_uldl_limit.kwn_frag_pkt_size = vap->kwn_frag_pkt_size;
+			frm += sizeof( struct ieee80211_action_vht_link_param );
+			break;
+		case IEEE80211_ACTION_NODE_STATS:
+			iv_stats = wlan_get_stats(vap);
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_stats = ( struct ieee80211_action_vht_node_stats * )frm;
+			frame_stats->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_stats->at_header.ia_action  = IEEE80211_ACTION_NODE_STATS;
+			frame_stats->at_node_stats.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			frame_stats->at_node_stats.snr_avg[0] = ni->kwn_snr_avg.local_snr_avg[0];
+			frame_stats->at_node_stats.snr_avg[1] = ni->kwn_snr_avg.local_snr_avg[1];
+			frame_stats->at_node_stats.noise_floor = vap->kwn_local_noise_floor;
+			frame_stats->at_node_stats.rx_tput_mbps = iv_stats->kwn_rx_tput_mbps;
+			frame_stats->at_node_stats.phy_err = vap->kwn_local_phy_err;
+			frame_stats->at_node_stats.mpdu_err = vap->kwn_local_mpdu_err;
+			frame_stats->at_node_stats.retries = vap->kwn_local_retries;
+			frm += sizeof( struct ieee80211_action_vht_node_stats );
+			break;
+		case IEEE80211_ACTION_TPUT_TEST:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_tput = ( struct ieee80211_action_vht_tput_test * )frm;
+			frame_tput->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_tput->at_header.ia_action  = IEEE80211_ACTION_TPUT_TEST;
+			frame_tput->at_tput_test.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			frame_tput->at_tput_test.start_stop = vap->kwn_tput_test_in_progress;
+			frame_tput->at_tput_test.duration = vap->kwn_tput_test_duration;
+			frame_tput->at_tput_test.pkt_size = vap->kwn_tput_test_pkt_size;
+			frame_tput->at_tput_test.cnt = vap->kwn_tput_test_pkt_per_ms;
+			frm += sizeof( struct ieee80211_action_vht_tput_test );
+			break;
+		case IEEE80211_ACTION_SCAN_ENTRIES:
+            dev = dev_get_by_name( &init_net, "ath1" );
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_scan = ( struct ieee80211_action_vht_scan_entries * )frm;
+			frame_scan->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_scan->at_header.ia_action  = IEEE80211_ACTION_SCAN_ENTRIES;
+            ieee80211_get_scanentries( dev, frame_scan );
+			frm += sizeof( struct ieee80211_action_vht_scan_entries );
+            dev_put( dev );
+			break;
+		case IEEE80211_ACTION_TX_PARAMS:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_txparam = ( struct ieee80211_action_vht_tx_params * )frm;
+			frame_txparam->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_txparam->at_header.ia_action  = IEEE80211_ACTION_TX_PARAMS;
+			frame_txparam->at_tx_param.chan = -1;
+			frame_txparam->at_tx_param.txpower = ni->kwn_rxpwr;
+			frame_txparam->at_tx_param.rate = ni->kwn_rxrate;
+			frm += sizeof( struct ieee80211_action_vht_tx_params );
+			break;
+		case IEEE80211_ACTION_VHT_OPMODE:
+			IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
+					"%s: VHT Op Mode Notify action frame. Width %d Nss = %d",
+					__func__, cw_width, vap->iv_nss);
+			wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
+			if (wbuf == NULL) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_opmode = (struct ieee80211_action_vht_opmode *)frm;
+			frame_opmode->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_opmode->at_header.ia_action  = IEEE80211_ACTION_VHT_OPMODE;
+			ieee80211_add_opmode((u_int8_t *)&frame_opmode->at_op_mode, ni, ic, IEEE80211_ACTION_CAT_VHT);
+			frm += sizeof(struct ieee80211_action_vht_opmode);	
+			break;
+		default :
+			break;
+	}
     }
     break;
 
@@ -2241,6 +2653,7 @@
 }
 int
 ieee80211_parse_beacon(struct ieee80211vap                  *vap,
+		       struct ieee80211_node *ni,
                        struct ieee80211_beacon_frame        *beacon_frame,
                        const struct ieee80211_frame         *wh,
                        u_int32_t                            beacon_frame_length,
@@ -2404,6 +2817,9 @@
             scan_entry_parameters->ie_list.htcap = (u_int8_t *) &(((struct ieee80211_ie_htcap *) info_element)->hc_ie);
             break;
         case IEEE80211_ELEMID_RESERVED_47:
+		//printk(" subtype = %d ,latitude recieved: %s\n",subtype,(u_int8_t *)((struct ieee80211_ie_gps* )info_element)->hc_coordinates);
+		if ( ni != NULL )
+		   strncpy(ni->ni_latitude,((struct ieee80211_ie_gps* )info_element)->hc_coordinates,32);
             break;
         case IEEE80211_ELEMID_RSN:
             scan_entry_parameters->ie_list.rsn = (u_int8_t *) info_element;
@@ -2435,6 +2851,9 @@
             scan_entry_parameters->ie_list.extcaps = (u_int8_t *) info_element;
             break;
         case IEEE80211_ELEMID_RESERVED_133:
+		//printk(" subtype: %d longitude recieved: %s\n",subtype,(u_int8_t *)((struct ieee80211_ie_gps* )info_element)->hc_coordinates);
+		if ( ni != NULL )
+		   strncpy(ni->ni_longitude,((struct ieee80211_ie_gps* )info_element)->hc_coordinates,32);
             break;
         case IEEE80211_ELEMID_TPC:
             break;
@@ -2864,6 +3283,7 @@
     }
 
     scan_entry = ieee80211_scan_table_update(ni->ni_vap,
+					     ni,
                                              wh,
                                              wbuf_get_pktlen(wbuf),
                                              subtype,
@@ -3825,13 +4245,150 @@
 
                     ieee80211_parse_opmode(ni, (u_int8_t *)&ia_opmode->at_op_mode, subtype);
                 }
+		action_taken = FALSE;// set to false so that it is forwarded to hostapd
                 break;
+            case IEEE80211_ACTION_DYING_GASP: 
+                {
+#define IEEE80211_EV_DYING_GASP 45
+                    struct ieee80211_action_vht_dying_gasp *frame = (struct ieee80211_action_vht_dying_gasp *)frm;
+                    struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+                    union iwreq_data wreq = {{0}};
+                    u_int32_t ip = frame->at_dying_gasp.ipv4;
+
+                    if(frame->at_dying_gasp.type == DG_PKT_TYPE_INFORM ) {
+                        if (vap->iv_opmode == IEEE80211_M_HOSTAP && !vap->iv_ic->ic_dg_ack_disable) {
+                            ieee80211_send_dying_gasp( vap , 1, ni);
+                            //printk("\n:dying gasp ack sent---> \n");
+                        }
+                        printk("(%9lu)[Remote Time stamp : %9lu][Cus name:%s][Link id:%d][%d.%d.%d.%d] Seq No:%d --> Recv pkts %d \n",
+                                jiffies,frame->at_dying_gasp.ts, frame->at_dying_gasp.customer_name,frame->at_dying_gasp.link_id,
+                                (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF,
+                                frame->at_dying_gasp.seq_no,ni->dg_count++);
+
+                        /* Send an event to apl as dying gasp packet received for logging */
+                        memset(&wreq, 0, sizeof(wreq));
+                        wreq.addr.sa_family = ARPHRD_ETHER;
+                        memcpy(wreq.addr.sa_data, ni->ni_macaddr, 6);
+                        wreq.addr.sa_data[6] = IEEE80211_EV_DYING_GASP;
+                        wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+                    }
+                    else if (frame->at_dying_gasp.type == DG_PKT_TYPE_ACK ) {
+                        dg_ack_rcvd = 1;
+                    }
+                    dev_put(dev);
+		}
+		break;
+	    case IEEE80211_ACTION_LINK_PARAM: 
+		{
+			struct ieee80211_action_vht_link_param *frame_lmt = (struct ieee80211_action_vht_link_param *)frm;
+			u_int32_t ip = frame_lmt->at_uldl_limit.ipv4;
+			/* printk("######### Received [Uplink Limit:%d][Downlink Limit:%d][%d.%d.%d.%d] ##############\n",
+					frame_lmt->at_uldl_limit.ul_limit,frame_lmt->at_uldl_limit.dl_limit,
+					(ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF); */
+			if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+				ni->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit > vap->kwn_ul_limit ? 
+					vap->kwn_ul_limit : frame_lmt->at_uldl_limit.ul_limit;
+				ni->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit > vap->kwn_dl_limit ? 
+					vap->kwn_dl_limit : frame_lmt->at_uldl_limit.dl_limit;
+				ieee80211_send_link_params( vap );
+			}
+			else {
+				ni->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit;
+				ni->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit;
+                vap->kwn_assem_frag = frame_lmt->at_uldl_limit.kwn_assem_frag;
+                vap->kwn_max_pkt_size = frame_lmt->at_uldl_limit.kwn_max_pkt_size;
+                vap->kwn_frag_pkt_size = frame_lmt->at_uldl_limit.kwn_frag_pkt_size;
+			}
+			memcpy(ni->customer_name, frame_lmt->at_uldl_limit.customer_name, sizeof(frame_lmt->at_uldl_limit.customer_name));
+			ni->link_id = frame_lmt->at_uldl_limit.link_id;
+			ni->kwn_antenna_gain = frame_lmt->at_uldl_limit.antenna_gain;
+			printk("After negotiation[%d.%d.%d.%d], Uplink Limit %d Downlink Limit %d \n",
+                (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF, 
+                vap->kwn_ul_limit,vap->kwn_dl_limit);
+		}
+		break;
+	    case IEEE80211_ACTION_NODE_STATS: 
+		{
+			struct ieee80211_action_vht_node_stats *frame_stats = (struct ieee80211_action_vht_node_stats *)frm;
+#if 0
+			u_int32_t ip = frame_stats->at_node_stats.ipv4;
+			printk("######### Received Local [SNR1:%d][SNR2:%d] Remote [SNR1:%d][SNR2:%d][%d.%d.%d.%d] ##############\n",
+					vap->local_snr_a1,vap->local_snr_a2,
+					frame_stats->at_node_stats.snr_a1,frame_stats->at_node_stats.snr_a2,
+					(ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF);
+#endif
+                        ni->kwn_snr_avg.remote_snr_avg[0] = frame_stats->at_node_stats.snr_avg[0];
+                        ni->kwn_snr_avg.remote_snr_avg[1] = frame_stats->at_node_stats.snr_avg[1];
+                        ni->remote_noise_floor = frame_stats->at_node_stats.noise_floor;
+                        ni->ip_addr = frame_stats->at_node_stats.ipv4;
+                        ni->tx_tput_mbps = frame_stats->at_node_stats.rx_tput_mbps;
+                        ni->remote_phy_err = frame_stats->at_node_stats.phy_err;
+                        ni->remote_mpdu_err = frame_stats->at_node_stats.mpdu_err;
+                        ni->remote_retries = frame_stats->at_node_stats.retries;
+		}
+		break;
+	    case IEEE80211_ACTION_TPUT_TEST: 
+		{
+            struct ieee80211_action_vht_tput_test *frame_tput = (struct ieee80211_action_vht_tput_test *)frm;
+#if 0
+            u_int32_t ip = frame_tput->at_tput_test.ipv4;
+            printk("######### Received [value:%d] [%d.%d.%d.%d] ##############\n",
+                    frame_tput->at_tput_test.start_stop,
+                    (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF);
+            printk("########Mac addrss : %s########\n",ether_sprintf(ni->ni_macaddr));
+#endif
+            if ( frame_tput->at_tput_test.start_stop ) {
+                printk("\n Start Test ...\n");
+                IEEE80211_ADDR_COPY(vap->kwn_tput_test_mac, ni->ni_macaddr);
+                vap->kwn_tput_test_duration = frame_tput->at_tput_test.duration;
+                vap->kwn_tput_test_pkt_size = frame_tput->at_tput_test.pkt_size;
+                vap->kwn_tput_test_pkt_per_ms = frame_tput->at_tput_test.cnt;
+                vap->kwn_tput_test_start_time = jiffies;
+                vap->kwn_tput_test_in_progress = 1;
+                vap->kwn_tput_test_from_app = 1;
+                tasklet_schedule(&vap->kwn_tput_tq);
+            } else {
+                printk("\n Stop Test...\n");
+                vap->kwn_tput_test_start_time = 0;
+                vap->kwn_tput_test_in_progress = 0;
+                vap->kwn_tput_test_from_app = 0;
+            }
+        }
+		break;
+	    case IEEE80211_ACTION_SCAN_ENTRIES: 
+		{
+            int i;
+			struct ieee80211_action_vht_scan_entries *frame_scan = ( struct ieee80211_action_vht_scan_entries * )frm;
+            for( i = 0; i < frame_scan->at_scan_entry.count; i++ )
+            {
+                printk(": Link: Received Scan entry Channel: %d %d RSSI:%d\n",
+                        frame_scan->at_scan_entry.entry[i].channel, frame_scan->at_scan_entry.entry[i].frequency, frame_scan->at_scan_entry.entry[i].rssi);
+            }
+            /* TODO: Channel can get changed based on best channel selection algorithm */
+            //ieee80211_apply_txparams( vap, ni, frame_scan->at_scan_entry.entry[i].channel, -1, -1 );
+            printk(": Link: Established, Started DDRS ATPC Timer\n");
+
+			memcpy( &ni->kwn_profile_cfg.txparam, &vap->kwn_txparam, sizeof( struct kwn_link_txparam ) );
+            OS_SET_TIMER( &ni->kwn_snr_timer, KWN_SNR_TIMER_INT );
+            OS_SET_TIMER( &ni->kwn_stats_timer, KWN_STATS_TIMER_INT );
+            OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+            OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+        }
+		break;
+	    case IEEE80211_ACTION_TX_PARAMS: 
+		{
+            struct ieee80211_action_vht_tx_params *frame_txparam = ( struct ieee80211_action_vht_tx_params * )frm;
+			printk(": Link: Received Tx Params Chan:%d Power:%d Rate:%d\n",
+					frame_txparam->at_tx_param.chan, frame_txparam->at_tx_param.txpower,
+                    frame_txparam->at_tx_param.rate);
+            ieee80211_apply_txparams( vap, ni, frame_txparam->at_tx_param.chan, frame_txparam->at_tx_param.rate, frame_txparam->at_tx_param.txpower );
+        }
+		break;
             default:
                 IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
                         "%s: Unhandled OR invalid VHT action code - %d", __func__, ia->ia_action);
                 break;
         }
-        action_taken = FALSE; // set to false so that it is forwarded to hostapd
         break;
     }
 
@@ -4002,6 +4559,10 @@
     switch (subtype) {
     case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
     case IEEE80211_FC0_SUBTYPE_BEACON:
+#ifdef SIFY_MGMT_STATS
+        if( subtype == IEEE80211_FC0_SUBTYPE_BEACON )
+            vap->iv_mgmt_stats.bcn_recv++;
+#endif
         ieee80211_recv_beacon(ni, wbuf, subtype, rs);
         /*store all received beacon info*/
         if(vap->iv_beacon_info_count>=100)
@@ -4092,6 +4653,9 @@
         break;
 
     case IEEE80211_FC0_SUBTYPE_AUTH:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.aut_recv++;
+#endif
 #if ATH_NON_BEACON_AP
         if(IEEE80211_VAP_IS_NON_BEACON_ENABLED(vap)){
             /*Don't response to auth for non-beaconing AP VAP*/
@@ -4107,10 +4671,34 @@
     case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
     case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:
         ieee80211_recv_asresp(ni, wbuf, subtype);
-        break;
+	/* Configure MgmtVLAN if enabled */
+	{
+
+		struct net_device *eth_dev;
+		int vlan = 0;
+		eth_dev = dev_get_by_name( &init_net, "eth0" );
+		if ( eth_dev ) {
+			vlan = edma_get_mgmt_vlan_id( eth_dev );
+			printk(": MgmtVlan: %d Vlan: %d\n", vap->kwn_mgmt_vlan_id, vlan);
+			vap->kwn_mgmt_vlan_id = vlan;
+			memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+			printk(": Eth0MAC: %0x:%0x:%0x:%0x:%0x:%0x \n",
+					vap->kwn_eth_mac_addr[0],
+					vap->kwn_eth_mac_addr[1],
+					vap->kwn_eth_mac_addr[2],
+					vap->kwn_eth_mac_addr[3],
+					vap->kwn_eth_mac_addr[4],
+					vap->kwn_eth_mac_addr[5]);
+			dev_put( eth_dev );
+		}
+	}
+	break;
 
     case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
     case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.assoc_recv++;
+#endif
 #if ATH_NON_BEACON_AP
         if(IEEE80211_VAP_IS_NON_BEACON_ENABLED(vap)){
             /*Don't response to auth for non-beaconing AP VAP*/
@@ -4158,13 +4746,40 @@
 #endif
         if (ieee80211_recv_asreq(ni, wbuf, subtype) == -EBUSY)
             forward_to_filter = 0;
-        break;
+	/* Configure MgmtVLAN if enabled */
+	{
+
+		struct net_device *eth_dev;
+		int vlan = 0;
+		eth_dev = dev_get_by_name( &init_net, "eth0" );
+		if ( eth_dev ) {
+			vlan = edma_get_mgmt_vlan_id( eth_dev );
+			printk(": MgmtVlan: %d Vlan: %d\n", vap->kwn_mgmt_vlan_id, vlan);
+			vap->kwn_mgmt_vlan_id = vlan;
+			memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+			printk(": Eth0MAC: %0x:%0x:%0x:%0x:%0x:%0x \n",
+					vap->kwn_eth_mac_addr[0],
+					vap->kwn_eth_mac_addr[1],
+					vap->kwn_eth_mac_addr[2],
+					vap->kwn_eth_mac_addr[3],
+					vap->kwn_eth_mac_addr[4],
+					vap->kwn_eth_mac_addr[5]);
+			dev_put( eth_dev );
+		}
+	}
+	break;
 
     case IEEE80211_FC0_SUBTYPE_DEAUTH:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.deaut_recv++;
+#endif
         ieee80211_recv_deauth(ni, wbuf, subtype);
         break;
 
     case IEEE80211_FC0_SUBTYPE_DISASSOC:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.disassoc_recv++;
+#endif
         ret = ieee80211_recv_disassoc(ni, wbuf, subtype);
         if(ret){
             /*Something wrong, don't fwd to filter*/
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_sta.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_sta.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_sta.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_sta.c	2018-08-22 16:31:38.123887700 +0530
@@ -1074,6 +1074,17 @@
 	frm = ieee80211_add_extender_ie(vap, IEEE80211_FRAME_TYPE_ASSOCREQ, frm);
     }
 #endif
+     /* Update latitude and longitude info if valid*/
+    if ( (strlen(ic->ic_latitude) != 0 ) && (strlen(ic->ic_longitude) != 0 ) ) {	
+	    *frm++ = IEEE80211_ELEMID_RESERVED_47;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_latitude,32);
+	    frm += 32;
+	    *frm++ = IEEE80211_ELEMID_RESERVED_133;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_longitude,32);
+	    frm += 32;
+    }
 
     return (frm - (u_int8_t *)wh);
 }
@@ -1094,6 +1105,9 @@
     if (wbuf == NULL)
         return -ENOMEM;
 
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.assoc_xmit++;
+#endif
     length = ieee80211_setup_assoc(ni, (struct ieee80211_frame *)wbuf_header(wbuf),
                                    reassoc, prev_bssid);
 
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme_ap.c qca-wifi-mod/umac/mlme/ieee80211_mlme_ap.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme_ap.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme_ap.c	2018-08-22 16:31:47.219888027 +0530
@@ -251,6 +251,17 @@
     }
 
 end:
+#ifdef SIFY_MGMT_STATS  
+    if (assocstatus != IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.assoc_reject_xmit++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.assoc_confirm_xmit++;
+    }
+    vap->iv_mgmt_stats.assoc_reason = assocstatus;
+#endif
     /* Now send the notification and remove the node if needed */
     if (reassoc) {
         IEEE80211_DELIVER_EVENT_MLME_REASSOC_INDICATION(vap, ni->ni_macaddr,
@@ -960,7 +971,17 @@
         if (indication_status != IEEE80211_STATUS_SUCCESS ){
             /* auth is not success, remove the node from node table*/
             IEEE80211_NODE_LEAVE(ni);
+#ifdef SIFY_MGMT_STATS
+            vap->iv_mgmt_stats.aut_reject_xmit++;
+#endif
         }
+#ifdef SIFY_MGMT_STATS
+        else
+        {
+            vap->iv_mgmt_stats.aut_confirm_xmit++;
+        }
+        vap->iv_mgmt_stats.auth_reason = indication_status;
+#endif
     }
 
 #if UMAC_SUPPORT_ACL
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme.c qca-wifi-mod/umac/mlme/ieee80211_mlme.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme.c	2018-10-31 18:45:33.204654529 +0530
@@ -623,6 +623,10 @@
                       __func__,ether_sprintf(ni->ni_macaddr));
     IEEE80211_ADDR_COPY(macaddr, ni->ni_macaddr);
 
+    OS_FREE_TIMER( &ni->kwn_stats_timer );
+    OS_FREE_TIMER( &ni->kwn_snr_timer );
+    OS_FREE_TIMER( &ni->kwn_ddrs_timer );
+    OS_FREE_TIMER( &ni->kwn_atpc_timer );
     associd = ni->ni_associd;
     IEEE80211_DPRINTF(vap, IEEE80211_MSG_AUTH, "%s: sending DEAUTH to %s, reason %d\n",
             __func__, ether_sprintf(ni->ni_macaddr), IEEE80211_REASON_AUTH_LEAVE);
@@ -643,6 +647,11 @@
     struct ieee80211vap    *vap = ni->ni_vap;
     u_int8_t macaddr[6];
     u_int8_t *only_rptr_clients = (u_int8_t *)arg;
+
+    OS_FREE_TIMER( &ni->kwn_stats_timer );
+    OS_FREE_TIMER( &ni->kwn_snr_timer );
+    OS_FREE_TIMER( &ni->kwn_ddrs_timer );
+    OS_FREE_TIMER( &ni->kwn_atpc_timer );
     if (only_rptr_clients && ((*only_rptr_clients) == 0x1)) {
 	if (!ni->is_extender_client) {
 	    return;
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme_sta.c qca-wifi-mod/umac/mlme/ieee80211_mlme_sta.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme_sta.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme_sta.c	2018-11-06 14:27:15.782145555 +0530
@@ -655,6 +655,18 @@
         error = mlme_process_timeout_interval_elements(ni, ie_data, ie_length);
     }
 
+#ifdef SIFY_MGMT_STATS
+    if (status_code != IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.assoc_reject_recv++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.assoc_confirm_recv++;
+    }
+    vap->iv_mgmt_stats.assoc_reason = status_code;
+#endif
+
     /* indicate linkspeed */
      mlme_get_linkrate(ni, &rxlinkspeed, &txlinkspeed);
      IEEE80211_DELIVER_EVENT_LINK_SPEED(vap, rxlinkspeed, txlinkspeed);
@@ -672,6 +684,11 @@
     default:
         break;
     }
+    /* Link is established */
+    /* Send the link param values to Base */
+    ieee80211_send_link_params( vap );
+    /* Send the scan entries values to Base */
+    ieee80211_send_scan_entries( vap );
 }
 
 /* Send association or reassociation request */
@@ -1295,6 +1312,17 @@
     }
 
     IEEE80211_DPRINTF(vap, IEEE80211_MSG_MLME, "%s: mlme_auth_complete\n", __func__);
+#ifdef SIFY_MGMT_STATS
+    if (status_code == IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.aut_confirm_recv++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.aut_reject_recv++;
+    }
+    vap->iv_mgmt_stats.auth_reason = status_code;
+#endif
 
     /* Request complete */
     mlme_priv->im_request_type = MLME_REQ_NONE;
diff -urN qca-wifi-org/umac/scan/ieee80211_scanentry.c qca-wifi-mod/umac/scan/ieee80211_scanentry.c
--- qca-wifi-org/umac/scan/ieee80211_scanentry.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/scan/ieee80211_scanentry.c	2018-07-03 10:12:53.972984595 +0530
@@ -2048,6 +2048,7 @@
 
 struct ieee80211_scan_entry *
 ieee80211_scan_table_update(struct ieee80211vap          *vap,
+			    struct ieee80211_node *ni,
                             struct ieee80211_frame *wh,
                             u_int32_t                    frame_length,
                             int                          subtype,
@@ -2070,6 +2071,7 @@
      * Parse and validate the beacon first
      */
     if (ieee80211_parse_beacon(vap,
+			       ni,
                                beacon_frame,
                                wh,
                                beacon_length,
