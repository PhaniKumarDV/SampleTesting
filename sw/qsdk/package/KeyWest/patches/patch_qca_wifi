diff -urN qca-wifi-org/cmn_dev/dp/inc/cdp_txrx_stats_struct.h qca-wifi-mod/cmn_dev/dp/inc/cdp_txrx_stats_struct.h
--- qca-wifi-org/cmn_dev/dp/inc/cdp_txrx_stats_struct.h	2018-06-08 10:23:13.000000000 +0530
+++ qca-wifi-mod/cmn_dev/dp/inc/cdp_txrx_stats_struct.h	2018-07-03 13:48:45.221216000 +0530
@@ -505,7 +505,13 @@
 	OL_ATH_PARAM_CHAN_FREE  = 366,
 	OL_ATH_PARAM_CHAN_AP_TX_UTIL = 367,
 	OL_ATH_PARAM_CHAN_OBSS_RX_UTIL  =368,
-
+	OL_ATH_PARAM_TXDISTANCE = 369,
+	OL_ATH_PARAM_DYING_GASP = 370,
+	OL_ATH_PARAM_DG_TIMER_INTERVAL = 371,
+	OL_ATH_PARAM_DG_ACK_DISABLE = 372,
+	OL_ATH_PARAM_LINKID = 373,
+	OL_ATH_PARAM_STR_TYPE = 374,
+	OL_ATH_PARAM_KWN_AMSDU = 375
 } ol_ath_param_t;
 
 /*
diff -urN qca-wifi-org/include/ieee80211_defines.h qca-wifi-mod/include/ieee80211_defines.h
--- qca-wifi-org/include/ieee80211_defines.h	2018-06-08 11:00:51.000000000 +0530
+++ qca-wifi-mod/include/ieee80211_defines.h	2018-09-04 18:44:21.900113409 +0530
@@ -14,6 +14,7 @@
 #ifndef _IEEE80211_DEFINES_H_
 #define _IEEE80211_DEFINES_H_
 
+#define SIFY_MGMT_STATS
 #include <ieee80211.h>
 #ifndef EXTERNAL_USE_ONLY
 #include <_ieee80211.h>        /* IEEE80211_ADDR_LEN, iee80211_phymode */
@@ -1913,6 +1914,32 @@
     u_int32_t   chan_tx_power_range;     /* EEPROM Tx power value for Maximum range*/
 };
 
+#ifdef SIFY_MGMT_STATS
+struct ieee80211_mgmt_stats
+{
+	u_int64_t                         bcn_recv;
+	u_int64_t                         assoc_xmit;
+	u_int64_t                         assoc_recv;
+	u_int64_t                         assoc_reject_recv;
+	u_int64_t                         assoc_reject_xmit;    
+	u_int64_t                         assoc_confirm_recv;  
+	u_int64_t                         assoc_confirm_xmit;
+	u_int64_t                         disassoc_xmit;
+	u_int64_t                         disassoc_recv;                                      
+	u_int64_t                         aut_xmit;
+	u_int64_t                         aut_recv;
+	u_int64_t                         aut_confirm_recv;
+	u_int64_t                         aut_confirm_xmit;    
+	u_int64_t                         aut_reject_recv;
+	u_int64_t                         aut_reject_xmit;        
+	u_int64_t                         deaut_xmit;
+	u_int64_t                         deaut_recv;
+	u_int64_t                         reg_fail_last_reason;
+    u_int32_t                         assoc_reason;
+	u_int32_t                         auth_reason;    
+	u_int64_t                         iv_opmode;
+};
+#endif
 struct ieee80211_mac_stats {
     u_int64_t   ims_tx_packets; /* frames successfully transmitted */
     u_int64_t   ims_rx_packets; /* frames successfully received */
@@ -2075,6 +2102,12 @@
     u_int64_t   mlme_auth_success;         /* no of 802.11 MLME Auth Success */
     u_int64_t   authorize_attempt;         /* no of Authorization Attempt */
     u_int64_t   authorize_success;         /* no of Authorization successful */
+    u_int64_t   kwn_tx_tput_mbps;
+    u_int64_t   kwn_tx_tput_last_jiffies;
+    u_int64_t   rx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+    u_int64_t   rx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+    u_int64_t   kwn_rx_tput_mbps;
+    u_int64_t   kwn_rx_tput_last_jiffies;
 };
 
 typedef enum _ieee80211_send_frame_type {
diff -urN qca-wifi-org/include/_ieee80211.h qca-wifi-mod/include/_ieee80211.h
--- qca-wifi-org/include/_ieee80211.h	2018-06-08 11:00:51.000000000 +0530
+++ qca-wifi-mod/include/_ieee80211.h	2018-07-22 10:53:49.294071269 +0530
@@ -208,8 +208,8 @@
 };
 
 #define	IEEE80211_NWID_LEN	32
-#define IEEE80211_CHAN_MAX      1023
-#define IEEE80211_CHAN_BYTES    128      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
+#define IEEE80211_CHAN_MAX      (1023*2)
+#define IEEE80211_CHAN_BYTES    (128*2)      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
 #define IEEE80211_CHAN_ANY      (-1)    /* token for ``any channel'' */
 #define IEEE80211_CHAN_ANYC \
         ((struct ieee80211_channel *) IEEE80211_CHAN_ANY)
diff -urN qca-wifi-org/include/ieee80211.h qca-wifi-mod/include/ieee80211.h
--- qca-wifi-org/include/ieee80211.h	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/include/ieee80211.h	2018-10-05 12:59:55.497103529 +0530
@@ -768,6 +768,10 @@
 #define IEEE80211_ACTION_TPC_REQUEST        2   /* Transmit Power control */
 #define IEEE80211_ACTION_TPC_REPORT         3
 #define IEEE80211_ACTION_CHAN_SWITCH        4   /* 802.11h Channel Switch Announcement */
+#define IEEE80211_ACTION_DYING_GASP         5   /*Dying Gasp*/
+#define IEEE80211_ACTION_LINK_PARAM         6   /*Link param*/
+#define IEEE80211_ACTION_NODE_STATS         7   /*Node Stats*/
+#define IEEE80211_ACTION_TPUT_TEST          8   /*Tput Test*/
 
 /* HT actions */
 #define IEEE80211_ACTION_HT_TXCHWIDTH       0   /* recommended transmission channel width */
@@ -840,6 +844,69 @@
         struct ieee80211_ie_op_mode opmode;
 } __packed;
 
+#define DG_PKT_TYPE_INFORM 1
+#define DG_PKT_TYPE_ACK	   2
+
+struct ieee80211_tput_test {
+    u_int32_t  	ipv4;
+    u_int8_t  	start_stop; 
+    u_int32_t  	duration; 
+    u_int32_t  	pkt_size; 
+    u_int32_t  	cnt; 
+} __packed;
+
+/* VHT - TPUT Test*/
+struct ieee80211_action_vht_tput_test {
+    struct ieee80211_action    at_header;
+    struct ieee80211_tput_test at_tput_test;
+} __packed;
+
+struct ieee80211_node_stats {
+    u_int32_t  	ipv4;
+    u_int8_t  	snr_a1; 
+    u_int8_t  	snr_a2; 
+    u_int64_t   rx_tput_mbps;
+    u_int32_t  	phy_err; 
+    u_int32_t  	mpdu_err; 
+    u_int32_t  	retries; 
+    int16_t  	noise_floor; 
+} __packed;
+
+/* VHT - Node Stats*/
+struct ieee80211_action_vht_node_stats {
+    struct ieee80211_action     at_header;
+    struct ieee80211_node_stats at_node_stats;
+} __packed;
+
+struct ieee80211_link_param {
+    u_int32_t  	ipv4;
+    u_int32_t  	ul_limit; 
+    u_int32_t  	dl_limit; 
+    u_int8_t	link_id;
+    u_int8_t	customer_name[32];
+} __packed;
+
+/* VHT - exchange param */
+struct ieee80211_action_vht_link_param {
+    struct ieee80211_action     at_header;
+    struct ieee80211_link_param at_uldl_limit;
+} __packed;
+
+struct ieee80211_dying_gasp_ie {
+    u_int8_t    type;
+    u_int8_t	link_id;
+    u_int16_t	seq_no;
+    u_long   	ts;
+    u_int32_t  	ipv4;
+    u_int8_t	customer_name[32];
+    
+} __packed;
+
+/* VHT - Dying gasp*/
+struct ieee80211_action_vht_dying_gasp {
+    struct ieee80211_action     at_header;
+    struct ieee80211_dying_gasp_ie at_dying_gasp;
+} __packed;
 
 /* VHT - recommended Channel width and Nss */
 struct ieee80211_action_vht_opmode {
@@ -1243,6 +1310,14 @@
 } __packed;
 
 /*
+ * GPS IE
+ */
+struct ieee80211_ie_gps {
+    u_int8_t                         hc_id;      /* element ID */
+    u_int8_t                         hc_len;     /* length in bytes */
+    u_int8_t    		     hc_coordinates[32];
+} __packed;
+/*
  * 802.11n HT Capability IE
  */
 struct ieee80211_ie_htcap {
@@ -2813,6 +2888,30 @@
         u_int8_t isi_tx_rate_mcs;
         u_int8_t isi_tx_rate_flags;
 #endif
+        u_int8_t isi_r_latitude[32];
+        u_int8_t isi_r_longitude[32];
+        u_int8_t isi_l_latitude[32];
+        u_int8_t isi_l_longitude[32];
+        u_int64_t isi_tx_tput;             /* Tx Thput */
+        u_int64_t isi_rx_tput;             /* Rx Thput */
+        u_int8_t isi_local_snr_a1;        /* Local SNR A1 */
+        u_int8_t isi_local_snr_a2;        /* Local SNR A2 */
+        u_int8_t isi_remote_snr_a1;        /* Remote SNR A1 */
+        u_int8_t isi_remote_snr_a2;        /* Remote SNR A2 */
+        u_int32_t  isi_ip_addr;
+        u_int32_t isi_local_phy_err;        /* Local Phy Err */
+        u_int32_t isi_remote_phy_err;       /* Remote Phy Err */
+        u_int32_t isi_local_mpdu_err;       /* Local MPDU Err */
+        u_int32_t isi_remote_mpdu_err;      /* Remote MPDU Err */
+        u_int32_t isi_local_retries;        /* Local Retries */
+        u_int32_t isi_remote_retries;       /* Remote Retries */
+        u_int8_t  isi_l_customer_name[32];
+        u_int8_t  isi_r_customer_name[32];
+        u_int8_t  isi_l_link_id;
+        u_int8_t  isi_r_link_id;
+        int16_t   isi_l_noise_floor;
+        int16_t   isi_r_noise_floor;
+        u_int8_t  isi_kwn_tx_rate_mcs;
 
 };
 
diff -urN qca-wifi-org/offload/os/linux/ol_ath_iw_handler.c qca-wifi-mod/offload/os/linux/ol_ath_iw_handler.c
--- qca-wifi-org/offload/os/linux/ol_ath_iw_handler.c	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/os/linux/ol_ath_iw_handler.c	2018-07-03 13:48:53.081215623 +0530
@@ -1022,6 +1022,30 @@
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "acktimeout" },
     { OL_ATH_PARAM_TXACKTIMEOUT | OL_ATH_PARAM_SHIFT,
         0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_acktimeout" },
+    { OL_ATH_PARAM_TXDISTANCE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "distance" },
+    { OL_ATH_PARAM_TXDISTANCE | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_distance" },
+    { OL_ATH_PARAM_DYING_GASP | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dying_gasp" },
+    { OL_ATH_PARAM_DYING_GASP | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dying_gasp" },
+    { OL_ATH_PARAM_DG_TIMER_INTERVAL | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dgtimeout" },
+    { OL_ATH_PARAM_DG_TIMER_INTERVAL | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dgtimeout" },
+    { OL_ATH_PARAM_DG_ACK_DISABLE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dgackdisable" },
+    { OL_ATH_PARAM_DG_ACK_DISABLE | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dgackdisable" },
+    { OL_ATH_PARAM_LINKID | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "linkid" },
+    { OL_ATH_PARAM_STR_TYPE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "str_type" },
+    { OL_ATH_PARAM_KWN_AMSDU | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "kwn_amsdu" },
+    { OL_ATH_PARAM_KWN_AMSDU | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_kwn_amsdu" },
     { OL_ATH_PARAM_BEST_UL_HYST | OL_ATH_PARAM_SHIFT,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,       "ul_hyst" },
     { OL_ATH_PARAM_BEST_UL_HYST | OL_ATH_PARAM_SHIFT,
diff -urN qca-wifi-org/offload/wlan/include/ol_if_athvar.h qca-wifi-mod/offload/wlan/include/ol_if_athvar.h
--- qca-wifi-org/offload/wlan/include/ol_if_athvar.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/include/ol_if_athvar.h	2018-09-09 17:09:51.766200231 +0530
@@ -36,6 +36,7 @@
 #include "ieee80211_wds.h"
 #include "ieee80211_ique.h"
 #include "ieee80211_acs.h"
+#include "ieee80211_acs_internal.h"
 #include "ieee80211_csa.h"
 #include "asf_amem.h"
 #include "qdf_types.h"
@@ -340,14 +341,14 @@
 #define DEFAULT_PRINT_RATE_LIMIT_VALUE 100
 
 /*
- * Default TX ACK time out value (micro second)
- */
-#define DEFAULT_TX_ACK_TIMEOUT 0x40
-
-/*
  * Max TX ACK time out value (micro second)
  */
 #define MAX_TX_ACK_TIMEOUT 0xFF
+/*
+ * Default TX ACK time out value (micro second)
+ */
+#define DEFAULT_TX_ACK_TIMEOUT 0x40
+//#define DEFAULT_TX_ACK_TIMEOUT MAX_TX_ACK_TIMEOUT
 
 struct mute_error_types {
     u_int32_t  pn_errors;
@@ -1048,6 +1049,9 @@
 void ol_ath_vap_tx_lock(void *ptr);
 void ol_ath_vap_tx_unlock(void *ptr);
 
+
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap,u_int32_t send_ack,struct ieee80211_node *ni);
+void ieee80211_send_node_stats(struct ieee80211vap *vap);
 int
 ol_transfer_target_eeprom_caldata(struct ol_ath_softc_net80211 *scn, u_int32_t address, bool compressed);
 
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath.c	2018-09-17 16:59:12.920360211 +0530
@@ -4488,7 +4488,7 @@
     param.cfreq1 = 0;
     param.cfreq2 = 0;
     if((chan_mode == IEEE80211_MODE_11AC_VHT80) ||(chan_mode == IEEE80211_MODE_11AC_VHT160) || (chan_mode == IEEE80211_MODE_11AC_VHT80_80)) {
-            if (chan->ic_ieee < 20)
+            if (chan->ic_freq < 4000)
                 param.cfreq1 = ieee80211_ieee2mhz(&scn->sc_ic,
                                                           chan->ic_vhtop_ch_freq_seg1, IEEE80211_CHAN_2GHZ);
             else
@@ -5221,7 +5221,7 @@
                 return ((freq * 10) +
                     (((freq % 5) == 2) ? 5 : 0) - 49400)/5;
             } else if (freq > 4900) {
-                return (freq - 4000) / 5;
+                return (freq - 3920) / 5;
             } else {
                 return 15 + ((freq - 2512) / 20);
             }
@@ -6743,6 +6743,37 @@
     OS_SET_TIMER(&ic->ic_inact_timer, IEEE80211_SESSION_WAIT*1000);
 }
 
+static OS_TIMER_FUNC( ol_node_stats_timer_fun )
+{
+	wlan_dev_t ic;
+	wlan_if_t vap;
+	struct ol_ath_softc_net80211 *scn ;
+	struct ol_stats *stats;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+	ic = &scn->sc_ic;
+	stats = OS_MALLOC(&scn->sc_osdev,
+			sizeof(struct ol_stats), GFP_KERNEL);
+	if (stats == NULL)
+		return;
+	TAILQ_FOREACH(vap, &ic->ic_vaps, iv_next) {
+		if (vap != NULL) {
+			ol_get_wlan_dbg_stats( scn, &stats->stats );
+			ol_get_radio_stats( scn, &stats->interface_stats );
+                        vap->kwn_local_snr_a1 = stats->interface_stats.rx_rssi_chain0.rx_rssi_pri20;
+                        vap->kwn_local_snr_a2 = stats->interface_stats.rx_rssi_chain1.rx_rssi_pri20;
+                        vap->kwn_local_noise_floor = stats->interface_stats.chan_nf;
+                        vap->kwn_local_phy_err = stats->stats.rx.phy_errs;
+                        vap->kwn_local_mpdu_err = stats->stats.rx.mpdu_errs;
+                        vap->kwn_local_retries = stats->stats.tx.mpdus_requed;
+			ieee80211_send_node_stats( vap );
+			OS_SET_TIMER(&ic->kwn_stats_timer, 2000);
+			break;
+		}
+	}
+	OS_FREE(stats);
+}
+
 static int
 ol_ath_set_mgmt_retry_limit(struct ieee80211com *ic , u_int8_t limit)
 {
@@ -8133,6 +8164,7 @@
                                                 ol_ath_esp_estimate_event_handler, WMI_RX_UMAC_CTX);
 #endif
 
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_stats_timer, ol_node_stats_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
 #if OL_ATH_SUPPORT_LED
         if (scn->target_version == AR9888_REV2_VERSION || scn->target_version == AR9887_REV1_VERSION) {
             scn->scn_led_gpio = PEREGRINE_LED_GPIO ;
@@ -8645,6 +8677,7 @@
         num_mem_chunks = scn->num_mem_chunks;
     }
 
+    OS_FREE_TIMER(&ic->kwn_stats_timer);
     if (!(scn->down_complete)) {
         for (idx=0; idx < num_mem_chunks; ++idx) {
 #if WIFI_MEM_MANAGER_SUPPORT
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath_config.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath_config.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath_config.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath_config.c	2018-07-03 13:49:28.129213945 +0530
@@ -53,6 +53,8 @@
 #endif
 void ol_ath_reset_vap_stat(struct ieee80211com *ic);
 uint32_t promisc_is_active (struct ieee80211com *ic);
+extern void (*intimate_dying_gasp)(void *arg);
+extern void dying_gasp_fn ( void * arg ) ;
 
 extern int ol_ath_target_start(struct ol_ath_softc_net80211 *scn);
 extern void ol_ath_dump_target(struct ol_ath_softc_net80211 *scn);
@@ -1839,7 +1841,67 @@
             }
             break;
 #endif /* OL_ATH_CE_DEBUG */
-        case OL_ATH_PARAM_TXACKTIMEOUT:
+	case OL_ATH_PARAM_DYING_GASP:
+            {
+                if (value < 1 || value > 2) {
+                    retval = -EINVAL;
+                }
+                ic->dying_gasp = value;
+    		/*Dying gasp initialization only when enabled */
+		if ( value == 1) {
+    			intimate_dying_gasp = dying_gasp_fn;
+			printk("%s:Dying gasp enabled---->HZ: %d \n",__func__,HZ);
+		}
+		else if ( value == 2) {
+    			intimate_dying_gasp = NULL;
+			printk("%s:Dying gasp disabled---->HZ: %d \n",__func__,HZ);
+		}
+            }
+	    break;
+        case OL_ATH_PARAM_DG_TIMER_INTERVAL:
+            {
+            	ic->ic_dg_timer_interval = value;
+            }
+            break;
+        case OL_ATH_PARAM_DG_ACK_DISABLE:
+            {
+            	ic->ic_dg_ack_disable = value;
+            }
+            break;
+        case OL_ATH_PARAM_LINKID:
+            {
+            	ic->ic_link_id = value;
+            }
+            break;
+        case OL_ATH_PARAM_STR_TYPE:
+            {
+            	ic->ic_str_type = value;
+            }
+            break;
+	case OL_ATH_PARAM_KWN_AMSDU:
+            {
+                if (value < 1 || value > 2) {
+                    retval = -EINVAL;
+                }
+                ic->kwn_amsdu = value;
+            }
+            break;
+	case OL_ATH_PARAM_TXDISTANCE: 
+	    value = value * 1000; //Distance in meters
+	    if ( value >= 0 && value < 53100 ) {
+		    u_int32_t acktimeout = (9+(value/300) + ((value % 300)?1:0));
+		    acktimeout = acktimeout * 2 + 3;
+
+		    if (acktimeout < DEFAULT_TX_ACK_TIMEOUT )
+			    acktimeout = DEFAULT_TX_ACK_TIMEOUT;
+		    else if (acktimeout > MAX_TX_ACK_TIMEOUT)
+			    acktimeout = MAX_TX_ACK_TIMEOUT;
+		    (void)ol_ath_pdev_set_param(scn,
+				    wmi_pdev_param_tx_ack_timeout, acktimeout, 0);
+		    scn->tx_ack_timeout = acktimeout;
+	    } 
+	    break;
+	case OL_ATH_PARAM_TXACKTIMEOUT:
             {
                 if ((scn->target_type == TARGET_TYPE_AR900B) || (scn->target_type == TARGET_TYPE_QCA9984) ||
                    (scn->target_type == TARGET_TYPE_QCA9888) || (scn->target_type == TARGET_TYPE_IPQ4019))
@@ -2374,6 +2436,25 @@
             }
             break;
 #endif /* OL_ATH_CE_DEBUG */
+        case OL_ATH_PARAM_DYING_GASP:
+                *(int *)buff = ic->dying_gasp;
+	    break;
+        case OL_ATH_PARAM_DG_TIMER_INTERVAL:
+            {
+            	*(int *)buff = ic->ic_dg_timer_interval;
+            }
+            break;
+        case OL_ATH_PARAM_KWN_AMSDU:
+                *(int *)buff = ic->kwn_amsdu;
+	    break;
+        case OL_ATH_PARAM_DG_ACK_DISABLE:
+            {
+            	*(int *)buff = ic->ic_dg_ack_disable ;
+            }
+            break;
+        case OL_ATH_PARAM_TXDISTANCE:
+                *(int *)buff = scn->tx_ack_timeout;
+	    break;
         case OL_ATH_PARAM_TXACKTIMEOUT:
             if ((scn->target_type == TARGET_TYPE_AR900B) || (scn->target_type == TARGET_TYPE_QCA9984) ||
                (scn->target_type == TARGET_TYPE_QCA9888) || (scn->target_type == TARGET_TYPE_IPQ4019))
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_vap.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_vap.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_vap.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_vap.c	2018-10-12 16:47:50.652232961 +0530
@@ -32,6 +32,7 @@
 #if ATH_SUPPORT_GREEN_AP
 #include "ath_green_ap.h"
 #endif
+#include <linux/inetdevice.h>
 
 #define DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS  (IEEE80211_INACT_RUN * IEEE80211_INACT_WAIT)
 #define DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_IDLE_TIME_SECS          (DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS - 5)
@@ -65,6 +66,8 @@
 #define MAX_UNRESPONSIVE_TIME_MIN_THRESHOLD_SECS  5
 #define MAX_UNRESPONSIVE_TIME_MAX_THRESHOLD_SECS  (u_int16_t)~0
 
+struct timer_list       dg_timer;
+extern int dg_ack_rcvd;
 extern int ol_ath_set_vap_dscp_tid_map(struct ieee80211vap *vap);
 extern int ol_ath_ucfg_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
 static int wlan_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid)
@@ -852,6 +855,7 @@
                     }
                     val = (preamble << 6) | (nss << 4) | rix;
                 }
+                printk("############# preamble %d nss %d rix %d val %d ############## \n",preamble,nss,rix,val);
                 retval = ol_ath_wmi_send_vdev_param(scn,avn->av_if_id,
                                               wmi_vdev_param_fixed_rate, val);
            }
@@ -860,8 +864,11 @@
            {
                 if (vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_VHT) {
                     val = (WMI_HOST_RATE_PREAMBLE_VHT << 6) | ((vap->iv_nss -1) << 4) | vap->iv_vht_fixed_mcs;
+                    ol_ath_wmi_send_vdev_param( scn, avn->av_if_id,
+                            wmi_vdev_param_nss, vap->iv_nss);
                 }
                 else {
+                    printk("\n############## VHTMCS Auto Rate Enabled ############# \n");
                     /* Note: Event though val is 32 bits, only the lower 8 bits matter */
                     val = WMI_HOST_FIXED_RATE_NONE;
                 }
@@ -3717,6 +3724,69 @@
     return 0;
 }
 
+void dying_gasp_fn ( void * arg ) {
+#define IEEE80211_EV_BASE_DYING_GASP 46
+    struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+
+    if ( dev != NULL ) {
+        osif_dev  *osdev = ath_netdev_priv(dev);
+        wlan_if_t vap = osdev->os_if;
+
+        if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP ) {
+            struct ieee80211com *ic = vap->iv_ic;
+            struct net_device *dev_br;
+            struct ieee80211_node   *ni = NULL; 
+            union iwreq_data wreq = {{0}};
+            u_int32_t ip;
+
+            ni = vap->iv_bss;
+            /* find netdev by name, increment refcnt */
+            dev_br = dev_get_by_name(&init_net,"br-lan");
+            if (!dev_br) { 
+                printk("Unable to fetch IP Address\n");
+                return;
+            }
+            /* get ip addr from rtable (global scope) */
+            ip = inet_select_addr(dev_br, 0, RT_SCOPE_UNIVERSE);
+            /* decrement netdev refcnt */
+            dev_put(dev_br);
+            /* Send an event to apl as dying gasp packet */
+            if( ni->dg_count == 0 ) 
+            {
+                memset(&wreq, 0, sizeof(wreq));
+                wreq.addr.sa_family = ARPHRD_ETHER;
+                memcpy(wreq.addr.sa_data, ni->ni_macaddr, 6);
+                wreq.addr.sa_data[6] = IEEE80211_EV_BASE_DYING_GASP;
+                wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+            }
+            printk("Outdoor Base [Time stamp : %9lu][Cus name:%s][Link id:%d][%d.%d.%d.%d] --> pkt count %d \n",
+                    jiffies, ic->ic_customer_name,ic->ic_link_id,
+                    (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF,
+                    ni->dg_count++);
+        }
+        ieee80211_send_dying_gasp( vap , 0, NULL );
+        //printk("dg_ack_rcvd : %d \n",dg_ack_rcvd);	
+        //printk("vap->iv_ic->ic_dg_timer_interval = %d,HZ = %d,jiffies = %9lu , Next jiffies = %9lu \n",vap->iv_ic->ic_dg_timer_interval,HZ,jiffies, 
+        //	jiffies+(vap->iv_ic->ic_dg_timer_interval*HZ/1000));
+        if(!dg_ack_rcvd) {
+            //printk("Reset timer\n");
+            mod_timer(&dg_timer,jiffies+(vap->iv_ic->ic_dg_timer_interval*HZ/1000));
+        }
+        else {
+            //printk("Delete timer\n");
+            del_timer(&dg_timer);
+        }
+
+        dev_put(dev);
+    }
+    return ;
+}
+
+void dying_gasp_timer ( unsigned long  arg )
+{
+	struct ol_ath_softc_net80211 *scn = ( struct ol_ath_softc_net80211 *)arg;
+	dying_gasp_fn(scn);
+}
 /* Intialization functions */
 void
 ol_ath_vap_attach(struct ieee80211com *ic)
@@ -3754,6 +3824,7 @@
         ath_green_ap_start(ic);
     }
 #endif  /* ATH_SUPPORT_GREEN_AP */
+   setup_timer(&dg_timer, dying_gasp_timer, (unsigned long)scn );
 }
 
 
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain.c qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.c
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.c	2018-07-22 10:56:39.796784660 +0530
@@ -1525,12 +1525,21 @@
     if (regdmn == OVERRIDE_RD && ol_regdmn_duplicate_channel(icv, chans, *next+1))
         return;
     icv->ic_ieee = ol_ath_mhz2ieee(ic, icv->ic_freq, icv->ic_flags);
+#if 0
     if(vht_ch_freq_seg1) {
         icv->ic_vhtop_ch_freq_seg1 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg1, icv->ic_flags);
     }
     else {
         icv->ic_vhtop_ch_freq_seg1 = 0;
     }
+#else
+    if( cm->mode == REGDMN_MODE_11AC_VHT80 ) {
+        icv->ic_vhtop_ch_freq_seg1 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg1, icv->ic_flags);
+    }
+    else {
+        icv->ic_vhtop_ch_freq_seg1 = 0;
+    }
+#endif
     if(vht_ch_freq_seg2) {
         icv->ic_vhtop_ch_freq_seg2 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg2, icv->ic_flags);
     }
@@ -1566,13 +1575,14 @@
     u_int16_t chanSep;
     ol_scn_t scn_handle;
     struct ieee80211com *ic;
-    u_int32_t ch144, ch144_eppr_ovrd;
+    //int i;
+    //u_int32_t ch144, ch144_eppr_ovrd;
 
     struct ol_ath_softc_net80211 *scn = NULL;
     scn_handle = ol_regdmn_handle->scn_handle;
     ic = &scn_handle->sc_ic;
     sec_channel_count = 0;
-    ch144_eppr_ovrd = 0;
+    //ch144_eppr_ovrd = 0;
 
     scn = OL_ATH_SOFTC_NET80211(ic);
     /*
@@ -1898,6 +1908,7 @@
         // Walk through the 5G band to find 80 Mhz channel
         else  if ((cm->mode == REGDMN_MODE_11AC_VHT80) && (rd == &rd5GHz))
         {
+#if 0
             ol_regdmn_init_vht80_chan(&vht80_chans);
 
             if (regdmn != OVERRIDE_RD) {
@@ -1925,6 +1936,10 @@
                 ol_regdmn_add_vht80_chan(&vht80_chans, 5690);
                 ol_regdmn_add_vht80_chan(&vht80_chans, 5775);
             }
+#else
+                hi_adj = -30;
+                low_adj = 30;
+#endif
         }
 
         if(rd == &rd2GHz) {
@@ -1959,6 +1974,7 @@
                     (!is_49ghz_cap) && (regdmn != OVERRIDE_RD))
                     continue;
 
+#if 0
                 if (((IS_HT40_MODE(cm->mode)) || (IS_VHT40_MODE(cm->mode))) && (rd == &rd5GHz)) {
                     /* For 5G HT40 mode, channel seperation should be 40. */
                     chanSep = 40;
@@ -1993,7 +2009,9 @@
                         }
                     }
                 }
-
+#else
+                    chanSep = fband->channelSep;
+#endif
                 for (c=fband->lowChannel + low_adj;
                      ((c <= (fband->highChannel + hi_adj)) &&
                       (c >= (fband->lowChannel + low_adj)));
@@ -2069,6 +2087,7 @@
                         QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Skipping HT40 channel (en_jap_dfs_ht40 = 0)\n");
                         continue;
                     }
+#if 0
                     if(rd == &rd5GHz)
                     {
                         /*
@@ -2125,7 +2144,7 @@
                             }
                         }
                     }
-
+#endif
                     OS_MEMZERO(&icv, sizeof(icv));
                     if(cm->mode == REGDMN_MODE_11AC_VHT80_80) {
 
@@ -2188,16 +2207,18 @@
                          * For all 4.9G, VHT80 is not allowed.
                          * Except for CTRY_DEBUG.
                          */
-                        if ((fband->lowChannel < 5180) && (cc != CTRY_DEBUG) && (regdmn != OVERRIDE_RD)) {
+                        if ((fband->lowChannel < 4920) && (cc != CTRY_DEBUG) && (regdmn != OVERRIDE_RD)) {
                             continue;
                         }
-
+#if 0
                         if(!ol_regdmn_find_vht80_chan(&vht80_chans, c, &vht_ch_freq_seg1)) {
                             if (regdmn != OVERRIDE_RD){
                                 QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, KERN_INFO"Skipping VHT80 channel %d\n", c);
                             }
                             continue;
                         }
+#endif
+                        vht_ch_freq_seg1 = c;
                         vht_ch_freq_seg2 = 0;
                         if (ol_validate_restricted_channel(scn_handle, cm, c, vht_ch_freq_seg1, vht_ch_freq_seg2)) {
                             populate_icv(&icv, c, vht_ch_freq_seg1, vht_ch_freq_seg2, fband, 0,  cm, rd, rd5GHz, dfsDomain, scn_handle, regdmn, chans, &next);
@@ -2234,6 +2255,16 @@
 
     ieee80211_set_nchannels(ic, next);
 
+    {
+	    uint32_t m;
+	    for( m = 0; m < ic->ic_nchans; m++ )
+	    {
+		    if( m == 0 )
+			    ic->kwn_start_freq = ic->ic_channels[m].ic_freq;	
+		    ic->kwn_end_freq = ic->ic_channels[m].ic_freq;	
+	    }
+	    ic->kwn_curr_freq = ic->kwn_start_freq;
+    }
     /* save for later query */
     ol_regdmn_handle->ol_regdmn_currentRDInUse = regdmn;
     ol_regdmn_handle->ol_regdmn_currentRD5G = rd5GHz.regDmnEnum;
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain_common.h qca-wifi-mod/offload/wlan/regdmn/ol_regdomain_common.h
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain_common.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain_common.h	2018-07-22 10:56:59.119119498 +0530
@@ -52,6 +52,14 @@
 	NO_ENUMRD	= 0x00,
     OVERRIDE_RD = 0x01,
 	NULL1_WORLD	= 0x03,		/* For 11b-only countries (no 11a allowed) */
+	SF_RUSSIA_49_51 = 0x04,		/* Sify custom  */
+	SF_RUSSIA_51_53 = 0x05,		/* Sify custom */
+	SF_RUSSIA_53_56 = 0x06,		/* Sify custom */
+	SF_RUSSIA_56_58 = 0x09,		/* Sify custom */
+	SF_RUSSIA_58_59 = 0x24,		/* Sify custom */
+	SF_INDIA_UL     = 0x25,		/* Sify custom */
+	SF_INDIA_L      = 0x27,		/* Sify custom */
+
 	NULL1_ETSIB	= 0x07,		/* Israel */
 	NULL1_ETSIC	= 0x08,
 	FCC1_FCCA	= 0x10,		/* USA */
@@ -216,7 +224,14 @@
 
 	NULL1		= 0x0198,
 	WORLD		= 0x0199,
-	DEBUG_REG_DMN	= 0x01ff,
+    DEBUG_REG_DMN	= 0x01ff,
+    RUSSIA01    = 0x0201,   /* Sify custom */ 
+    RUSSIA02    = 0x0202,   /* Sify custom */
+    RUSSIA03    = 0x0203,   /* Sify custom */
+    RUSSIA04    = 0x0204,   /* Sify custom */
+    RUSSIA05    = 0x0205,   /* Sify custom */
+    INDIAUL     = 0x0206,   /* Sify custom */
+    INDIAL      = 0x0207,   /* Sify custom */
     OVER1_OVERA = 0x0200,
 };
 
@@ -354,6 +369,13 @@
 	{WORA_WORLD,	WORA_WORLD,	WORA_WORLD,	DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{WORB_WORLD,	WORB_WORLD,	WORB_WORLD,	DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{WORC_WORLD,	WORC_WORLD,	WORC_WORLD,	NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+	{SF_RUSSIA_49_51,	RUSSIA01,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_51_53,	RUSSIA02,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_53_56,	RUSSIA03,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_56_58,	RUSSIA04,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_58_59,	RUSSIA05,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_INDIA_UL,	    INDIAUL,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },  /* Sify custom */
+	{SF_INDIA_L,	    INDIAL,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }  /* Sify custom */
 };
 
 /*
@@ -561,7 +583,14 @@
     {CTRY_VIRGIN_ISLANDS, FCC3_FCCA,  "VI", "VIRGIN ISLANDS", YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_WALLIS_FUTUNA, ETSI1_WORLD, "WF", "WALLIS AND FUTUNA", YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, NO, NO, 7000 },
-    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  YES,  YES, YES, YES, YES, 7000 }
+    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  YES,  YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_1, SF_RUSSIA_49_51,  "S1", "RUSSIA1",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_2, SF_RUSSIA_51_53,  "S2", "RUSSIA2",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_3, SF_RUSSIA_53_56,  "S3", "RUSSIA3",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_4, SF_RUSSIA_56_58,  "S4", "RUSSIA4",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_5, SF_RUSSIA_58_59,  "S5", "RUSSIA5",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_INDIA_UL,     SF_INDIA_UL,  "S6", "INDIA1",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_INDIA_L,      SF_INDIA_L,   "S7", "INDIA2",          YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 }
 };
 
 
@@ -705,6 +734,13 @@
 	W1_5260_5320,
 	W1_5745_5825,
 	W1_5500_5700,
+    RU_4920_5925,
+    RU_5150_5350,   /* Sify custom */
+    RU_5350_5600,   /* Sify custom */
+    RU_5600_5850,   /* Sify custom */
+    RU_5850_5925,   /* Sify custom */
+    INUL_5825_5875,   /* Sify custom */
+    INL_5725_5875,   /* Sify custom */
 	A_DEMO_ALL_CHANNELS,
     OVERRIDE_MODE_ALL_CHANNELS_5,
     OVERRIDE_MODE_ALL_CHANNELS_10,
@@ -844,6 +880,15 @@
 	{ 5260, 5320, 30, 0, 20, 20, DFS_FCC3 | DFS_ETSI, PSCAN_WWR, 0 },		/* W1_5260_5320 */
 	{ 5745, 5825, 30, 0, 20, 20, NO_DFS, PSCAN_WWR, 0 },				/* W1_5745_5825 */
 	{ 5500, 5700, 30, 0, 20, 20, DFS_FCC3 | DFS_ETSI, PSCAN_WWR, 0 },		/* W1_5500_5700 */
+
+    { 4920, 5925, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_4920_5925 custom */
+    { 5150, 5350, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5150_5350 custom */
+    { 5350, 5600, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5350_5600 custom */
+    { 5600, 5850, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5600_5850 custom */
+    { 5850, 5925, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5850_5925 custom */
+    { 5825, 5875, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* INUL_5825_5875 custom */
+    { 5725, 5875, 30, 6, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* INL_5725_5875 custom */
+
 	{ 4920, 6100, 30, 6, 20, 20, NO_DFS, NO_PSCAN, 0 },				/* A_DEMO_ALL_CHANNELS */
     { 4920, 6100, 50, 20, 20, 5,  DFS_FCC3 | DFS_ETSI | DFS_MKK4, NO_PSCAN, 0 },             /* OVERRIDE_MODE_ALL_CHANNELS_5 */
     { 4920, 6100, 50, 20, 20, 10, DFS_FCC3 | DFS_ETSI | DFS_MKK4, NO_PSCAN, 0 },             /* OVERRIDE_MODE_ALL_CHANNELS_10 */
@@ -1221,6 +1266,70 @@
      CHAN_TURBO_G_BMZERO
      },
 
+    {RUSSIA01, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_4920_5925, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA02, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5150_5350, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA03, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5350_5600, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA04, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5600_5850, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA05, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5850_5925, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIAUL, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(INUL_5825_5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIAL, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(INL_5725_5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+
 #ifndef ATH_NO_5G_SUPPORT
 	{APL1, FCC, NO_DFS, NO_PSCAN, NO_REQ,
 	 BM(F4_5745_5825, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain.h qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.h
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.h	2018-07-03 10:12:53.956984596 +0530
@@ -1063,7 +1063,14 @@
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
     CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
     CTRY_ARGENTINA2           = 5003,    /* Argentina for AP only */
-    CTRY_INDIA2               = 5006     /* India with 5.9GHz support */
+    CTRY_INDIA2               = 5006,    /* India with 5.9GHz support */
+    CTRY_RUSSIA_1             = 5011,    /* Russia 4920-5150 support */
+    CTRY_RUSSIA_2             = 5012,    /* Russia 5150-5350 support */
+    CTRY_RUSSIA_3             = 5013,    /* Russia 5350-5600 support */
+    CTRY_RUSSIA_4             = 5014,    /* Russia 5600-5850 support */
+    CTRY_RUSSIA_5             = 5015,    /* Russia 5850-5925 support */
+    CTRY_INDIA_UL             = 5016,    /* India 5825-5875 support */
+    CTRY_INDIA_L              = 5017     /* India 5725-5875 support */
 };
 
 
diff -urN qca-wifi-org/offload/wlan/umac_offload_if/ol_if_mgmt.c qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_mgmt.c
--- qca-wifi-org/offload/wlan/umac_offload_if/ol_if_mgmt.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_mgmt.c	2018-07-03 13:50:09.921211943 +0530
@@ -204,6 +204,7 @@
     if (IEEE80211_VAP_IS_SAFEMODE_ENABLED(ni->ni_vap)) {
         param.safe_mode_enabled = TRUE;
     }
+#if 0
       /* Disable AMSDU for station transmit, if user configures it */
     if ((vap->iv_opmode == IEEE80211_M_STA) && (ic->ic_sta_vap_amsdu_disable) &&
         !(ni->ni_flags & IEEE80211_NODE_VHT)) {
@@ -214,6 +215,13 @@
         (ni->ni_flags & IEEE80211_NODE_HT) && (!(IEEE80211_NODE_USE_VHT(ni))) ) {
         param.amsdu_disable = TRUE;
     }
+#endif
+    if( ic-> kwn_amsdu == 1 ) {
+        param.amsdu_disable = FALSE;
+    }
+    else {
+        param.amsdu_disable = TRUE;
+    }
     param.peer_caps = ni->ni_capinfo;
     param.peer_listen_intval = ni->ni_lintval;
     param.peer_ht_caps = ni->ni_htcap;
@@ -313,6 +321,7 @@
             param.peer_bw_rxnss_override = IEEE80211_BW_NSS_FWCONF_MAP_ENABLE;
         }
     }
+    OS_SET_TIMER(&ic->kwn_stats_timer, 2000);
     return wmi_unified_peer_assoc_send(scn->wmi_handle, &param);
 }
 
diff -urN qca-wifi-org/offload/wlan/umac_offload_if/ol_if_scan.c qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_scan.c
--- qca-wifi-org/offload/wlan/umac_offload_if/ol_if_scan.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_scan.c	2018-07-26 18:32:49.533035382 +0530
@@ -975,7 +975,7 @@
     return EINVAL;
 
 }
-
+#if 0
 static const u_int16_t default_scan_order[] = {
     /* 2.4Ghz ch: 1,6,11,7,13 */
     2412, 2437, 2462, 2442, 2472,
@@ -1007,7 +1007,36 @@
     /* Add MKK quarter-rates */
     4912, 4917, 4922, 4927, 4932, 4937, 5032, 5037, 5042, 5047, 5052, 5057,
 };
-
+#else
+static const u_int16_t default_scan_order[] = {
+    2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 
+    2462, 2467, 2472, 2477, 2482, 2487, 2492, 2497,
+    4920, 4925, 4930, 4935, 4940, 4945, 4950, 4955, 4960, 4965,
+    4970, 4975, 4980, 4985, 4990, 4995, 5000, 5005, 5010, 5015,
+    5020, 5025, 5030, 5035, 5040, 5045, 5050, 5055, 5060, 5065,
+    5070, 5075, 5080, 5085, 5090, 5095, 5100, 5105, 5110, 5115,
+    5120, 5125, 5130, 5135, 5140, 5145, 5150, 5155, 5160, 5165,
+    5170, 5175, 5180, 5185, 5190, 5195, 5200, 5205, 5210, 5215, 
+    5220, 5225, 5230, 5235, 5240, 5245, 5250, 5255, 5260, 5265, 
+    5270, 5275, 5280, 5285, 5290, 5295, 5300, 5305, 5310, 5315, 
+    5320, 5325, 5330, 5335, 5340, 5345, 5350, 5355, 5360, 5365, 
+    5370, 5375, 5380, 5385, 5390, 5395, 5400, 5405, 5410, 5415, 
+    5420, 5425, 5430, 5435, 5440, 5445, 5450, 5455, 5460, 5465, 
+    5470, 5475, 5480, 5485, 5490, 5495, 5500, 5505, 5510, 5515, 
+    5520, 5525, 5530, 5535, 5540, 5545, 5550, 5555, 5560, 5565, 
+    5570, 5575, 5580, 5585, 5590, 5595, 5600, 5605, 5610, 5615, 
+    5620, 5625, 5630, 5635, 5640, 5645, 5650, 5655, 5660, 5665, 
+    5670, 5675, 5680, 5685, 5690, 5695, 5700, 5705, 5710, 5715, 
+    5720, 5725, 5730, 5735, 5740, 5745, 5750, 5755, 5760, 5765, 
+    5770, 5775, 5780, 5785, 5790, 5795, 5800, 5805, 5810, 5815, 
+    5820, 5825, 5830, 5835, 5840, 5845, 5850, 5855, 5860, 5865, 
+    5870, 5875, 5880, 5885, 5890, 5895, 5900, 5905, 5910, 5915, 
+    5920, 5925, 5930, 5935, 5940, 5945, 5950, 5955, 5960, 5965, 
+    5970, 5975, 5980, 5985, 5990, 5995, 6000, 6005, 6010, 6015, 
+    6020, 6025, 6030, 6035, 6040, 6045, 6050, 6055, 6060, 6065, 
+    6070, 6075, 6080, 6085, 6090, 6095, 6100
+};
+#endif
 /*
  * get all the channels to scan .
  * can be called whenever the set of supported channels are changed.
@@ -1021,8 +1050,10 @@
     struct ol_ath_softc_net80211 *scn = OL_ATH_SOFTC_NET80211(ic);
     u_int16_t *scan_order = (u_int16_t *)default_scan_order;
     u_int32_t scan_order_size = IEEE80211_N(default_scan_order);
-    int i = 0;
+    int i = 0, j =0;
+    int fixed_chan;
     struct scan_chan_list_params *param;
+    struct ieee80211_acs *acs = ic->ic_acs;
 
     param = (struct scan_chan_list_params *)
         kmalloc((sizeof(struct scan_chan_list_params) +
@@ -1035,6 +1066,30 @@
 
     ss->ss_nallchans = 0;
     ss->ss_nchans = 0;
+    /* Fixed channel support in client mode */
+    if( ic->sta_freq > 0 ) {
+       scan_order_size = 1;
+       fixed_chan = ic->sta_freq;
+    }
+    else {
+        /* In case of ACS, Sending 40 channels for scanning to firmware in one iteration */
+        for( i=ic->kwn_curr_freq; i<=ic->kwn_end_freq; i+=5 ) {
+            if( j > 40 )
+                break;
+            scan_order[j] = i;
+            acs->acs_ieee_chan[j] = ieee80211_mhz2ieee(ic, i, 0);
+            j++;
+        }
+        acs->acs_nchans_scan = j;
+	    scan_order_size = j;
+            /* Moving current freq to next iteration first freq,
+	       if current freq > end freq, move current freq to start freq */
+	    ic->kwn_curr_freq = scan_order[j-1] + 5;
+	    if( ic->kwn_curr_freq > ic->kwn_end_freq )
+		ic->kwn_curr_freq = ic->kwn_start_freq;
+            /* If scan order size is 1, updating fixed channel as this parameter is used for scanning below */
+		fixed_chan = scan_order[0];
+    }
 
     if (ic->ic_custom_scan_order_size > 0) {
         QDF_PRINT_INFO(QDF_PRINT_IDX_SHARED, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Using custom scan order\n"),
@@ -1045,7 +1100,12 @@
     spin_lock(&ss->ss_lock);
 
     for (i = 0; i < scan_order_size; ++i) {
-        c = ol_ath_find_full_channel(ic,scan_order[i]);
+        if( scan_order_size == 1 ) {
+            c = ol_ath_find_full_channel(ic,fixed_chan);
+        }
+        else {
+            c = ol_ath_find_full_channel(ic,scan_order[i]);
+        }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1060,12 +1120,18 @@
     /* Iterate again adding half-rate and quarter-rate channels */
     for (i = 0; i < scan_order_size; ++i) {
 
-        if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD)
+        if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD && scan_order_size != 1)
             continue;
 
         c = NULL;
-        c = ieee80211_find_channel(ic, scan_order[i], 0,
-                                   (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        if( scan_order_size == 1 ) {
+            c = ieee80211_find_channel(ic, fixed_chan, 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        }
+        else {
+            c = ieee80211_find_channel(ic, scan_order[i], 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        }
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
 #else
@@ -1075,8 +1141,14 @@
         }
 
         c = NULL;
-        c = ieee80211_find_channel(ic, scan_order[i], 0,
-                                   (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        if( scan_order_size == 1 ) {
+            c = ieee80211_find_channel(ic, fixed_chan, 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        }
+        else {
+            c = ieee80211_find_channel(ic, scan_order[i], 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1087,16 +1159,21 @@
         }
     }
 
-    if (ss->ss_flags & IEEE80211_SCAN_80MHZ) {
+    if (ss->ss_flags & IEEE80211_SCAN_80MHZ) 
+    {
         /* Iterate again adding VHT40 & VHT80 channels */
         for (i = 0,c = NULL; i < scan_order_size; ++i) {
-
-            if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD)
+            if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD && scan_order_size != 1)
                 continue;
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT40PLUS)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                }
             }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
@@ -1109,7 +1186,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT80)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT80);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80);
+                }
             }
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
             if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1121,7 +1203,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT160)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT160);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT160);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT160);
+                }
             }
             if (c != NULL) {
                 ss->ss_all_chans[ss->ss_nallchans++] = c;
@@ -1129,7 +1216,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT80_80)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80_80);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT80_80);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80_80);
+                }
             }
             if (c != NULL) {
                 ss->ss_all_chans[ss->ss_nallchans++] = c;
diff -urN qca-wifi-org/os/linux/include/ieee80211_ioctl.h qca-wifi-mod/os/linux/include/ieee80211_ioctl.h
--- qca-wifi-org/os/linux/include/ieee80211_ioctl.h	2018-06-08 11:00:42.000000000 +0530
+++ qca-wifi-mod/os/linux/include/ieee80211_ioctl.h	2018-10-14 23:27:52.498790670 +0530
@@ -1530,6 +1530,32 @@
     IEEE80211_PARAM_TIMEOUTIE                  = 550,   /* set/get assoc comeback timeout value */
     IEEE80211_PARAM_PMF_ASSOC                  = 551,   /* enable/disable pmf support */
     IEEE80211_PARAM_DFS_INFO_NOTIFY_APP        = 552,   /* Enable the feature to notify dfs info to app */
+    IEEE80211_PARAM_UPLINK_LIMIT               = 553,   /* Uplink Limit */
+    IEEE80211_PARAM_DOWNLINK_LIMIT             = 554,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST              = 555,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_DUR          = 556,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS   = 557,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE     = 558,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_DIR          = 559,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_VLAN_MODE              = 560,   /* Vlan Mode */
+    IEEE80211_PARAM_KWN_VID_ADD                = 561,   /* Vlan Add */
+    IEEE80211_PARAM_KWN_VID_DEL                = 562,   /* Vlan Del */
+    IEEE80211_PARAM_KWN_ALLOW_UNTAGGED         = 563,   /* Allow UnTagged */
+    IEEE80211_PARAM_KWN_SET_ACCESS_VLANID      = 564,   /* Access VlanID */
+    IEEE80211_PARAM_KWN_SET_NATIVE_VLANID      = 565,   /* Native VlanID */
+    IEEE80211_PARAM_KWN_SET_MGMT_VLANID        = 566,   /* Mgmt VlanID */
+    IEEE80211_PARAM_KWN_ETH_TX_PKTS            = 567,   /* Eth Tx Pkts */
+    IEEE80211_PARAM_KWN_ETH_TX_BYTES           = 568,   /* Eth Tx Bytes */
+    IEEE80211_PARAM_KWN_ETH_TX_ERRORS          = 569,   /* Eth Tx Errors */
+    IEEE80211_PARAM_KWN_ETH_RX_PKTS            = 570,   /* Eth Rx Pkts */
+    IEEE80211_PARAM_KWN_ETH_RX_BYTES           = 571,   /* Eth Rx Bytes */
+    IEEE80211_PARAM_KWN_ETH_RX_ERRORS          = 572,   /* Eth Rx Errors */
+    IEEE80211_PARAM_KWN_SET_SVLAN_ID           = 573,   /* SVLAN ID */
+    IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE    = 574,   /* SVLAN EtherType */
+    IEEE80211_PARAM_KWN_SET_PBB_B_VLANID       = 575,   /* PBB B-VLANID */
+    IEEE80211_PARAM_KWN_SET_PBB_B_ISID 	       = 576,	/* PBB B-ISID */
+    IEEE80211_PARAM_KWN_SET_PBB_B_MAC_FLAG     = 577,	/* PBB B-MAC Flag */
+    IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET     = 578	/* Noise Floor Offset */
 };
 #define WOW_CUSTOM_PKT_LEN 102
 #define WOW_SYNC_PATTERN 0xFF
diff -urN qca-wifi-org/os/linux/src/ieee80211_wireless.c qca-wifi-mod/os/linux/src/ieee80211_wireless.c
--- qca-wifi-org/os/linux/src/ieee80211_wireless.c	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/src/ieee80211_wireless.c	2018-10-14 23:28:08.502696730 +0530
@@ -106,6 +106,10 @@
 int ieee80211_authorise_local_peer(wlan_if_t vap, char *params);
 #endif
 
+/* KWN: PBB: B_DA_MAC & B_SA_MAC */
+extern int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac );
+extern int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac );
+
 #if 0
 /*
  * Common folder is coming from qca_main and
@@ -524,6 +528,7 @@
 {
     osif_dev *osnetdev = ath_netdev_priv(dev);
     wlan_if_t vap = osnetdev->os_if;
+    struct ieee80211com *ic = vap->iv_ic;
     int i;
 
     debug_print_ioctl(dev->name, SIOCSIWFREQ, "siwfreq") ;
@@ -534,6 +539,11 @@
     /*
     * Necessary to cast, to properly interpret negative channel numbers
     */
+    /* To enable fixed channel on Client mode, writing -1 to station freq in case of acs enabled */
+    ic->sta_freq = 0;
+    if( freq->m == 0 )
+      ic->sta_freq = -1;
+
     if (freq->e == 1)
         i = (u_int8_t)wlan_mhz2ieee(osnetdev->os_devhandle, freq->m / 100000, 0);
     else
@@ -600,6 +610,40 @@
 }
 
 static int
+ieee80211_ioctl_siwnickname(struct net_device *dev,
+    struct iw_request_info *info,
+    struct iw_point *data, char *ssid)
+{
+#define CUSTOMER_NAME 1
+#define LONGITUDE     2
+#define LATITUDE      3
+    osif_dev *osifp = ath_netdev_priv(dev);
+    wlan_if_t vap = osifp->os_if; 
+
+    if (data->length > IEEE80211_NWID_LEN)
+	    data->length = IEEE80211_NWID_LEN;
+    if ( vap->iv_ic->ic_str_type == CUSTOMER_NAME ) {
+	    OS_MEMZERO(vap->iv_ic->ic_customer_name, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_customer_name, ssid, data->length);
+	    printk("Cusname: %s \n",vap->iv_ic->ic_customer_name);
+    }
+    else if ( vap->iv_ic->ic_str_type == LONGITUDE ) {
+	    OS_MEMZERO(vap->iv_ic->ic_longitude, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_longitude, ssid, data->length);
+	    printk("langitude: %s \n",vap->iv_ic->ic_longitude);
+	    vap->appie_buf_updated = 1;
+    }
+    else if ( vap->iv_ic->ic_str_type == LATITUDE ) {
+	    OS_MEMZERO(vap->iv_ic->ic_latitude, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_latitude, ssid, data->length);
+	    printk("latitude: %s \n",vap->iv_ic->ic_latitude);
+	    vap->appie_buf_updated = 1;
+    }
+    vap->iv_ic->ic_str_type = 0;
+    return 0;
+}
+
+static int
 ieee80211_ioctl_giwessid(struct net_device *dev,
     struct iw_request_info *info,
     struct iw_point *data, char *essid)
@@ -1148,6 +1192,7 @@
     wlan_if_t vap;
     struct sockaddr addr[IW_MAX_AP];
     struct iw_quality qual[IW_MAX_AP];
+    struct iw_ssid ssid[IW_MAX_AP];
     int i;
 };
 
@@ -1161,6 +1206,8 @@
     u_int8_t *se_macaddr = wlan_scan_entry_macaddr(se);
     u_int8_t *se_bssid = wlan_scan_entry_bssid(se);
     u_int8_t se_rssi = wlan_scan_entry_rssi(se);
+    u_int8_t se_ssid_len;
+    u_int8_t *se_ssid = wlan_scan_entry_ssid(se, &se_ssid_len);
 
     if (i >= IW_MAX_AP)
         return 0;
@@ -1171,6 +1218,7 @@
         IEEE80211_ADDR_COPY(req->addr[i].sa_data, se_bssid);
 
     set_quality(&req->qual[i], se_rssi);
+    memcpy( req->ssid[i].essid, se_ssid, se_ssid_len);
 
     req->i = i+1;
 
@@ -1199,6 +1247,8 @@
     data->flags = 1;        /* signal quality present (sort of) */
     OS_MEMCPY(extra + req->i*sizeof(req->addr[0]), &req->qual,
         req->i*sizeof(req->qual[0]));
+    OS_MEMCPY(extra + (req->i*sizeof(req->addr[0] )) + ( req->i * sizeof(req->qual[0] ) ), &req->ssid,
+        req->i*sizeof(req->ssid[0]));
     OS_FREE(req);
 
     return 0;
@@ -10115,6 +10165,31 @@
 
     debug_print_ioctl(dev->name, IEEE80211_IOCTL_ADDMAC, "addmac") ;
 
+    if ( vap->kwn_tput_test_duration != 0 ) {
+	    int i = 0;
+	    IEEE80211_ADDR_COPY(vap->kwn_tput_test_mac, sa->sa_data);
+	    printk("\n TPUT Test MAC: ");
+	    for(i = 0; i < 6; i++)
+		    printk(": %x",vap->kwn_tput_test_mac[i]);
+	    printk("\n");
+	    return 0;
+    }
+
+    /* This ioctl used for configuring the PBB B-DA/B-SA mac address 
+	to be configured in edma driver */
+    if ( vap->kwn_pbb_add_mac_flag > 0 ) {
+	    struct net_device *eth_dev;
+	    eth_dev = dev_get_by_name(&init_net, "eth0");
+	    if ( eth_dev ) {
+		    if ( vap->kwn_pbb_add_mac_flag == 1 ) {
+			    edma_set_pbb_da_mac( eth_dev, sa->sa_data );
+		    } else {
+			    edma_set_pbb_sa_mac( eth_dev, sa->sa_data );
+		    }
+		    dev_put(eth_dev);
+	    }
+	    return 0;
+    }
     rc = wlan_set_acl_add(vap, sa->sa_data, IEEE80211_ACL_FLAG_ACL_LIST_1);
     return rc;
 }
@@ -14947,6 +15022,75 @@
     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dfs_notify" },
     { IEEE80211_PARAM_DFS_INFO_NOTIFY_APP,
     0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_dfs_notify" },
+    { IEEE80211_PARAM_UPLINK_LIMIT,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "ul_limit" },
+    { IEEE80211_PARAM_UPLINK_LIMIT,
+    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_ul_limit" },
+    { IEEE80211_PARAM_DOWNLINK_LIMIT,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dl_limit" },
+    { IEEE80211_PARAM_DOWNLINK_LIMIT,
+    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_dl_limit" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_test" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_test" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DUR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_dur" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DUR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_dur" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_cnt" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_cnt" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_size" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_size" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DIR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_dir" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DIR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_dir" },
+    { IEEE80211_PARAM_KWN_VLAN_MODE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vlan_mode" },
+    { IEEE80211_PARAM_KWN_VID_ADD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vid_add" },
+    { IEEE80211_PARAM_KWN_VID_DEL,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vid_del" },
+    { IEEE80211_PARAM_KWN_ALLOW_UNTAGGED,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_allowuntag" },
+    { IEEE80211_PARAM_KWN_SET_ACCESS_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_acc_vid" },
+    { IEEE80211_PARAM_KWN_SET_NATIVE_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_nat_vid" },
+    { IEEE80211_PARAM_KWN_SET_MGMT_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_mgmt_vid" },
+    { IEEE80211_PARAM_KWN_SET_SVLAN_ID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_svlan_id" },
+    { IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_setherType" },
+    { IEEE80211_PARAM_KWN_ETH_TX_PKTS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxpkt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_BYTES,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxbyt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_ERRORS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxerr" },
+    { IEEE80211_PARAM_KWN_ETH_RX_PKTS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxpkt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_BYTES,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxbyt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_ERRORS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxerr" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_bvid" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_ISID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_bisid" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_MAC_FLAG,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_flag" },
+    { IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnnoiseoff" },
+    { IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnnoiseoff" }
+
 };
 
 static const iw_handler ieee80211_handlers[] = {
@@ -14992,7 +15136,7 @@
 #endif /* SIOCGIWSCAN */
     (iw_handler) ieee80211_ioctl_siwessid,      /* SIOCSIWESSID */
     (iw_handler) ieee80211_ioctl_giwessid,      /* SIOCGIWESSID */
-    (iw_handler) NULL,      /* SIOCSIWNICKN */
+    (iw_handler) ieee80211_ioctl_siwnickname,      /* SIOCSIWNICKN */
     (iw_handler) NULL,      /* SIOCGIWNICKN */
     (iw_handler) NULL,              /* -- hole -- */
     (iw_handler) NULL,              /* -- hole -- */
@@ -15309,11 +15453,26 @@
     {
 
     case SIOCG80211STATS:
-        return _copy_to_user(ifr->ifr_data, &vap->iv_stats,
-            sizeof (vap->iv_stats) +
-            sizeof(vap->iv_unicast_stats) +
-            sizeof(vap->iv_multicast_stats)) ? -EFAULT : 0;
-
+        if (*((char*)ifr->ifr_data))
+        {
+            memset (&(vap->iv_stats), 0x00, sizeof(struct ieee80211_stats));
+            memset (&(vap->iv_unicast_stats), 0x00, sizeof(struct ieee80211_mac_stats));
+            memset (&(vap->iv_multicast_stats), 0x00, sizeof(struct ieee80211_mac_stats));
+            memset (&(vap->iv_mgmt_stats), 0x00, sizeof(struct ieee80211_mgmt_stats));
+            return 0;
+        }
+        else
+        {
+            vap->iv_mgmt_stats.iv_opmode = vap->iv_opmode;
+            return _copy_to_user(ifr->ifr_data, &vap->iv_stats,
+                    sizeof (vap->iv_stats) +
+                    sizeof(vap->iv_unicast_stats) +
+                    sizeof(vap->iv_multicast_stats)
+#ifdef SIFY_MGMT_STATS                               
+                    + sizeof (vap->iv_mgmt_stats)
+#endif
+                    ) ? -EFAULT : 0;
+        }
     case SIOC80211IFDESTROY:
         if (!capable(CAP_NET_ADMIN))
             return -EPERM;
diff -urN qca-wifi-org/os/linux/src/osif_umac.c qca-wifi-mod/os/linux/src/osif_umac.c
--- qca-wifi-org/os/linux/src/osif_umac.c	2018-06-08 11:00:41.000000000 +0530
+++ qca-wifi-mod/os/linux/src/osif_umac.c	2018-08-14 17:29:25.045491751 +0530
@@ -2425,7 +2425,7 @@
     struct ev_msg msg;
 
     if (osifp->os_opmode != IEEE80211_M_P2P_GO) {
-        if (!wlan_get_param(vap, IEEE80211_TRIGGER_MLME_RESP))
+        //if (!wlan_get_param(vap, IEEE80211_TRIGGER_MLME_RESP))
         {
         	OS_MEMSET(&wreq, 0, sizeof(wreq));
 	        IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
@@ -2508,6 +2508,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DEAUTH_IND_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
     ald_assoc_notify(((osif_dev *)osif)->os_if, macaddr, ALD_ACTION_DISASSOC);
 #if ATH_SUPPORT_WAPI
@@ -2641,6 +2642,7 @@
     memset(&wrqu, 0, sizeof(wrqu));
     IEEE80211_ADDR_COPY(wrqu.addr.sa_data, macaddr);
     wrqu.addr.sa_family = ARPHRD_ETHER;
+    wrqu.addr.sa_data[6] = IEEE80211_EV_DEAUTH_COMPLETE_STA;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wrqu, NULL);
 
 #if UMAC_SUPPORT_ACFG
@@ -3089,6 +3091,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DISASSOC_IND_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
     ald_assoc_notify(((osif_dev *)osif)->os_if, macaddr, ALD_ACTION_DISASSOC);
 #if ATH_SUPPORT_WAPI
@@ -3160,6 +3163,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DISASSOC_COMPLETE_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
 
     IEEE80211_ADDR_COPY(msg.addr, macaddr);
diff -urN qca-wifi-org/os/linux/src/umac_exports.c qca-wifi-mod/os/linux/src/umac_exports.c
--- qca-wifi-org/os/linux/src/umac_exports.c	2018-06-08 11:00:41.000000000 +0530
+++ qca-wifi-mod/os/linux/src/umac_exports.c	2018-07-03 10:15:42.428976528 +0530
@@ -203,6 +203,8 @@
 #endif
 
 EXPORT_SYMBOL(ieee80211_send_rcsa);
+EXPORT_SYMBOL(ieee80211_send_dying_gasp);
+EXPORT_SYMBOL(ieee80211_send_node_stats);
 EXPORT_SYMBOL(ieee80211_dfs_cac_cancel);
 EXPORT_SYMBOL(ieee80211_update_dfs_next_channel);
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
diff -urN qca-wifi-org/os/linux/tools/80211stats.c qca-wifi-mod/os/linux/tools/80211stats.c
--- qca-wifi-org/os/linux/tools/80211stats.c	2018-06-08 11:00:39.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/80211stats.c	2018-08-22 16:30:44.607885776 +0530
@@ -68,6 +68,70 @@
 #ifndef SIOCG80211STATS
 #define	SIOCG80211STATS	(SIOCDEVPRIVATE+2)
 #endif
+typedef struct 
+{
+	int code;
+	char *str;
+}ieee80211_reason_t;
+ieee80211_reason_t ieee80211_reason[] =
+{
+	{1,"unspecified"},
+	{2,"auth expire"},
+	{3,"auth leave"},
+	{4,"assoc expire"},
+	{5,"assoc toomany"},
+	{6,"not authed"},
+	{7,"not assoced"},
+	{8,"assoc leave"},
+	{9,"assoc not authed"},
+	{11,"rsn required"},
+	{12,"rsn inconsistent"},
+	{13,"ie invalid"},
+	{14,"mic failure"},
+	{32,"qos"},
+	{33,"qos bandwitdh"},
+	{34,"qos ch conditions"},
+	{35,"qos txop"},
+	{36,"qos leave"},
+	{37,"qos declined"},
+	{38,"qos setup required"},
+	{39,"qos timeout"},
+	{45,"qos cipher"},
+	{0,"success"},
+	{1,"unspecified"},
+	{10,"capinfo"},
+	{11,"not assoced"},
+	{12,"other"},
+	{13,"alg"},
+	{14,"sequence"},
+	{15,"challenge"},
+	{16,"timeout"},
+	{17,"toomany"},
+	{18,"basic rate"},
+	{19,"sp required"},
+	{20,"pbcc required"},
+	{21,"ca required"},
+	{22,"too many stations"},
+	{23,"rates"},
+	{25,"shortslot required"},
+	{26,"dsssofdm required"},
+	{27,"no ht"},
+	{37,"refused"},
+	{38,"invalid param"}
+};
+
+static char *ieee80211_reason_get (int code)
+{
+	int  i = 0;
+	for (i = 0; i< sizeof(ieee80211_reason);i++)
+	{
+		if (ieee80211_reason[i].code == code)
+		{
+			return ieee80211_reason[i].str;
+		}
+	}
+	return "none";
+}
 
 static void
 printstats(FILE *fd, const struct ieee80211_stats *stats)
@@ -295,15 +359,159 @@
 int
 main(int argc, char *argv[])
 {
-	int c, len;
+    const char *ifname = "ath0";
+	int c = 0 , len, index;
 	struct ieee80211req_sta_info *si;
 	u_int8_t buf[24*1024], *cp;
 	struct iwreq iwr;
-	int allnodes = 0;
+	int allnodes = 0,mgmtstats = 0;
+    int clear = 0;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 	if (s < 0)
 		err(1, "socket");
+#if 1
+    while ((c = getopt(argc, argv, "e:i:")) != -1)
+        switch (c)
+        { 
+            case 'i':
+                ifname = optarg; 
+                break; 
+            case 'e':
+                clear = atoi(optarg);
+                break;
+            case '?':
+                if (optopt == 'i')
+                    fprintf(stderr, "Option -%c requires an argument.\n", optopt);
+                close(s);
+                return -1;
+            default:
+                abort();
+        }
+	strlcpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
+	if (clear == 1)
+	{
+		char data[2] = {1};
+		ifr.ifr_data = data;
+
+		if (ioctl(s, SIOCG80211STATS, &ifr) < 0)
+		{
+			printf("error opening socket");
+			err(1, ifr.ifr_name);
+		}
+		return 0;
+	}
+	{
+		struct ieee80211_stats      *stats = NULL;
+		struct ieee80211_mac_stats  *unicast_stats = NULL;
+		struct ieee80211_mac_stats  *multicast_stats = NULL;
+		struct ieee80211_mgmt_stats *mgmt_stats = NULL;
+
+		/* no args, just show global stats */
+        /* fetch both ieee80211_stats, and mac_stats, including multicast and unicast stats */
+        stats = malloc(sizeof(struct ieee80211_stats)+ 2* sizeof(struct ieee80211_mac_stats) + sizeof (struct ieee80211_mgmt_stats));
+        if (!stats) {
+            fprintf (stderr, "Unable to allocate memory for stats\n");
+            return -1;
+        }
+		ifr.ifr_data = (caddr_t) stats;
+		if (ioctl(s, SIOCG80211STATS, &ifr) < 0)
+			err(1, ifr.ifr_name);
+		unicast_stats = (struct ieee80211_mac_stats*)(((unsigned char*)stats)+sizeof(struct ieee80211_stats));
+		multicast_stats = (struct ieee80211_mac_stats *)(((unsigned char*)stats)+sizeof(struct ieee80211_stats)+ sizeof(struct ieee80211_mac_stats));
+		mgmt_stats = (struct ieee80211_mgmt_stats*)(((unsigned char*)stats)+sizeof(struct ieee80211_stats)+2*sizeof(struct ieee80211_mac_stats));
+		
+		/* AP */
+		if (mgmt_stats->iv_opmode != 1)
+		{
+			printf(" Authentication requests received:   %llu\n",mgmt_stats->aut_recv);
+			printf(" Authentication confirms:            %llu\n",mgmt_stats->aut_confirm_xmit);
+			printf(" Authentication rejects:             %llu\n",mgmt_stats->aut_reject_xmit);
+			printf(" Deauthentication requests sent:     %llu\n",mgmt_stats->deaut_xmit);
+#if 0			
+			printf(" Deauthentication requests received: %llu\n",mgmt_stats->deaut_recv);
+#endif			
+			if (mgmt_stats->aut_recv > 0)
+			{
+				printf(" Authentication result last:         %s\n",ieee80211_reason_get(mgmt_stats->auth_reason));
+			}
+			else
+			{
+				printf(" Authentication result last:         %s\n","not available");
+			}
+#if 1	
+			printf(" Association requests received:      %llu\n",mgmt_stats->assoc_recv);
+			printf(" Association rejects:                %llu\n",mgmt_stats->assoc_reject_xmit);
+			printf(" Association confirms:               %llu\n",mgmt_stats->assoc_confirm_xmit);
+			printf(" Disassociation requests received:   %llu\n",mgmt_stats->disassoc_recv);
+			if (mgmt_stats->assoc_recv > 0)
+			{
+				printf(" Association result last:            %s\n",ieee80211_reason_get(mgmt_stats->assoc_reason));
+			}
+			else
+			{
+				printf(" Association result last:            %s\n","not available");
+			}
+#endif			
+
+		}
+		else
+		{
+
+			/* SU */
+			
+			printf(" Beacons received:                   %llu\n",mgmt_stats->bcn_recv);
+			printf(" Authentication requests sent:       %llu\n",mgmt_stats->aut_xmit);
+			printf(" Authentication confirms:            %llu\n",mgmt_stats->aut_confirm_recv);
+			printf(" Authentication rejects:             %llu\n",mgmt_stats->aut_reject_recv);
+			printf(" Deauthentication requests received: %llu\n",mgmt_stats->deaut_recv);
+			if (mgmt_stats->aut_confirm_recv || mgmt_stats->aut_reject_recv)
+			{
+				printf(" Authentication result last:         %s\n",ieee80211_reason_get(mgmt_stats->auth_reason));
+			}
+			else
+			{
+				printf(" Authentication result last:         %s\n","not available");
+			}
+#if 1
+			printf(" Association requests sent:          %llu\n",mgmt_stats->assoc_xmit);
+			printf(" Association rejects:                %llu\n",mgmt_stats->assoc_reject_recv);
+			printf(" Association confirms:               %llu\n",mgmt_stats->assoc_confirm_recv);
+			printf(" Disassociation requests sent:       %llu\n",mgmt_stats->disassoc_xmit);
+			if (mgmt_stats->assoc_reject_recv || mgmt_stats->assoc_confirm_recv)
+			{
+				printf(" Association result last:            %s\n",ieee80211_reason_get(mgmt_stats->assoc_reason));
+
+			}
+			else
+			{
+				printf(" Association result last:            %s\n","not available");
+			}
+#endif			
+
+		}
+		printf("----------------------------\r\n");
+		printf(" Multicast packets sent:             %llu\n",multicast_stats->ims_tx_packets);
+		printf(" Multicast packets received:         %llu\n",multicast_stats->ims_rx_packets);
+		printf(" Multicast data packets sent:        %llu\n",multicast_stats->ims_tx_data_packets);
+		printf(" Multicast data packets received:    %llu\n",multicast_stats->ims_rx_data_packets);
+		printf(" Multicast data bytes sent:          %llu\n",multicast_stats->ims_tx_data_bytes);
+		printf(" Multicast data bytes received:      %llu\n",multicast_stats->ims_rx_data_bytes);
+		printf(" Broadcast data packets sent:        %llu\n",multicast_stats->ims_tx_bcast_data_packets);
+		printf(" Broadcast data packets received:    %llu\n",multicast_stats->ims_rx_bcast_data_packets);
+		printf(" Unicast packets sent:               %llu\n",unicast_stats->ims_tx_packets);
+		printf(" Unicast packets received:           %llu\n",unicast_stats->ims_rx_packets);
+		printf(" Unicast data packets sent:          %llu\n",unicast_stats->ims_tx_data_packets);
+		printf(" Unicast data packets received:      %llu\n",unicast_stats->ims_rx_data_packets);
+		printf(" Unicast data bytes sent:            %llu\n",unicast_stats->ims_tx_data_bytes);
+		printf(" Unicast data bytes received:        %llu\n",unicast_stats->ims_rx_data_bytes);
+		printf(" Broadcast data packets sent:        %llu\n",unicast_stats->ims_tx_bcast_data_packets);
+		printf(" Broadcast data packets received:    %llu\n",unicast_stats->ims_rx_bcast_data_packets);
+
+		free(stats);
+		return 0;
+	}
+#else
 	strlcpy(ifr.ifr_name, "ath0", sizeof (ifr.ifr_name));
 	while ((c = getopt(argc, argv, "ai:")) != -1)
 		switch (c) {
@@ -376,4 +584,5 @@
 		}
 	}
         return 0;       	
+#endif
 }
diff -urN qca-wifi-org/os/linux/tools/athstats.c qca-wifi-mod/os/linux/tools/athstats.c
--- qca-wifi-org/os/linux/tools/athstats.c	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/athstats.c	2018-08-22 16:30:50.671885994 +0530
@@ -633,9 +633,11 @@
 {
     fprintf(fd, "txrx stats:\n");
     if (stats_level == TXRX_STATS_LEVEL_BASIC) {
-        fprintf(fd,"  tx: %u msdus (%u B)\n",
+        fprintf(fd,"tx:%u\n",
+            stats->tx.delivered.pkts);
+        /* fprintf(fd,"  tx: %u msdus (%u B)\n",
             stats->tx.delivered.pkts,
-            stats->tx.delivered.bytes);
+            stats->tx.delivered.bytes); */
     } else { /* full */
         fprintf(fd,
             "  tx: sent %u msdus (%u B), "
@@ -661,10 +663,12 @@
             stats->tx.dropped.no_ack.pkts,
             stats->tx.dropped.no_ack.bytes);
     }
-    fprintf(fd,
+    fprintf(fd,"rx:%u\n",
+        stats->rx.delivered.pkts);
+    /*fprintf(fd,
         "  rx: %u msdus, %u bytes\n",
         stats->rx.delivered.pkts,
-        stats->rx.delivered.bytes);
+        stats->rx.delivered.bytes);*/
     if (stats_level == TXRX_STATS_LEVEL_FULL) {
         fprintf(fd,
             "    forwarded %u msdus, %u bytes\n",
@@ -727,11 +731,11 @@
     /* AMSDUs that have more MSDUs than the status ring size */
     fprintf(fd,"oversize_amsdu    :\t%d\n",rx->oversize_amsdu);
     /* Number of PHY errors */
-    fprintf(fd,"phy_errs          :\t%d\n",rx->phy_errs);
+    fprintf(fd,"phy_errors:%d\n",rx->phy_errs);
     /* Number of PHY errors dropped */
     fprintf(fd,"phy_errs dropped  :\t%d\n",rx->phy_err_drop);
     /* Number of mpdu errors - FCS, MIC, ENC etc. */
-    fprintf(fd,"mpdu_errs         :\t%d\n",rx->mpdu_errs);
+    fprintf(fd,"mpdu_errs:%d\n",rx->mpdu_errs);
 
 }
 
@@ -741,11 +745,11 @@
     const struct wlan_dbg_tx_stats *tx = &wlan_pdev_stats->tx;
     int   i;
 
-    fprintf(fd,"ast_be_xmit         :\t%llu\n",radio_stats->tx_beacon);
+    fprintf(fd,"ast_be_xmit:%llu\n",radio_stats->tx_beacon);
     fprintf(fd,"ast_be_nobuf        :\t%d\n",radio_stats->be_nobuf);
     fprintf(fd,"ast_tx_buf_count    :\t%u\n",radio_stats->tx_buf_count);
-    fprintf(fd,"ast_tx_packets      :\t%u\n",radio_stats->tx_mgmt + radio_stats->tx_num_data);
-    fprintf(fd,"ast_rx_packets      :\t%u\n",radio_stats->rx_packets);
+    fprintf(fd,"ast_tx_packets:%u\n",radio_stats->tx_mgmt + radio_stats->tx_num_data);
+    fprintf(fd,"ast_rx_packets:%u\n",radio_stats->rx_packets);
     fprintf(fd,"ast_tx_mgmt         :\t%d\n",radio_stats->tx_mgmt);
     fprintf(fd,"ast_tx_nobuf        :\t%d\n",tx->wmm_drop);
     fprintf(fd,"ast_tx_xretries     :\t%u\n",tx->tx_xretry);
diff -urN qca-wifi-org/qca_ol/osif_ol.c qca-wifi-mod/qca_ol/osif_ol.c
--- qca-wifi-org/qca_ol/osif_ol.c	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/qca_ol/osif_ol.c	2018-08-31 19:02:47.490721458 +0530
@@ -106,6 +106,7 @@
 extern bool osif_pltfrm_deliver_data(os_if_t osif, wbuf_t wbuf);
 #endif
 
+char kwn_tput_test_dsap[6] = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
 #if UMAC_VOW_DEBUG
 static inline void
 osif_ol_hadrstart_vap_vow_debug(osif_dev  *osdev, struct sk_buff *skb){
@@ -460,6 +461,12 @@
 }
 #endif /*end of ATH_DATA_RX_INFO_EN*/
 
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+};
 
 
 #if QCA_NSS_PLATFORM
@@ -469,10 +476,11 @@
     struct net_device *dev = OSIF_TO_NETDEV(osif);
     osif_dev  *osdev = (osif_dev *)osif;
     int nwifi = ((osif_dev *)osif)->nss_nwifi;
+    struct ieee80211_stats *iv_stats;
 
-#if ATH_SUPPORT_WRAP
+//#if ATH_SUPPORT_WRAP
     wlan_if_t vap = osdev->os_if;
-#endif
+//#endif
 
 #if QCA_OL_VLAN_WAR
     struct net_device *comdev;
@@ -482,6 +490,8 @@
     scn = ath_netdev_priv(comdev);
 #endif /* QCA_OL_VLAN_WAR */
 
+    iv_stats = wlan_get_stats(vap);
+
     while (skb_list) {
         struct sk_buff *skb;
         skb = skb_list;
@@ -569,7 +579,57 @@
 	}
 #endif  /* HOST_SW_LRO_ENABLE */
 
-        osif_send_to_nss(osif, skb, nwifi);
+	/* inc Tx packets/bytes offered by kernel to us */
+	iv_stats->rx_offer_pkt_cnt++;
+	iv_stats->rx_offer_pkt_bytes_cnt += skb->len;
+
+	if ( iv_stats->kwn_rx_tput_last_jiffies == 0 ) {
+		iv_stats->kwn_rx_tput_last_jiffies = jiffies;
+	} else {
+		if ( (jiffies - iv_stats->kwn_rx_tput_last_jiffies) >= 1000 )
+		{
+			iv_stats->kwn_rx_tput_mbps = iv_stats->rx_offer_pkt_cnt > 0 ? 
+				( (iv_stats->rx_offer_pkt_bytes_cnt * 8)) : 0;
+			iv_stats->kwn_rx_tput_last_jiffies = jiffies;
+			iv_stats->rx_offer_pkt_cnt = 0;
+			iv_stats->rx_offer_pkt_bytes_cnt = 0;
+			//printk(": RX Tput: %llu\n",iv_stats->kwn_rx_tput_mbps);
+		}
+	}
+
+	/* In case of KWN Tput Packets, then drop them immediately */
+	if ( skb->len > 20 && 
+			(memcmp(&skb->data[14], kwn_tput_test_dsap, 6) == 0)) {
+		if ( 1 /*vap->kwn_tput_test_in_progress == 0*/ ) {
+			struct kwn_tput_test_params *kparams;
+			int offset = 0;
+
+			offset += sizeof(struct ether_header) + sizeof(kwn_tput_test_dsap);
+			kparams = (struct kwn_tput_test_params *)&skb->data[ offset ];
+			vap->kwn_tput_test_duration = ntohl(kparams->kwn_tput_test_duration);
+			vap->kwn_tput_test_pkt_size = ntohl(kparams->kwn_tput_test_pktsize);
+			vap->kwn_tput_test_pkt_per_ms = ntohl(kparams->kwn_tput_test_pktperms);
+			vap->kwn_tput_test_direction = ntohl(kparams->kwn_tput_test_direction);
+			/*printk(": Dur: %d PktSize: %d PktPerMs: %d Dir: %d\n",
+				vap->kwn_tput_test_duration,
+				vap->kwn_tput_test_pkt_size,
+				vap->kwn_tput_test_pkt_per_ms,
+				vap->kwn_tput_test_direction);
+			if ( vap->kwn_tput_test_direction > 0 &&
+				vap->kwn_tput_test_direction > 1 ) {
+				if ( vap->iv_opmode == IEEE80211_M_HOSTAP )
+					printk("\n DL Tput Test Started....\n");
+				else
+					printk("\n UL Tput Test Started....\n");
+				vap->kwn_tput_test_in_progress = 1;
+				vap->kwn_tput_test_start_time = jiffies;
+				tasklet_schedule( &vap->kwn_tput_tq );
+			}*/
+		}
+		dev_kfree_skb_any ( skb );
+		continue;
+	}
+	osif_send_to_nss(osif, skb, nwifi);
     }
 
 #if HOST_SW_LRO_ENABLE
@@ -834,10 +894,25 @@
     osdev = ath_netdev_priv(dev);
     vap = osdev->os_if;
     iv_stats = wlan_get_stats(vap);
+
     /* inc Tx packets/bytes offered by kernel to us */
     iv_stats->tx_offer_pkt_cnt++;
     iv_stats->tx_offer_pkt_bytes_cnt += skb->len;
 
+    if ( iv_stats->kwn_tx_tput_last_jiffies == 0 ) {
+	    iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+    } else {
+	    if ( (jiffies - iv_stats->kwn_tx_tput_last_jiffies) >= 1000 )
+	    {
+		    iv_stats->kwn_tx_tput_mbps = iv_stats->tx_offer_pkt_cnt > 0 ? 
+						( (iv_stats->tx_offer_pkt_bytes_cnt * 8)) : 0;
+		    iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+		    iv_stats->tx_offer_pkt_cnt = 0;
+		    iv_stats->tx_offer_pkt_bytes_cnt = 0;
+		    //printk(": Tx Tput: %llu\n",iv_stats->kwn_tx_tput_mbps);
+	    }
+    }
+
     qdf_nbuf_count_inc(skb);
     if (qdf_unlikely((dev->flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP))) {
 	    goto bad1;
@@ -968,6 +1043,16 @@
     }
 #endif
 
+    /* If Packet started in Local, then Tag the packet with MgmtVLANID*/
+    if ( vap->kwn_mgmt_vlan_id > 0 ) {
+	    eh = (struct ether_header *)(skb->data);
+	    if ( memcmp ( vap->kwn_eth_mac_addr, eh->ether_shost, 6 ) == 0 ) {
+		    skb = __vlan_put_tag( skb, htons(ETH_P_8021Q), vap->kwn_mgmt_vlan_id );
+		    if ( unlikely ( !skb ) ) {
+			    goto bad1;
+		    }
+	    }
+    }
 
     osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
 
diff -urN qca-wifi-org/umac/base/ieee80211_channel.c qca-wifi-mod/umac/base/ieee80211_channel.c
--- qca-wifi-org/umac/base/ieee80211_channel.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_channel.c	2018-07-26 18:36:49.261046813 +0530
@@ -21,6 +21,7 @@
 #include <if_smart_ant.h>
 #include <qdf_lock.h>
 #include <osif_private.h>
+#include <ieee80211_acs_internal.h>
 
 int ieee80211_ucfg_set_chanswitch(wlan_if_t vaphandle, u_int8_t chan, u_int8_t tbtt, u_int16_t ch_width);
 
@@ -1930,6 +1931,7 @@
 {
     struct ieee80211vap *vap = vaphandle;
     struct ieee80211com *ic = vap->iv_ic;
+    struct ieee80211_acs *acs = ic->ic_acs;
 
     if (!channel) {
         IEEE80211_DPRINTF(vap, IEEE80211_MSG_ACS,
@@ -1989,6 +1991,19 @@
      * TBD: If curchan = channel, still need to set channel again to pass
      * SendRecv_ext in ndistest.
      */
+    /* Fixed channel in client mode: updating configured frequency if acs is disabled */
+    if( ic->sta_freq == 0 )
+       ic->sta_freq = channel->ic_freq;
+
+    /* TODO: Fixed channel in client mode is not working on 80MHz, so enabling ACS on 80MHz*/
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP || vap->iv_des_mode == IEEE80211_MODE_11AC_VHT80 )
+    {
+        /* For Fixed channel in AP, updating the acs chans to 0 */
+        if( ic->sta_freq > 0 ) {
+            acs->acs_nchans_scan = 0;
+        }
+        ic->sta_freq = -1;
+    }
     if (ieee80211_vap_ready_is_set(vap) || ieee80211_vap_dfswait_is_set(vap) ||
         (ic->cw_inter_found)) {// && ic->ic_curchan != channel) {
         ieee80211_set_channel(ic, channel);
diff -urN qca-wifi-org/umac/base/ieee80211_config.c qca-wifi-mod/umac/base/ieee80211_config.c
--- qca-wifi-org/umac/base/ieee80211_config.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_config.c	2018-09-04 18:44:52.595726996 +0530
@@ -478,12 +478,13 @@
              vap->iv_fixed_rate.series = IEEE80211_FIXED_RATE_NONE;
         } else {
              if (val & 0x80) {
-
+#if 0
                 if (!IEEE80211_IS_CHAN_VHT(ic->ic_curchan) && !IEEE80211_IS_CHAN_11N(ic->ic_curchan))
                 {
                     QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Rate is not allowed in current mode\n");
                     return -EINVAL;
                 }
+#endif
                 vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_MCS;
              } else {
                  vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_LEGACY;
@@ -1115,9 +1116,10 @@
          }
          vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_NONE;
 
-         if (val > 9) {
+         if (val == 21) {
             /* Treat this as disabling fixed rate */
-            return EOK;
+             break;
+            //return EOK;
          }
 
 	 if (is2GHz && (val > 7) && (!ieee80211_vap_256qam_is_set(vap))) {
@@ -1125,10 +1127,15 @@
 		 return EOK;
 	 }
 
+         vap->iv_nss = 1;
+         if( val > 9 ) {
+             vap->iv_nss = 2;
+             val = val - 10;
+         }
          vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_VHT;
          vap->iv_vht_fixed_mcs = val;
+         printk("\n############## VHT MCS %d NSS %d ################ \n",val,vap->iv_nss);
     break;
-
     case IEEE80211_FIXED_NSS:
          if (val > ieee80211_getstreams(ic, ic->ic_tx_chainmask))
          return -EINVAL;
@@ -2667,7 +2674,6 @@
              val = vap->iv_vht_fixed_mcs;
          }
     break;
-
     case IEEE80211_FIXED_NSS:
          val = vap->iv_nss;
     break;
diff -urN qca-wifi-org/umac/base/ieee80211_ucfg.c qca-wifi-mod/umac/base/ieee80211_ucfg.c
--- qca-wifi-org/umac/base/ieee80211_ucfg.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_ucfg.c	2018-10-14 23:29:17.414292228 +0530
@@ -50,6 +50,27 @@
 #define HIGHEST_BASIC_RATE 24000
 #define THREE_HUNDRED_FIFTY_MBPS 350000
 
+/* KWN: Ethernet EDMA Routines */
+extern int edma_set_vid_bitmap(struct net_device *dev, int16_t vid, int16_t flags);
+extern int edma_clear_vid_bitmap(struct net_device *dev, int16_t vid);
+extern int edma_set_vlan_mode(struct net_device *dev, int8_t vlan_mode);
+extern int edma_set_allow_untagged(struct net_device *dev, int8_t allow_untagged);
+extern int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all );
+extern int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType );
+extern uint64_t edma_get_tx_pkts( struct net_device *dev );
+extern uint64_t edma_get_tx_errors( struct net_device *dev );
+extern uint64_t edma_get_tx_bytes( struct net_device *dev );
+extern uint64_t edma_get_rx_pkts( struct net_device *dev );
+extern uint64_t edma_get_rx_errors( struct net_device *dev );
+extern uint64_t edma_get_rx_bytes( struct net_device *dev );
+extern int edma_get_mgmt_vlan_id( struct net_device *dev );
+extern int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id );
+
 extern int ol_ath_ucfg_get_user_postion(wlan_if_t vaphandle, u_int32_t aid);
 extern int ol_ath_ucfg_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
 extern int ol_ath_ucfg_reset_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
@@ -2642,7 +2663,10 @@
     case IEEE80211_IOC_SCAN_FLUSH:
         IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL, "set %s\n",
                         "IEEE80211_IOC_SCAN_FLUSH");
-        wlan_scan_table_flush(vap);
+        /* Flush the entries only when user set */
+        if ( vap->kwn_pbb_add_mac_flag == 1 ) {
+            wlan_scan_table_flush(vap);
+        }
         retv = 0; /* success */
         break;
 
@@ -3974,7 +3998,190 @@
     case IEEE80211_PARAM_DFS_INFO_NOTIFY_APP:
         ic->ic_dfs_info_notify_channel_available = !!value;
         break;
+    case IEEE80211_PARAM_UPLINK_LIMIT:
+        vap->kwn_ul_limit = value;
+        break;
+    case IEEE80211_PARAM_DOWNLINK_LIMIT:
+        vap->kwn_dl_limit = value;
+        break;
+    case IEEE80211_PARAM_KWN_VLAN_MODE: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_vlan_mode(eth_dev, value);
+		printk(": Ethernet VLANMode: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_VID_ADD:
+	{
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_vid_bitmap(eth_dev, value, 0);
+		printk(": Set Vid: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_VID_DEL: 
+	{
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_clear_vid_bitmap(eth_dev, value);
+		printk(": Clear Vid: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_ALLOW_UNTAGGED: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		if ( value == 0 || value == 1 ) {
+			edma_set_allow_untagged(eth_dev, value);
+			edma_set_allow_all_tagged_trunk(eth_dev, 0);
+		}
+		else if ( value == 2 ) {
+			edma_set_allow_untagged(eth_dev, 0);
+			edma_set_allow_all_tagged_trunk(eth_dev, 1);
+		} else {
+			edma_set_allow_untagged(eth_dev, 0);
+			edma_set_allow_all_tagged_trunk(eth_dev, 0);
+		}
+		printk(": Allow Untagged: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_ACCESS_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_access_vlan_id(eth_dev, value);
+		printk(": Access VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_NATIVE_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_native_vlan_id(eth_dev, value);
+		printk(": Native VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_MGMT_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_mgmt_vlan_id(eth_dev, value);
+		vap->kwn_mgmt_vlan_id = value;
+		memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+		printk(": Mgmt VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_SVLAN_ID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_svlan_id(eth_dev, value);
+		printk(": SVlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_svlan_etherType(eth_dev, value);
+		printk(": SVlan EtherType: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST: 
+	if ( value ) {
+		printk("\n Start Test ...\n");
+        vap->kwn_tput_test_start_time = jiffies;
+        vap->kwn_tput_test_in_progress = 1;
+        vap->kwn_tput_test_from_app = 1;
+        if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 2 )
+            ieee80211_send_tput_test(vap);
+        if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 1 )
+            tasklet_schedule(&vap->kwn_tput_tq);
+    } else {
+		printk("\n Stop Test...\n");
+		vap->kwn_tput_test_start_time = 0;
+		vap->kwn_tput_test_in_progress = 0;
+        if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 2 )
+            ieee80211_send_tput_test(vap);
+		vap->kwn_tput_test_from_app = 0;
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DUR:
+	vap->kwn_tput_test_duration = value * 1000;
+	//printk(": Test Duration: %d\n",vap->kwn_tput_test_duration);
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS:
+	vap->kwn_tput_test_pkt_per_ms = value;
+	//printk(": Test PacketPerMs: %d\n",vap->kwn_tput_test_pkt_per_ms);
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE:
+	vap->kwn_tput_test_pkt_size = value;
+	//printk(": Test PktSize: %d\n",vap->kwn_tput_test_pkt_size);
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DIR:
+	vap->kwn_tput_test_direction = value;
+	//printk(": Test Direction: %d\n",vap->kwn_tput_test_direction);
+	break;
 
+    case IEEE80211_PARAM_KWN_SET_PBB_B_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_pbb_bvid(eth_dev, value);
+		printk(": PBB B VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_PBB_B_ISID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_pbb_isid(eth_dev, value);
+		printk(": PBB B VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_SET_PBB_B_MAC_FLAG: 
+	{
+		vap->kwn_pbb_add_mac_flag = value;
+		printk(": PBB MAC Flag: %d", value);
+		break;
+	}
+    case IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET: 
+	{
+		vap->kwn_noise_floor_offset = value;
+		printk(": Noise Floor Offset: %d", value);
+		break;
+	}
     }
 
     if (retv == ENETRESET)
@@ -5586,6 +5793,84 @@
     case IEEE80211_PARAM_DFS_INFO_NOTIFY_APP:
         *value = ic->ic_dfs_info_notify_channel_available;
         break;
+    case IEEE80211_PARAM_UPLINK_LIMIT:
+        *value = vap->kwn_ul_limit;
+        break;
+    case IEEE80211_PARAM_DOWNLINK_LIMIT:
+        *value = vap->kwn_dl_limit;
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_PKTS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_pkts(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_BYTES:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_bytes(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_PKTS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_pkts(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_BYTES:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_bytes(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST: 
+        *value = vap->kwn_tput_test_in_progress;
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DUR: 
+        *value = vap->kwn_tput_test_duration / 1000;
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DIR: 
+        *value = vap->kwn_tput_test_direction;
+        break;
+    case IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET: 
+        *value = vap->kwn_noise_floor_offset;
+        break;
     }
 
     if (retv) {
@@ -6582,12 +6867,15 @@
     wlan_chan_t chan = wlan_node_get_chan(node);
     ieee80211_rate_info rinfo;
     u_int32_t jiffies_now=0, jiffies_delta=0, jiffies_assoc=0;
+    struct ieee80211_stats *iv_stats;
+    struct ieee80211com *ic = vap->iv_ic;
     /* already ignore invalid nodes in UMAC */
 
     if (chan == IEEE80211_CHAN_ANYC) { /* XXX bogus entry */
         return;
     }
 
+    iv_stats = wlan_get_stats(vap);
     len = sta_space(node, &ielen, vap);
     if (len > req->space) {
         return;
@@ -6641,6 +6929,7 @@
         si->isi_tx_rate_mcs = rinfo.mcs;
         si->isi_tx_rate_flags = rinfo.flags;
 #endif
+        si->isi_kwn_tx_rate_mcs = rinfo.mcs & 0x0F;
 
     }
 
@@ -6685,7 +6974,40 @@
     si->isi_is_256qam = wlan_node_get_256qam_support(node);
     si->isi_rx_nss = wlan_node_get_rx_spatial(node);
     si->isi_tx_nss = wlan_node_get_tx_spatial(node);
-
+#if 0
+    printk("sizeof : %d,r_latitude = %s,r_longitude = %s,l_latitude = %s,l_longitude = %s\n",si->isi_len,node->ni_latitude,
+		node->ni_longitude,vap->iv_ic->ic_latitude,vap->iv_ic->ic_longitude);
+#endif
+    if ( ( strlen(node->ni_latitude) != 0 ) && ( strlen(node->ni_longitude) != 0 ) &&
+		    ( strlen(vap->iv_ic->ic_latitude) != 0 ) && ( strlen(vap->iv_ic->ic_longitude) != 0) ) {
+	    strncpy(si->isi_r_latitude,node->ni_latitude,32);
+	    strncpy(si->isi_r_longitude,node->ni_longitude,32);
+	    strncpy(si->isi_l_latitude,vap->iv_ic->ic_latitude,32);
+	    strncpy(si->isi_l_longitude,vap->iv_ic->ic_longitude,32);
+    }
+#if 0
+    printk("r_latitude = %s,r_longitude = %s,l_latitude = %s,l_longitude = %s\n",si->isi_r_latitude,si->isi_r_longitude,
+			si->isi_l_latitude,si->isi_l_longitude);
+#endif
+    si->isi_tx_tput = node->tx_tput_mbps;
+    si->isi_rx_tput = iv_stats->kwn_rx_tput_mbps;
+    si->isi_local_snr_a1 = vap->kwn_local_snr_a1;
+    si->isi_local_snr_a2 = vap->kwn_local_snr_a2;
+    si->isi_remote_snr_a1 = node->remote_snr_a1;
+    si->isi_remote_snr_a2 = node->remote_snr_a2;
+    si->isi_ip_addr = node->ip_addr;
+    si->isi_local_phy_err = vap->kwn_local_phy_err;
+    si->isi_remote_phy_err = node->remote_phy_err;
+    si->isi_local_mpdu_err = vap->kwn_local_mpdu_err;
+    si->isi_remote_mpdu_err = node->remote_mpdu_err;
+    si->isi_local_retries = vap->kwn_local_retries;
+    si->isi_remote_retries = node->remote_retries;
+    memcpy( si->isi_l_customer_name, ic->ic_customer_name, sizeof(ic->ic_customer_name) );
+    memcpy( si->isi_r_customer_name, node->customer_name, sizeof(node->customer_name) );
+    si->isi_l_link_id = ic->ic_link_id;
+    si->isi_r_link_id = node->link_id;
+    si->isi_l_noise_floor = vap->kwn_local_noise_floor + vap->kwn_noise_floor_offset;
+    si->isi_r_noise_floor = node->remote_noise_floor + vap->kwn_noise_floor_offset;
     cp = (u_int8_t *)(si+1);
 
     if(!wlan_node_getwpaie(vap, macaddr, ni_ie, &ni_ie_len)) {
diff -urN qca-wifi-org/umac/base/ieee80211_ucfg.h qca-wifi-mod/umac/base/ieee80211_ucfg.h
--- qca-wifi-org/umac/base/ieee80211_ucfg.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_ucfg.h	2018-08-14 17:39:44.969471224 +0530
@@ -56,4 +56,5 @@
 int ieee80211_ucfg_set_otherband_bssid(wlan_if_t vap, int *val);
 int ieee80211_ucfg_send_probereq(wlan_if_t vap, int val);
 int ieee80211_ucfg_get_cap_snr(wlan_if_t vap, int *cap_snr);
+int ieee80211_send_tput_test(wlan_if_t vap);
 #endif //IEEE80211_UCFG_H_
diff -urN qca-wifi-org/umac/base/ieee80211_vap.c qca-wifi-mod/umac/base/ieee80211_vap.c
--- qca-wifi-org/umac/base/ieee80211_vap.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_vap.c	2018-07-05 16:33:52.998167293 +0530
@@ -37,6 +37,73 @@
 void acfg_clean(struct ieee80211com *ic);
 #endif
 
+/* Phani: Tx Tasklet for KWN TPUT Test */
+char kwn_tput_test_dsap[6] = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+};
+void
+ieee80211_send_kwn_tput_tx( void *data )
+{
+	struct ieee80211vap *vap = (struct ieee80211vap *)data;
+	int pkt_per_ms = vap->kwn_tput_test_pkt_per_ms;
+  	int pkt_size = vap->kwn_tput_test_pkt_size;
+	struct ether_header *eth;
+	struct net_device *dev;
+	struct kwn_tput_test_params *kparams;
+	int offset = 0;
+
+	if ( (dev = dev_get_by_name( &init_net, vap->iv_netdev_name )) == NULL )
+		return;
+
+	/* Calculate packet count per ms */
+	for ( ; pkt_per_ms > 0; --pkt_per_ms )
+	{
+		struct sk_buff *skb = NULL;
+		/* Create a packet */
+		skb = dev_alloc_skb ( pkt_size + 64 );
+		if ( skb == NULL ) {
+			return;
+		}
+		/* Fill the skb content */
+		skb_reserve( skb, 64 );
+		skb_put( skb, pkt_size );
+		skb->dev = dev;
+		eth = (struct ether_header *)skb->data;
+		IEEE80211_ADDR_COPY( eth->ether_shost, vap->iv_myaddr );
+		if ( vap->iv_opmode == IEEE80211_M_STA )
+			IEEE80211_ADDR_COPY( eth->ether_dhost, vap->iv_bss->ni_macaddr );
+		else
+			IEEE80211_ADDR_COPY( eth->ether_dhost, vap->kwn_tput_test_mac );
+		eth->ether_type = htons( skb->len - sizeof(*eth) );
+		memcpy(&skb->data[sizeof(*eth)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap));
+		if ( 1 /*vap->kwn_tput_test_from_app*/ ) {
+			offset += sizeof(*eth) + sizeof(kwn_tput_test_dsap);
+			kparams = (struct kwn_tput_test_params *)&skb->data[offset];
+			kparams->kwn_tput_test_duration = htonl(vap->kwn_tput_test_duration);
+			kparams->kwn_tput_test_pktsize = htonl(pkt_size);
+			kparams->kwn_tput_test_pktperms = htonl(pkt_per_ms);
+			kparams->kwn_tput_test_direction = htonl(vap->kwn_tput_test_direction);
+			vap->kwn_tput_test_from_app = 0;
+		}
+		skb_reset_mac_header( skb );
+		dev_queue_xmit( skb );
+	}	
+	/* Schedule Tx Tasklet when test duration is not completed */
+	if ( vap->kwn_tput_test_start_time &&
+			(( jiffies - vap->kwn_tput_test_start_time ) < vap->kwn_tput_test_duration )) {
+		tasklet_schedule( &vap->kwn_tput_tq );
+	} else {
+		vap->kwn_tput_test_in_progress = 0;
+	} 
+	dev_put( dev );	
+	return;
+}
+
+
 #if DYNAMIC_BEACON_SUPPORT
 static OS_TIMER_FUNC(ieee80211_dbeacon_suspend_beacon)
 {
@@ -502,6 +569,9 @@
         }
 #endif
 
+
+    tasklet_init(&vap->kwn_tput_tq, (void *)ieee80211_send_kwn_tput_tx, (unsigned long)vap);
+    vap->kwn_tput_test_start_time = 0;
     vap->offchan_requestor = 0;
     vap->iv_csmode = IEEE80211_CSA_MODE_AUTO; /* csmode will be calculated dynamically */
     vap->iv_enable_ecsaie = true; /* Extended channel switch ie is enabled by default */
@@ -553,6 +623,8 @@
 {
     int i;
 
+    /* Phani */
+    tasklet_kill(&vap->kwn_tput_tq);
     ieee80211_quiet_vdetach(vap);
     ieee80211_vap_ath_info_detach(vap->iv_vap_ath_info_handle);
     ieee80211_node_latevdetach(vap);
diff -urN qca-wifi-org/umac/include/ieee80211_mlme.h qca-wifi-mod/umac/include/ieee80211_mlme.h
--- qca-wifi-org/umac/include/ieee80211_mlme.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_mlme.h	2018-07-03 10:12:53.964984596 +0530
@@ -718,6 +718,7 @@
 };
 
 int ieee80211_parse_beacon(struct ieee80211vap                  *vap,
+			   struct ieee80211_node 		*ni,
                            struct ieee80211_beacon_frame        *beacon_frame,
                            const struct ieee80211_frame         *wh,
                            u_int32_t                            beacon_frame_length,
diff -urN qca-wifi-org/umac/include/ieee80211_node.h qca-wifi-mod/umac/include/ieee80211_node.h
--- qca-wifi-org/umac/include/ieee80211_node.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_node.h	2018-09-17 16:59:46.840252613 +0530
@@ -585,6 +585,19 @@
     bool        is_ft_reassoc;
     ni_mgmt_stats_t ni_mgmt_stats;
     ni_ctrl_stats_t ni_ctrl_stats;
+    u_int32_t   dg_count;
+    char	ni_latitude[32];
+    char	ni_longitude[32];
+    u_int8_t    remote_snr_a1;
+    u_int8_t    remote_snr_a2;
+    uint32_t    ip_addr;
+    u_int64_t   tx_tput_mbps;
+    u_int32_t   remote_phy_err;
+    u_int32_t   remote_mpdu_err;
+    u_int32_t   remote_retries;
+    u_int8_t	customer_name[32];
+    u_int8_t	link_id;
+    int16_t	    remote_noise_floor;
 } IEEE80211_NODE, *PIEEE80211_NODE;
 
 
diff -urN qca-wifi-org/umac/include/ieee80211_scan.h qca-wifi-mod/umac/include/ieee80211_scan.h
--- qca-wifi-org/umac/include/ieee80211_scan.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_scan.h	2018-07-03 10:12:53.968984596 +0530
@@ -587,6 +587,7 @@
 
 struct ieee80211_scan_entry *
 ieee80211_scan_table_update(struct ieee80211vap          *vap,
+			    struct ieee80211_node *ni,
                             struct ieee80211_frame *wh,
                             u_int32_t                    frame_length,
                             int                          subtype, 
diff -urN qca-wifi-org/umac/include/ieee80211_vap.h qca-wifi-mod/umac/include/ieee80211_vap.h
--- qca-wifi-org/umac/include/ieee80211_vap.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_vap.h	2018-07-03 10:16:28.988974298 +0530
@@ -177,4 +177,7 @@
  *  Return ieee80211_cwm_width
  */
 enum ieee80211_cwm_width ieee80211_get_vap_max_chwidth (struct ieee80211vap *vap);
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap,u_int32_t send_ack,struct ieee80211_node *ni);
+void ieee80211_send_uldl_limit(struct ieee80211vap *vap);
+void ieee80211_send_node_stats(struct ieee80211vap *vap);
 #endif
diff -urN qca-wifi-org/umac/include/ieee80211_var.h qca-wifi-mod/umac/include/ieee80211_var.h
--- qca-wifi-org/umac/include/ieee80211_var.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_var.h	2018-10-14 23:29:29.198223057 +0530
@@ -1886,6 +1886,20 @@
     u_int32_t                           ic_whc_scaling_factor; /* scaling factor for WHC best uplink algorithm */
     u_int32_t                           device_id;   /* Device id from probe */
     u_int32_t                           vendor_id;   /* Vendor id from probe */
+    int                                 sta_freq;        /* setting in Mhz */
+    u_int32_t                           dying_gasp;
+    u_int32_t                           ic_str_type;
+    u_int8_t                          	ic_link_id;
+    char				ic_customer_name[32];
+    char				ic_longitude[32];
+    char				ic_latitude[32];
+    u_int32_t				ic_dg_timer_interval;
+    u_int32_t				ic_dg_ack_disable;
+    os_timer_t                          kwn_stats_timer;
+    u_int32_t                           kwn_amsdu;
+    u_int16_t                           kwn_start_freq;
+    u_int16_t                           kwn_curr_freq;
+    u_int16_t                           kwn_end_freq;
 } IEEE80211COM, *PIEEE80211COM;
 
 #define BEST_UL_HYST_DEF        10
@@ -2283,6 +2297,9 @@
     struct ieee80211_stats            iv_stats; /* for backward compatibility */
     struct ieee80211_mac_stats        iv_unicast_stats;   /* mac statistics for unicast frames */
     struct ieee80211_mac_stats        iv_multicast_stats; /* mac statistics for multicast frames */
+#ifdef SIFY_MGMT_STATS
+	struct ieee80211_mgmt_stats       iv_mgmt_stats;
+#endif	
     struct tkip_countermeasure        iv_unicast_counterm;  /* unicast tkip countermeasure */
     struct tkip_countermeasure        iv_multicast_counterm;  /* unicast tkip countermeasure */
 
@@ -2673,6 +2690,7 @@
     void                        *iv_txrx_handle;
 #endif
     u_int8_t                   iv_vht_fixed_mcs;        /* VHT Fixed MCS Index */
+    u_int8_t                   iv_ht_fixed_mcs;         /* HT Fixed MCS Index */
     u_int8_t                   iv_nss;                  /* Spatial Stream Count */
     u_int8_t                   iv_tx_stbc;              /* TX STBC Enable:1 Disable:0 */
     u_int8_t                   iv_rx_stbc;              /* RX STBC Enable:(1,2,3) Disable:0 */
@@ -2908,6 +2926,27 @@
     bool                       iv_wps_session;
     csa_deauth_type            iv_csa_deauth_mode; /* if set, sends deauth to all stations after CSA */
     u_int8_t                   iv_filter_ssid[IEEE80211_NWID_LEN+1]; /* Filter SSID from scan results */
+    u_int32_t                  kwn_ul_limit;
+    u_int32_t                  kwn_dl_limit;
+    u_int8_t                   kwn_local_snr_a1;
+    u_int8_t                   kwn_local_snr_a2;
+    struct tasklet_struct      kwn_tput_tq;             /* Holds a hrtimer to send broadcast probe response from a vap */
+    u_int64_t                  kwn_tput_test_start_time;
+    u_int32_t                  kwn_tput_test_duration;
+    u_int32_t                  kwn_tput_test_pkt_size;
+    u_int32_t                  kwn_tput_test_pkt_per_ms;
+    char                       kwn_tput_test_mac[6];
+    u_int8_t                   kwn_tput_test_in_progress;
+    u_int8_t                   kwn_tput_test_direction;
+    u_int8_t                   kwn_tput_test_from_app;
+    u_int32_t                  kwn_local_phy_err;
+    u_int32_t                  kwn_local_mpdu_err;
+    u_int32_t                  kwn_local_retries;
+    u_int32_t                  kwn_mgmt_vlan_id;
+    char                       kwn_eth_mac_addr[6];
+    int16_t                    kwn_local_noise_floor;
+    u_int8_t                   kwn_pbb_add_mac_flag;
+    u_int8_t                   kwn_noise_floor_offset;
 } IEEE80211VAP, *PIEEE80211VAP;
 
 #if QCN_IE
diff -urN qca-wifi-org/umac/mlme/ieee80211_beacon.c qca-wifi-mod/umac/mlme/ieee80211_beacon.c
--- qca-wifi-org/umac/mlme/ieee80211_beacon.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_beacon.c	2018-07-03 10:12:53.968984596 +0530
@@ -594,6 +594,18 @@
         bo->bo_ibssdfs_trailerlen = 0;
     }
 #endif /* ATH_SUPPORT_IBSS_DFS */
+    /* Update latitude and longitude info if valid*/
+    if ( (strlen(ic->ic_latitude) != 0 ) && (strlen(ic->ic_longitude) != 0 ) ) {
+	    *frm++ = IEEE80211_ELEMID_RESERVED_47;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_latitude,32);
+	    frm += 32;
+	    *frm++ = IEEE80211_ELEMID_RESERVED_133;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_longitude,32);
+	    frm += 32;
+    }
+
 #if UMAC_SUPPORT_WNM
     bo->bo_fms_trailerlen = frm - bo->bo_fms_trailer;
 #endif /* UMAC_SUPPORT_WNM */
@@ -646,6 +658,7 @@
  *       that problem can be solved.
  */
     ieee80211_scan_table_update(vap,
+				NULL,
                                 (struct ieee80211_frame*)wh,
                                 frame_len,
                                 IEEE80211_FC0_SUBTYPE_BEACON,
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_ap.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_ap.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_ap.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_ap.c	2018-07-03 10:12:53.968984596 +0530
@@ -268,6 +268,27 @@
 	case IEEE80211_ELEMID_FT:
             ftcap = frm;
             break;
+        case IEEE80211_ELEMID_RESERVED_133:
+                if ( ni != NULL ) {
+                   printk(" %s:ni->ni_longitude:%s Element id 133, longitude recieved: %s \n",__func__,ni->ni_longitude,
+                        (u_int8_t *) ((struct ieee80211_ie_gps* )frm)->hc_coordinates);
+                   printk("sta MAC addr:%02x:%02x:%02x:%02x:%02x:%02x \n",
+                        ni->ni_macaddr[0],ni->ni_macaddr[1],ni->ni_macaddr[2],
+                        ni->ni_macaddr[3],ni->ni_macaddr[4],ni->ni_macaddr[5]);
+                   strncpy(ni->ni_longitude,((struct ieee80211_ie_gps* )frm)->hc_coordinates,32);
+                }
+            break;
+        case IEEE80211_ELEMID_RESERVED_47:
+                if ( ni != NULL ) {
+                   printk(" %s:ni->ni_latitude : %s Element id 47,latitude recieved: %s \n",__func__,ni->ni_latitude,
+                                (u_int8_t *) ((struct ieee80211_ie_gps* )frm)->hc_coordinates);
+                   printk("sta MAC addr:%02x:%02x:%02x:%02x:%02x:%02x \n",
+                        ni->ni_macaddr[0],ni->ni_macaddr[1],ni->ni_macaddr[2],
+                        ni->ni_macaddr[3],ni->ni_macaddr[4],ni->ni_macaddr[5]);
+                   strncpy(ni->ni_latitude,((struct ieee80211_ie_gps* )frm)->hc_coordinates,32);
+                }
+            break;
+
 
         case IEEE80211_ELEMID_VENDOR:
             if (iswpaoui(frm)) {
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt.c qca-wifi-mod/umac/mlme/ieee80211_mgmt.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt.c	2018-09-17 17:00:08.156185180 +0530
@@ -22,10 +22,20 @@
 #include "ieee80211_wifipos_pvt.h"
 #endif
 #include "dfs_ioctl.h"
+#include <linux/inetdevice.h>
+#include <linux/rtnetlink.h>
+
 /*
  * xmit management processing code.
  */
 
+/* KWN */
+extern int edma_get_mgmt_vlan_id( struct net_device *dev );
+
+unsigned int dg_ack_rcvd;
+unsigned int dg_seq;
+EXPORT_SYMBOL(dg_ack_rcvd);
+
 /*
  * Set the direction field and address fields of an outgoing
  * non-QoS frame.  Note this should be called early on in
@@ -597,7 +607,9 @@
     if (status == IEEE80211_STATUS_SUCCESS) {
         vap->iv_stats.mlme_auth_success++;
     }
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.aut_xmit++;
+#endif
     return ieee80211_send_mgmt(vap,ni, wbuf,false);
 }
 
@@ -692,7 +704,9 @@
         ieee80211_vap_set_complete_buf_handler(wbuf, handler, (void *)ni);
     }
 #endif
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.deaut_xmit++;
+#endif
     if (vap->iv_vap_is_down)
         return ieee80211_send_mgmt(vap, ni, wbuf, true);
     else
@@ -884,7 +898,9 @@
             frm = res;
         }
     }
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.disassoc_xmit++;
+#endif
     if (vap->iv_mesh_mgmt_txsend_config == 0)
     {
         wbuf_set_pktlen(wbuf, (frm - (u_int8_t *)wbuf_header(wbuf)));
@@ -921,6 +937,141 @@
             return 0;
     }
 }
+int get_default_ipaddr_by_devname(const char *devname)
+{
+	int addr;
+	struct net_device *dev;
+	if (!devname) return 0;
+	/* find netdev by name, increment refcnt */
+	dev=dev_get_by_name(&init_net,devname);
+	if (!dev) return 0;
+	/* get ip addr from rtable (global scope) */
+	addr = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);
+	/* decrement netdev refcnt */
+	dev_put(dev);
+	return addr;
+}
+
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap, u_int32_t send_ack, struct ieee80211_node *ack_ni)
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap) {
+            struct ieee80211_node   *ni = NULL; 
+            if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP && !send_ack) {
+                /* create temporary node for broadcast */
+                ni = ieee80211_tmp_node(vap, IEEE80211_GET_BCAST_ADDR(vap->iv_ic));
+            } else {
+		if ( send_ack ) {
+			ni = ack_ni;
+			//printk("use ack ni\n");
+		}
+		else {
+                	ni = vap->iv_bss;
+		}
+            }
+            if (ni != NULL) {
+                actionargs.category = IEEE80211_ACTION_CAT_VHT;
+                actionargs.action   = IEEE80211_ACTION_DYING_GASP;
+                actionargs.arg1     = send_ack;
+                actionargs.arg2     = 0;
+                actionargs.arg3     = 0;
+                ieee80211_send_action(ni, &actionargs, NULL);
+                if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP && !send_ack) {
+                    /* temporary node - decrement reference count so that the node will be
+                     * automatically freed upon completion */
+                    ieee80211_free_node(ni);
+                }
+            }
+    }
+}
+
+void ieee80211_send_uldl_limit( struct ieee80211vap *vap )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		struct ieee80211_node   *ni = NULL; 
+		if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+			/* create temporary node for broadcast */
+			ni = ieee80211_tmp_node( vap, IEEE80211_GET_BCAST_ADDR( vap->iv_ic ) );
+		}
+		else {
+			ni = vap->iv_bss;
+		}
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_LINK_PARAM;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+			if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+				/* temporary node - decrement reference count so that the node will be
+				 * automatically freed upon completion */
+				ieee80211_free_node( ni );
+			}
+		}
+	}
+}
+
+void ieee80211_send_node_stats( struct ieee80211vap *vap )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		struct ieee80211_node   *ni = NULL; 
+		if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+			/* create temporary node for broadcast */
+			ni = ieee80211_tmp_node( vap, IEEE80211_GET_BCAST_ADDR( vap->iv_ic ) );
+		}
+		else {
+			ni = vap->iv_bss;
+		}
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_NODE_STATS;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+			if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+				/* temporary node - decrement reference count so that the node will be
+				 * automatically freed upon completion */
+				ieee80211_free_node( ni );
+			}
+		}
+	}
+}
+
+void ieee80211_send_tput_test( struct ieee80211vap *vap )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		struct ieee80211_node   *ni = NULL; 
+		if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+			/* create temporary node for broadcast */
+			ni = ieee80211_tmp_node( vap, IEEE80211_GET_BCAST_ADDR( vap->iv_ic ) );
+		}
+		else {
+			ni = vap->iv_bss;
+		}
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_TPUT_TEST;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+			if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+				/* temporary node - decrement reference count so that the node will be
+				 * automatically freed upon completion */
+				ieee80211_free_node( ni );
+			}
+		}
+	}
+}
 
 int
 ieee80211_send_action(
@@ -1183,21 +1334,107 @@
     break;
 
     case IEEE80211_ACTION_CAT_VHT: {
-        struct ieee80211_action_vht_opmode *opmode_frame;
+        struct ieee80211_action_vht_opmode *frame_opmode;
+        struct ieee80211_action_vht_dying_gasp *frame;
+        struct ieee80211_action_vht_link_param *frame_lmt;
+        struct ieee80211_action_vht_node_stats *frame_stats;
+        struct ieee80211_action_vht_tput_test *frame_tput;
+        struct ieee80211_stats *iv_stats;
         enum ieee80211_cwm_width cw_width = ic->ic_cwm_get_width(ic);
-        IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
-                           "%s: VHT Op Mode Notify action frame. Width %d Nss = %d",
-                            __func__, cw_width, vap->iv_nss);
-        wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
-        if (wbuf == NULL) {
-            error = -ENOMEM;
-            break;
-        }
-        opmode_frame = (struct ieee80211_action_vht_opmode *)frm;
-        opmode_frame->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
-        opmode_frame->at_header.ia_action  = IEEE80211_ACTION_VHT_OPMODE;
-        ieee80211_add_opmode((u_int8_t *)&opmode_frame->at_op_mode, ni, ic, IEEE80211_ACTION_CAT_VHT);
-        frm += sizeof(struct ieee80211_action_vht_opmode);
+       
+	switch (actionargs->action) { 
+		case IEEE80211_ACTION_DYING_GASP:
+			wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
+			if (wbuf == NULL) {
+				error = -ENOMEM;
+				break;
+			}
+			frame = (struct ieee80211_action_vht_dying_gasp *)frm;
+			frame->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame->at_header.ia_action  = IEEE80211_ACTION_DYING_GASP;
+			if ( actionargs->arg1 == 0 ) {
+				frame->at_dying_gasp.type = DG_PKT_TYPE_INFORM;
+				frame->at_dying_gasp.ipv4 = get_default_ipaddr_by_devname("br-lan");
+				frame->at_dying_gasp.ts = jiffies;
+				frame->at_dying_gasp.seq_no = dg_seq++;
+				frame->at_dying_gasp.link_id = ic->ic_link_id;
+				strncpy(frame->at_dying_gasp.customer_name,ic->ic_customer_name,32);
+			}
+			else if ( actionargs->arg1 == 1 ) {
+				frame->at_dying_gasp.type = DG_PKT_TYPE_ACK;
+			}
+			frm += sizeof(struct ieee80211_action_vht_dying_gasp);
+			break;
+		case IEEE80211_ACTION_LINK_PARAM:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_lmt = ( struct ieee80211_action_vht_link_param * )frm;
+			frame_lmt->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_lmt->at_header.ia_action  = IEEE80211_ACTION_LINK_PARAM;
+			frame_lmt->at_uldl_limit.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			frame_lmt->at_uldl_limit.ul_limit = vap->kwn_ul_limit;
+			frame_lmt->at_uldl_limit.dl_limit = vap->kwn_dl_limit;
+			memcpy(frame_lmt->at_uldl_limit.customer_name,ic->ic_customer_name,sizeof(ic->ic_customer_name));
+			frame_lmt->at_uldl_limit.link_id = ic->ic_link_id;
+			frm += sizeof( struct ieee80211_action_vht_link_param );
+			break;
+		case IEEE80211_ACTION_NODE_STATS:
+			iv_stats = wlan_get_stats(vap);
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_stats = ( struct ieee80211_action_vht_node_stats * )frm;
+			frame_stats->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_stats->at_header.ia_action  = IEEE80211_ACTION_NODE_STATS;
+			frame_stats->at_node_stats.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			frame_stats->at_node_stats.snr_a1 = vap->kwn_local_snr_a1;
+			frame_stats->at_node_stats.snr_a2 = vap->kwn_local_snr_a2;
+			frame_stats->at_node_stats.noise_floor = vap->kwn_local_noise_floor;
+			frame_stats->at_node_stats.rx_tput_mbps = iv_stats->kwn_rx_tput_mbps;
+			frame_stats->at_node_stats.phy_err = vap->kwn_local_phy_err;
+			frame_stats->at_node_stats.mpdu_err = vap->kwn_local_mpdu_err;
+			frame_stats->at_node_stats.retries = vap->kwn_local_retries;
+			frm += sizeof( struct ieee80211_action_vht_node_stats );
+			break;
+		case IEEE80211_ACTION_TPUT_TEST:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_tput = ( struct ieee80211_action_vht_tput_test * )frm;
+			frame_tput->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_tput->at_header.ia_action  = IEEE80211_ACTION_TPUT_TEST;
+			frame_tput->at_tput_test.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			frame_tput->at_tput_test.start_stop = vap->kwn_tput_test_in_progress;
+			frame_tput->at_tput_test.duration = vap->kwn_tput_test_duration;
+			frame_tput->at_tput_test.pkt_size = vap->kwn_tput_test_pkt_size;
+			frame_tput->at_tput_test.cnt = vap->kwn_tput_test_pkt_per_ms;
+			frm += sizeof( struct ieee80211_action_vht_tput_test );
+			break;
+		case IEEE80211_ACTION_VHT_OPMODE:
+			IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
+					"%s: VHT Op Mode Notify action frame. Width %d Nss = %d",
+					__func__, cw_width, vap->iv_nss);
+			wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
+			if (wbuf == NULL) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_opmode = (struct ieee80211_action_vht_opmode *)frm;
+			frame_opmode->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_opmode->at_header.ia_action  = IEEE80211_ACTION_VHT_OPMODE;
+			ieee80211_add_opmode((u_int8_t *)&frame_opmode->at_op_mode, ni, ic, IEEE80211_ACTION_CAT_VHT);
+			frm += sizeof(struct ieee80211_action_vht_opmode);	
+			break;
+		default :
+			break;
+	}
     }
     break;
 
@@ -2241,6 +2478,7 @@
 }
 int
 ieee80211_parse_beacon(struct ieee80211vap                  *vap,
+		       struct ieee80211_node *ni,
                        struct ieee80211_beacon_frame        *beacon_frame,
                        const struct ieee80211_frame         *wh,
                        u_int32_t                            beacon_frame_length,
@@ -2404,6 +2642,9 @@
             scan_entry_parameters->ie_list.htcap = (u_int8_t *) &(((struct ieee80211_ie_htcap *) info_element)->hc_ie);
             break;
         case IEEE80211_ELEMID_RESERVED_47:
+		//printk(" subtype = %d ,latitude recieved: %s\n",subtype,(u_int8_t *)((struct ieee80211_ie_gps* )info_element)->hc_coordinates);
+		if ( ni != NULL )
+		   strncpy(ni->ni_latitude,((struct ieee80211_ie_gps* )info_element)->hc_coordinates,32);
             break;
         case IEEE80211_ELEMID_RSN:
             scan_entry_parameters->ie_list.rsn = (u_int8_t *) info_element;
@@ -2435,6 +2676,9 @@
             scan_entry_parameters->ie_list.extcaps = (u_int8_t *) info_element;
             break;
         case IEEE80211_ELEMID_RESERVED_133:
+		//printk(" subtype: %d longitude recieved: %s\n",subtype,(u_int8_t *)((struct ieee80211_ie_gps* )info_element)->hc_coordinates);
+		if ( ni != NULL )
+		   strncpy(ni->ni_longitude,((struct ieee80211_ie_gps* )info_element)->hc_coordinates,32);
             break;
         case IEEE80211_ELEMID_TPC:
             break;
@@ -2864,6 +3108,7 @@
     }
 
     scan_entry = ieee80211_scan_table_update(ni->ni_vap,
+					     ni,
                                              wh,
                                              wbuf_get_pktlen(wbuf),
                                              subtype,
@@ -3825,13 +4070,117 @@
 
                     ieee80211_parse_opmode(ni, (u_int8_t *)&ia_opmode->at_op_mode, subtype);
                 }
+		action_taken = FALSE;// set to false so that it is forwarded to hostapd
                 break;
+            case IEEE80211_ACTION_DYING_GASP: 
+                {
+#define IEEE80211_EV_DYING_GASP 45
+                    struct ieee80211_action_vht_dying_gasp *frame = (struct ieee80211_action_vht_dying_gasp *)frm;
+                    struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+                    union iwreq_data wreq = {{0}};
+                    u_int32_t ip = frame->at_dying_gasp.ipv4;
+
+                    if(frame->at_dying_gasp.type == DG_PKT_TYPE_INFORM ) {
+                        if (vap->iv_opmode == IEEE80211_M_HOSTAP && !vap->iv_ic->ic_dg_ack_disable) {
+                            ieee80211_send_dying_gasp( vap , 1, ni);
+                            //printk("\n:dying gasp ack sent---> \n");
+                        }
+                        printk("(%9lu)[Remote Time stamp : %9lu][Cus name:%s][Link id:%d][%d.%d.%d.%d] Seq No:%d --> Recv pkts %d \n",
+                                jiffies,frame->at_dying_gasp.ts, frame->at_dying_gasp.customer_name,frame->at_dying_gasp.link_id,
+                                (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF,
+                                frame->at_dying_gasp.seq_no,ni->dg_count++);
+
+                        /* Send an event to apl as dying gasp packet received for logging */
+                        memset(&wreq, 0, sizeof(wreq));
+                        wreq.addr.sa_family = ARPHRD_ETHER;
+                        memcpy(wreq.addr.sa_data, ni->ni_macaddr, 6);
+                        wreq.addr.sa_data[6] = IEEE80211_EV_DYING_GASP;
+                        wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+                    }
+                    else if (frame->at_dying_gasp.type == DG_PKT_TYPE_ACK ) {
+                        dg_ack_rcvd = 1;
+                    }
+                    dev_put(dev);
+		}
+		break;
+	    case IEEE80211_ACTION_LINK_PARAM: 
+		{
+			struct ieee80211_action_vht_link_param *frame_lmt = (struct ieee80211_action_vht_link_param *)frm;
+			u_int32_t ip = frame_lmt->at_uldl_limit.ipv4;
+			/* printk("######### Received [Uplink Limit:%d][Downlink Limit:%d][%d.%d.%d.%d] ##############\n",
+					frame_lmt->at_uldl_limit.ul_limit,frame_lmt->at_uldl_limit.dl_limit,
+					(ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF); */
+			if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+				vap->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit > vap->kwn_ul_limit ? 
+					vap->kwn_ul_limit : frame_lmt->at_uldl_limit.ul_limit;
+				vap->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit > vap->kwn_dl_limit ? 
+					vap->kwn_dl_limit : frame_lmt->at_uldl_limit.dl_limit;
+				ieee80211_send_uldl_limit( vap );
+			}
+			else {
+				vap->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit;
+				vap->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit;
+			}
+			memcpy(ni->customer_name, frame_lmt->at_uldl_limit.customer_name, sizeof(frame_lmt->at_uldl_limit.customer_name));
+			ni->link_id = frame_lmt->at_uldl_limit.link_id;
+			printk("After negotiation[%d.%d.%d.%d], Uplink Limit %d Downlink Limit %d \n",
+                (ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF, 
+                vap->kwn_ul_limit,vap->kwn_dl_limit);
+		}
+		break;
+	    case IEEE80211_ACTION_NODE_STATS: 
+		{
+			struct ieee80211_action_vht_node_stats *frame_stats = (struct ieee80211_action_vht_node_stats *)frm;
+#if 0
+			u_int32_t ip = frame_stats->at_node_stats.ipv4;
+			printk("######### Received Local [SNR1:%d][SNR2:%d] Remote [SNR1:%d][SNR2:%d][%d.%d.%d.%d] ##############\n",
+					vap->local_snr_a1,vap->local_snr_a2,
+					frame_stats->at_node_stats.snr_a1,frame_stats->at_node_stats.snr_a2,
+					(ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF);
+#endif
+                        ni->remote_snr_a1 = frame_stats->at_node_stats.snr_a1;
+                        ni->remote_snr_a2 = frame_stats->at_node_stats.snr_a2;
+                        ni->remote_noise_floor = frame_stats->at_node_stats.noise_floor;
+                        ni->ip_addr = frame_stats->at_node_stats.ipv4;
+                        ni->tx_tput_mbps = frame_stats->at_node_stats.rx_tput_mbps;
+                        ni->remote_phy_err = frame_stats->at_node_stats.phy_err;
+                        ni->remote_mpdu_err = frame_stats->at_node_stats.mpdu_err;
+                        ni->remote_retries = frame_stats->at_node_stats.retries;
+		}
+		break;
+	    case IEEE80211_ACTION_TPUT_TEST: 
+		{
+			struct ieee80211_action_vht_tput_test *frame_tput = (struct ieee80211_action_vht_tput_test *)frm;
+#if 0
+			u_int32_t ip = frame_tput->at_tput_test.ipv4;
+			printk("######### Received [value:%d] [%d.%d.%d.%d] ##############\n",
+					frame_tput->at_tput_test.start_stop,
+					(ip & 0xFF),(ip >> 8) & 0xFF,(ip >> 16 ) & 0xFF,(ip >> 24) & 0xFF);
+            printk("########Mac addrss : %s########\n",ether_sprintf(ni->ni_macaddr));
+#endif
+	if ( frame_tput->at_tput_test.start_stop ) {
+		printk("\n Start Test ...\n");
+        IEEE80211_ADDR_COPY(vap->kwn_tput_test_mac, ni->ni_macaddr);
+		vap->kwn_tput_test_duration = frame_tput->at_tput_test.duration;
+		vap->kwn_tput_test_pkt_size = frame_tput->at_tput_test.pkt_size;
+		vap->kwn_tput_test_pkt_per_ms = frame_tput->at_tput_test.cnt;
+		vap->kwn_tput_test_start_time = jiffies;
+		vap->kwn_tput_test_in_progress = 1;
+		vap->kwn_tput_test_from_app = 1;
+		tasklet_schedule(&vap->kwn_tput_tq);
+	} else {
+		printk("\n Stop Test...\n");
+		vap->kwn_tput_test_start_time = 0;
+		vap->kwn_tput_test_in_progress = 0;
+		vap->kwn_tput_test_from_app = 0;
+	}
+		}
+		break;
             default:
                 IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
                         "%s: Unhandled OR invalid VHT action code - %d", __func__, ia->ia_action);
                 break;
         }
-        action_taken = FALSE; // set to false so that it is forwarded to hostapd
         break;
     }
 
@@ -4002,6 +4351,10 @@
     switch (subtype) {
     case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
     case IEEE80211_FC0_SUBTYPE_BEACON:
+#ifdef SIFY_MGMT_STATS
+        if( subtype == IEEE80211_FC0_SUBTYPE_BEACON )
+            vap->iv_mgmt_stats.bcn_recv++;
+#endif
         ieee80211_recv_beacon(ni, wbuf, subtype, rs);
         /*store all received beacon info*/
         if(vap->iv_beacon_info_count>=100)
@@ -4092,6 +4445,9 @@
         break;
 
     case IEEE80211_FC0_SUBTYPE_AUTH:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.aut_recv++;
+#endif
 #if ATH_NON_BEACON_AP
         if(IEEE80211_VAP_IS_NON_BEACON_ENABLED(vap)){
             /*Don't response to auth for non-beaconing AP VAP*/
@@ -4107,10 +4463,34 @@
     case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
     case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:
         ieee80211_recv_asresp(ni, wbuf, subtype);
-        break;
+	/* Configure MgmtVLAN if enabled */
+	{
+
+		struct net_device *eth_dev;
+		int vlan = 0;
+		eth_dev = dev_get_by_name( &init_net, "eth0" );
+		if ( eth_dev ) {
+			vlan = edma_get_mgmt_vlan_id( eth_dev );
+			printk(": MgmtVlan: %d Vlan: %d\n", vap->kwn_mgmt_vlan_id, vlan);
+			vap->kwn_mgmt_vlan_id = vlan;
+			memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+			printk(": Eth0MAC: %0x:%0x:%0x:%0x:%0x:%0x \n",
+					vap->kwn_eth_mac_addr[0],
+					vap->kwn_eth_mac_addr[1],
+					vap->kwn_eth_mac_addr[2],
+					vap->kwn_eth_mac_addr[3],
+					vap->kwn_eth_mac_addr[4],
+					vap->kwn_eth_mac_addr[5]);
+			dev_put( eth_dev );
+		}
+	}
+	break;
 
     case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
     case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.assoc_recv++;
+#endif
 #if ATH_NON_BEACON_AP
         if(IEEE80211_VAP_IS_NON_BEACON_ENABLED(vap)){
             /*Don't response to auth for non-beaconing AP VAP*/
@@ -4158,13 +4538,40 @@
 #endif
         if (ieee80211_recv_asreq(ni, wbuf, subtype) == -EBUSY)
             forward_to_filter = 0;
-        break;
+	/* Configure MgmtVLAN if enabled */
+	{
+
+		struct net_device *eth_dev;
+		int vlan = 0;
+		eth_dev = dev_get_by_name( &init_net, "eth0" );
+		if ( eth_dev ) {
+			vlan = edma_get_mgmt_vlan_id( eth_dev );
+			printk(": MgmtVlan: %d Vlan: %d\n", vap->kwn_mgmt_vlan_id, vlan);
+			vap->kwn_mgmt_vlan_id = vlan;
+			memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+			printk(": Eth0MAC: %0x:%0x:%0x:%0x:%0x:%0x \n",
+					vap->kwn_eth_mac_addr[0],
+					vap->kwn_eth_mac_addr[1],
+					vap->kwn_eth_mac_addr[2],
+					vap->kwn_eth_mac_addr[3],
+					vap->kwn_eth_mac_addr[4],
+					vap->kwn_eth_mac_addr[5]);
+			dev_put( eth_dev );
+		}
+	}
+	break;
 
     case IEEE80211_FC0_SUBTYPE_DEAUTH:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.deaut_recv++;
+#endif
         ieee80211_recv_deauth(ni, wbuf, subtype);
         break;
 
     case IEEE80211_FC0_SUBTYPE_DISASSOC:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.disassoc_recv++;
+#endif
         ret = ieee80211_recv_disassoc(ni, wbuf, subtype);
         if(ret){
             /*Something wrong, don't fwd to filter*/
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_sta.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_sta.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_sta.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_sta.c	2018-08-22 16:31:38.123887700 +0530
@@ -1074,6 +1074,17 @@
 	frm = ieee80211_add_extender_ie(vap, IEEE80211_FRAME_TYPE_ASSOCREQ, frm);
     }
 #endif
+     /* Update latitude and longitude info if valid*/
+    if ( (strlen(ic->ic_latitude) != 0 ) && (strlen(ic->ic_longitude) != 0 ) ) {	
+	    *frm++ = IEEE80211_ELEMID_RESERVED_47;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_latitude,32);
+	    frm += 32;
+	    *frm++ = IEEE80211_ELEMID_RESERVED_133;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_longitude,32);
+	    frm += 32;
+    }
 
     return (frm - (u_int8_t *)wh);
 }
@@ -1094,6 +1105,9 @@
     if (wbuf == NULL)
         return -ENOMEM;
 
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.assoc_xmit++;
+#endif
     length = ieee80211_setup_assoc(ni, (struct ieee80211_frame *)wbuf_header(wbuf),
                                    reassoc, prev_bssid);
 
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme_ap.c qca-wifi-mod/umac/mlme/ieee80211_mlme_ap.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme_ap.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme_ap.c	2018-08-22 16:31:47.219888027 +0530
@@ -251,6 +251,17 @@
     }
 
 end:
+#ifdef SIFY_MGMT_STATS  
+    if (assocstatus != IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.assoc_reject_xmit++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.assoc_confirm_xmit++;
+    }
+    vap->iv_mgmt_stats.assoc_reason = assocstatus;
+#endif
     /* Now send the notification and remove the node if needed */
     if (reassoc) {
         IEEE80211_DELIVER_EVENT_MLME_REASSOC_INDICATION(vap, ni->ni_macaddr,
@@ -960,7 +971,17 @@
         if (indication_status != IEEE80211_STATUS_SUCCESS ){
             /* auth is not success, remove the node from node table*/
             IEEE80211_NODE_LEAVE(ni);
+#ifdef SIFY_MGMT_STATS
+            vap->iv_mgmt_stats.aut_reject_xmit++;
+#endif
         }
+#ifdef SIFY_MGMT_STATS
+        else
+        {
+            vap->iv_mgmt_stats.aut_confirm_xmit++;
+        }
+        vap->iv_mgmt_stats.auth_reason = indication_status;
+#endif
     }
 
 #if UMAC_SUPPORT_ACL
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme_sta.c qca-wifi-mod/umac/mlme/ieee80211_mlme_sta.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme_sta.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme_sta.c	2018-08-22 16:31:54.999888307 +0530
@@ -655,6 +655,18 @@
         error = mlme_process_timeout_interval_elements(ni, ie_data, ie_length);
     }
 
+#ifdef SIFY_MGMT_STATS
+    if (status_code != IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.assoc_reject_recv++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.assoc_confirm_recv++;
+    }
+    vap->iv_mgmt_stats.assoc_reason = status_code;
+#endif
+
     /* indicate linkspeed */
      mlme_get_linkrate(ni, &rxlinkspeed, &txlinkspeed);
      IEEE80211_DELIVER_EVENT_LINK_SPEED(vap, rxlinkspeed, txlinkspeed);
@@ -672,6 +684,8 @@
     default:
         break;
     }
+    /* Once Link is established, Send the UL DL Limit values to Base */
+    ieee80211_send_uldl_limit( vap );
 }
 
 /* Send association or reassociation request */
@@ -1295,6 +1309,17 @@
     }
 
     IEEE80211_DPRINTF(vap, IEEE80211_MSG_MLME, "%s: mlme_auth_complete\n", __func__);
+#ifdef SIFY_MGMT_STATS
+    if (status_code == IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.aut_confirm_recv++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.aut_reject_recv++;
+    }
+    vap->iv_mgmt_stats.auth_reason = status_code;
+#endif
 
     /* Request complete */
     mlme_priv->im_request_type = MLME_REQ_NONE;
diff -urN qca-wifi-org/umac/scan/ieee80211_scanentry.c qca-wifi-mod/umac/scan/ieee80211_scanentry.c
--- qca-wifi-org/umac/scan/ieee80211_scanentry.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/scan/ieee80211_scanentry.c	2018-07-03 10:12:53.972984595 +0530
@@ -2048,6 +2048,7 @@
 
 struct ieee80211_scan_entry *
 ieee80211_scan_table_update(struct ieee80211vap          *vap,
+			    struct ieee80211_node *ni,
                             struct ieee80211_frame *wh,
                             u_int32_t                    frame_length,
                             int                          subtype,
@@ -2070,6 +2071,7 @@
      * Parse and validate the beacon first
      */
     if (ieee80211_parse_beacon(vap,
+			       ni,
                                beacon_frame,
                                wh,
                                beacon_length,
