diff -urN qca-wifi-org/cmn_dev/dp/inc/cdp_txrx_stats_struct.h qca-wifi-mod/cmn_dev/dp/inc/cdp_txrx_stats_struct.h
--- qca-wifi-org/cmn_dev/dp/inc/cdp_txrx_stats_struct.h	2018-06-08 10:23:13.000000000 +0530
+++ qca-wifi-mod/cmn_dev/dp/inc/cdp_txrx_stats_struct.h	2018-07-03 13:48:45.221216000 +0530
@@ -505,7 +505,13 @@
 	OL_ATH_PARAM_CHAN_FREE  = 366,
 	OL_ATH_PARAM_CHAN_AP_TX_UTIL = 367,
 	OL_ATH_PARAM_CHAN_OBSS_RX_UTIL  =368,
-
+	OL_ATH_PARAM_TXDISTANCE = 369,
+	OL_ATH_PARAM_DYING_GASP = 370,
+	OL_ATH_PARAM_DG_TIMER_INTERVAL = 371,
+	OL_ATH_PARAM_DG_ACK_DISABLE = 372,
+	OL_ATH_PARAM_LINKID = 373,
+	OL_ATH_PARAM_STR_TYPE = 374,
+	OL_ATH_PARAM_KWN_AMSDU = 375
 } ol_ath_param_t;
 
 /*
diff -urN qca-wifi-org/cmn_dev/wmi/src/wmi_unified_non_tlv.c qca-wifi-mod/cmn_dev/wmi/src/wmi_unified_non_tlv.c
--- qca-wifi-org/cmn_dev/wmi/src/wmi_unified_non_tlv.c	2018-06-08 10:23:13.000000000 +0530
+++ qca-wifi-mod/cmn_dev/wmi/src/wmi_unified_non_tlv.c	2018-12-28 19:30:21.894263094 +0530
@@ -3728,10 +3728,14 @@
 		wmep = &param->wmep_array[ac];
 		switch (ac) {
 		case WME_AC_BE:
-			wmi_param = &cmd->wmm_params_ac_be;
-			break;
-		case WME_AC_BK:
-			wmi_param = &cmd->wmm_params_ac_bk;
+            wmi_param = &cmd->wmm_params_ac_be;
+            /* KWN */
+            //wmep = &param->wmep_array[WME_AC_BE];
+            break;
+        case WME_AC_BK:
+            wmi_param = &cmd->wmm_params_ac_bk;
+            /* KWN */
+            //wmep = &param->wmep_array[WME_AC_BE];
 			break;
 		case WME_AC_VI:
 			wmi_param = &cmd->wmm_params_ac_vi;
@@ -3750,6 +3754,14 @@
 		wmi_param->acm = wmep->wmep_acm;
 		wmi_param->no_ack = wmep->wmep_noackPolicy;
 
+        printk(": AC: %d AIFS: %d CWMIN: %d CWMAX: %d TxOpLimit: %d ACM: %d NoAck: %d\n",
+                ac,
+                wmi_param->aifs,
+                wmi_param->cwmin,
+                wmi_param->cwmax,
+                wmi_param->txoplimit,
+                wmi_param->acm,
+                wmi_param->no_ack);
 	}
 
 	wmi_unified_cmd_send(wmi_handle, buf, len,
diff -urN qca-wifi-org/include/ieee80211_api.h qca-wifi-mod/include/ieee80211_api.h
--- qca-wifi-org/include/ieee80211_api.h	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/include/ieee80211_api.h	2019-03-20 20:26:34.281506647 +0530
@@ -1042,6 +1042,7 @@
  *      pointer to RSN IE.
  */
 u_int8_t *wlan_scan_entry_rsn(wlan_scan_entry_t scan_entry);
+u_int8_t wlan_scan_entry_linktype(wlan_scan_entry_t scan_entry);
 
 /**
  * get WPA info .
diff -urN qca-wifi-org/include/ieee80211_defines.h qca-wifi-mod/include/ieee80211_defines.h
--- qca-wifi-org/include/ieee80211_defines.h	2018-06-08 11:00:51.000000000 +0530
+++ qca-wifi-mod/include/ieee80211_defines.h	2018-11-27 11:39:59.282564389 +0530
@@ -14,6 +14,7 @@
 #ifndef _IEEE80211_DEFINES_H_
 #define _IEEE80211_DEFINES_H_
 
+#define SIFY_MGMT_STATS
 #include <ieee80211.h>
 #ifndef EXTERNAL_USE_ONLY
 #include <_ieee80211.h>        /* IEEE80211_ADDR_LEN, iee80211_phymode */
@@ -1913,6 +1914,32 @@
     u_int32_t   chan_tx_power_range;     /* EEPROM Tx power value for Maximum range*/
 };
 
+#ifdef SIFY_MGMT_STATS
+struct ieee80211_mgmt_stats
+{
+	u_int64_t                         bcn_recv;
+	u_int64_t                         assoc_xmit;
+	u_int64_t                         assoc_recv;
+	u_int64_t                         assoc_reject_recv;
+	u_int64_t                         assoc_reject_xmit;    
+	u_int64_t                         assoc_confirm_recv;  
+	u_int64_t                         assoc_confirm_xmit;
+	u_int64_t                         disassoc_xmit;
+	u_int64_t                         disassoc_recv;                                      
+	u_int64_t                         aut_xmit;
+	u_int64_t                         aut_recv;
+	u_int64_t                         aut_confirm_recv;
+	u_int64_t                         aut_confirm_xmit;    
+	u_int64_t                         aut_reject_recv;
+	u_int64_t                         aut_reject_xmit;        
+	u_int64_t                         deaut_xmit;
+	u_int64_t                         deaut_recv;
+	u_int64_t                         reg_fail_last_reason;
+    u_int32_t                         assoc_reason;
+	u_int32_t                         auth_reason;    
+	u_int64_t                         iv_opmode;
+};
+#endif
 struct ieee80211_mac_stats {
     u_int64_t   ims_tx_packets; /* frames successfully transmitted */
     u_int64_t   ims_rx_packets; /* frames successfully received */
@@ -2068,6 +2095,7 @@
     u_int64_t   total_invalid_macaddr_nodealloc_failcnt; /* number of invalid mac addr node alloc fail count */
     u_int64_t   tx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
     u_int64_t   tx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+    u_int64_t   tx_byte_drop_cnt; /* no of bytes dropped to umac for Tx*/
     u_int64_t   mgmt_tx_fail_cnt;       /* no of pkts for which mgmt Tx failed */
     u_int64_t   sta_xceed_rlim;            /* no of connections refused after radio limit */
     u_int64_t   sta_xceed_vlim;            /* no of connections refused after vap limit */
@@ -2075,6 +2103,12 @@
     u_int64_t   mlme_auth_success;         /* no of 802.11 MLME Auth Success */
     u_int64_t   authorize_attempt;         /* no of Authorization Attempt */
     u_int64_t   authorize_success;         /* no of Authorization successful */
+    u_int64_t   kwn_tx_tput_mbps;
+    u_int64_t   kwn_tx_tput_last_jiffies;
+    u_int64_t   rx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+    u_int64_t   rx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+    u_int64_t   kwn_rx_tput_mbps;
+    u_int64_t   kwn_rx_tput_last_jiffies;
 };
 
 typedef enum _ieee80211_send_frame_type {
diff -urN qca-wifi-org/include/_ieee80211.h qca-wifi-mod/include/_ieee80211.h
--- qca-wifi-org/include/_ieee80211.h	2018-06-08 11:00:51.000000000 +0530
+++ qca-wifi-mod/include/_ieee80211.h	2018-11-14 14:06:48.946431080 +0530
@@ -208,8 +208,8 @@
 };
 
 #define	IEEE80211_NWID_LEN	32
-#define IEEE80211_CHAN_MAX      1023
-#define IEEE80211_CHAN_BYTES    128      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
+#define IEEE80211_CHAN_MAX      (1023*2)
+#define IEEE80211_CHAN_BYTES    (128*2)      /* howmany(IEEE80211_CHAN_MAX, NBBY) */
 #define IEEE80211_CHAN_ANY      (-1)    /* token for ``any channel'' */
 #define IEEE80211_CHAN_ANYC \
         ((struct ieee80211_channel *) IEEE80211_CHAN_ANY)
@@ -701,6 +701,14 @@
 #endif
 };
 
+struct kwn_chanutil_info {
+    u_int32_t    rx_clear_count;
+    u_int32_t    cycle_count;
+    u_int8_t     value; 
+    u_int32_t    total;
+    u_int32_t    count;
+};
+
 enum ieee80211_vendor_ie_param {
     IEEE80211_VENDOR_IE_PARAM_ADD = 0,
     IEEE80211_VENDOR_IE_PARAM_UPDATE,
diff -urN qca-wifi-org/include/ieee80211.h qca-wifi-mod/include/ieee80211.h
--- qca-wifi-org/include/ieee80211.h	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/include/ieee80211.h	2019-05-06 14:17:29.435551936 +0530
@@ -768,6 +768,15 @@
 #define IEEE80211_ACTION_TPC_REQUEST        2   /* Transmit Power control */
 #define IEEE80211_ACTION_TPC_REPORT         3
 #define IEEE80211_ACTION_CHAN_SWITCH        4   /* 802.11h Channel Switch Announcement */
+#define IEEE80211_ACTION_DYING_GASP         5   /* Dying Gasp */
+#define IEEE80211_ACTION_LINK_PARAM         6   /* Link param */
+#define IEEE80211_ACTION_NODE_STATS         7   /* Node Stats */
+#define IEEE80211_ACTION_TPUT_TEST          8   /* Tput Test */
+#define IEEE80211_ACTION_SCAN_ENTRIES       9   /* Scan Entries */
+#define IEEE80211_ACTION_TX_PARAMS          10  /* Tx params */
+#define IEEE80211_ACTION_TPUT_TEST_STATS    11  /* Tput Test stats */
+#define IEEE80211_ACTION_TXBA_SETUP         12   /* TX BA SETUP */
+#define IEEE80211_ACTION_CLEAR_NODE_STATS   13   /* Clear Node Stats */
 
 /* HT actions */
 #define IEEE80211_ACTION_HT_TXCHWIDTH       0   /* recommended transmission channel width */
@@ -840,6 +849,146 @@
         struct ieee80211_ie_op_mode opmode;
 } __packed;
 
+#define DG_PKT_TYPE_INFORM 1
+#define DG_PKT_TYPE_ACK	   2
+#define KWN_SCAN_ENTRY_MAX 100
+
+struct ieee80211_tx_param {
+    int16_t  	chan;
+    int8_t  	txpower;
+    int8_t  	rate;
+} __packed;
+
+/* VHT - Tx params */
+struct ieee80211_action_vht_tx_params {
+    struct ieee80211_action    at_header;
+    struct ieee80211_tx_param  at_tx_param;
+} __packed;
+
+struct ieee80211_scan_actionentry {
+    u_int8_t  	channel; 
+    u_int16_t  	frequency; 
+    u_int8_t  	rssi; 
+} __packed;
+
+struct ieee80211_scan_actionentries {
+    u_int8_t  	count;
+    struct ieee80211_scan_actionentry entry[ KWN_SCAN_ENTRY_MAX ];
+} __packed;
+
+/* VHT - Scan Entries */
+struct ieee80211_action_vht_scan_entries {
+    struct ieee80211_action    at_header;
+    struct ieee80211_scan_actionentries at_scan_entry;
+} __packed;
+
+struct ieee80211_clear_node_stats {
+    u_int8_t clear_node_stats;
+} __packed;
+
+struct ieee80211_action_vht_clear_node_stats {
+    struct ieee80211_action    at_header;
+    struct ieee80211_clear_node_stats at_clear_node_stats;
+} __packed;
+
+struct ieee80211_txba_setup {
+    u_int8_t start_txba;
+    u_int32_t pkt_per_ms;
+    u_int32_t pkt_size;
+} __packed;
+
+/* VHT - Start TXBA */
+struct ieee80211_action_vht_txba_setup {
+    struct ieee80211_action    at_header;
+    struct ieee80211_txba_setup at_txba_setup;
+} __packed;
+
+struct ieee80211_tput_test_stats {
+    u_int64_t rx_seq;
+    u_int64_t rx_failed_cnt;
+} __packed;
+
+/* VHT - TPUT Test stats*/
+struct ieee80211_action_vht_tput_test_stats {
+    struct ieee80211_action    at_header;
+    struct ieee80211_tput_test_stats at_tput_test_stats;
+} __packed;
+
+struct ieee80211_tput_test {
+    u_int8_t  	ipv4[20];
+    u_int8_t  	start_stop; 
+    u_int32_t  	duration; 
+    u_int32_t  	pkt_size; 
+    u_int32_t  	cnt;
+    u_int32_t   pkt_cnt;
+    u_int8_t  	ms_timer; 
+} __packed;
+
+/* VHT - TPUT Test*/
+struct ieee80211_action_vht_tput_test {
+    struct ieee80211_action    at_header;
+    struct ieee80211_tput_test at_tput_test;
+} __packed;
+
+struct ieee80211_node_stats {
+    u_int8_t  	ipv4[20];
+    u_int8_t    snr_avg[ 2 ];
+    u_int64_t   rx_tput_mbps;
+    u_int32_t  	phy_err; 
+    u_int32_t  	mpdu_err; 
+    u_int64_t  	retries; 
+    int16_t  	noise_floor; 
+    u_int8_t    rtx;
+    u_int8_t    tx_pwr;
+    u_int8_t    tx_chainmask;
+    u_int64_t   tx_tput_mbps;
+    u_int32_t   tx_data;
+    u_int32_t   rx_data;
+    u_int8_t    stream;
+} __packed;
+
+/* VHT - Node Stats*/
+struct ieee80211_action_vht_node_stats {
+    struct ieee80211_action     at_header;
+    struct ieee80211_node_stats at_node_stats;
+} __packed;
+
+struct ieee80211_link_param {
+    u_int8_t  	ipv4[20];
+    u_int32_t  	ul_limit; 
+    u_int32_t  	dl_limit; 
+    u_int8_t	link_id[16];
+    u_int8_t	customer_name[33];
+    u_int8_t	antenna_gain;
+    u_int8_t    kwn_assem_frag;
+    u_int16_t   kwn_max_pkt_size;
+    u_int16_t   kwn_frag_pkt_size;
+    u_int8_t	kwn_macinmac;
+    u_int8_t    kwn_linktype;
+    u_int8_t    kwn_shaping;
+} __packed;
+
+/* VHT - exchange param */
+struct ieee80211_action_vht_link_param {
+    struct ieee80211_action     at_header;
+    struct ieee80211_link_param at_uldl_limit;
+} __packed;
+
+struct ieee80211_dying_gasp_ie {
+    u_int8_t    type;
+    u_int8_t	link_id[16];
+    u_int16_t	seq_no;
+    u_long   	ts;
+    u_int8_t  	ipv4[20];
+    u_int8_t	customer_name[33];
+    
+} __packed;
+
+/* VHT - Dying gasp*/
+struct ieee80211_action_vht_dying_gasp {
+    struct ieee80211_action     at_header;
+    struct ieee80211_dying_gasp_ie at_dying_gasp;
+} __packed;
 
 /* VHT - recommended Channel width and Nss */
 struct ieee80211_action_vht_opmode {
@@ -1243,6 +1392,14 @@
 } __packed;
 
 /*
+ * GPS IE
+ */
+struct ieee80211_ie_gps {
+    u_int8_t                         hc_id;      /* element ID */
+    u_int8_t                         hc_len;     /* length in bytes */
+    u_int8_t    		     hc_coordinates[32];
+} __packed;
+/*
  * 802.11n HT Capability IE
  */
 struct ieee80211_ie_htcap {
@@ -1563,6 +1720,7 @@
     IEEE80211_ELEMID_FILS_INDICATION  = 240,
     IEEE80211_ELEMID_DILS             = 241,
     IEEE80211_ELEMID_FRAGMENT         = 242,
+    IEEE80211_ELEMID_LINKTYPE         = 243,
     IEEE80211_ELEMID_EXTENSION        = 255
 };
 
@@ -2734,7 +2892,8 @@
 
 // Factor used to convert airtime between user space and driver
 #define ATF_AIRTIME_CONVERSION_FACTOR 10
-#define IEEE80211_MAX_IFNAME 16
+#define IEEE80211_MAX_IFNAME          16
+#define KWN_CHAN_MAX                  250
 
 struct ieee80211_clone_params {
 	char		icp_name[IEEE80211_MAX_IFNAME];	/* device name */
@@ -2745,6 +2904,33 @@
     u_int8_t icp_mataddr[IEEE80211_ADDR_LEN];    /* optional MAT address */
 };
 
+struct kwn_acs_entries {
+    u_int8_t  channel;
+    u_int16_t frequency;
+    u_int8_t  utility;
+    u_int8_t  blacklist;
+    u_int64_t jiffies;
+};
+
+struct kwn_acs_result {
+    struct kwn_acs_entries acs_entry[ KWN_CHAN_MAX ];
+    u_int8_t cnt;
+};
+
+struct kwn_sa_scan_entries {
+    u_int8_t  channel;
+    u_int16_t frequency;
+    u_int8_t  utility;
+    int16_t   noise;
+    int16_t   pow_chain0;
+    int16_t   pow_chain1;
+};
+
+struct kwn_sa_scan_result {
+    struct kwn_sa_scan_entries sa_entry[ KWN_CHAN_MAX ];
+    u_int8_t cnt;
+};
+
 #define	    IEEE80211_CLONE_BSSID       0x0001		/* allocate unique mac/bssid */
 #define	    IEEE80211_NO_STABEACONS	    0x0002		/* Do not setup the station beacon timers */
 #define    IEEE80211_CLONE_WDS          0x0004      /* enable WDS processing */
@@ -2813,6 +2999,42 @@
         u_int8_t isi_tx_rate_mcs;
         u_int8_t isi_tx_rate_flags;
 #endif
+        u_int8_t isi_r_latitude[16];
+        u_int8_t isi_r_longitude[16];
+        u_int8_t isi_l_latitude[16];
+        u_int8_t isi_l_longitude[16];
+        u_int64_t isi_tx_tput;             /* Tx Thput */
+        u_int64_t isi_rx_tput;             /* Rx Thput */
+        u_int8_t isi_local_snr_a1;        /* Local SNR A1 */
+        u_int8_t isi_local_snr_a2;        /* Local SNR A2 */
+        u_int8_t isi_remote_snr_a1;        /* Remote SNR A1 */
+        u_int8_t isi_remote_snr_a2;        /* Remote SNR A2 */
+        u_int8_t  isi_ip_addr[20];
+        u_int32_t isi_local_phy_err;        /* Local Phy Err */
+        u_int32_t isi_remote_phy_err;       /* Remote Phy Err */
+        u_int32_t isi_local_mpdu_err;       /* Local MPDU Err */
+        u_int32_t isi_remote_mpdu_err;      /* Remote MPDU Err */
+        u_int32_t isi_local_retries;        /* Local Retries */
+        u_int32_t isi_remote_retries;       /* Remote Retries */
+        u_int8_t  isi_l_customer_name[33];
+        u_int8_t  isi_r_customer_name[33];
+        u_int8_t  isi_l_link_id[16];
+        u_int8_t  isi_r_link_id[16];
+        int16_t   isi_l_noise_floor;
+        int16_t   isi_r_noise_floor;
+        u_int8_t  isi_kwn_tx_rate_mcs;
+        u_int8_t  isi_l_ant_gain;
+        u_int8_t  isi_r_ant_gain;
+        u_int32_t isi_l_bw_limit;
+        u_int32_t isi_r_bw_limit;
+        u_int8_t  isi_l_rtx;
+        u_int8_t  isi_r_rtx;
+        u_int8_t  isi_l_tx_power;
+        u_int8_t  isi_r_tx_power;
+        u_int32_t isi_l_tx_data;
+        u_int32_t isi_l_rx_data;
+        u_int32_t isi_r_tx_data;
+        u_int32_t isi_r_rx_data;
 
 };
 
diff -urN qca-wifi-org/lmac/spectral/spectral_cmds.c qca-wifi-mod/lmac/spectral/spectral_cmds.c
--- qca-wifi-org/lmac/spectral/spectral_cmds.c	2018-06-08 11:00:35.000000000 +0530
+++ qca-wifi-mod/lmac/spectral/spectral_cmds.c	2019-03-16 15:18:08.293266931 +0530
@@ -114,6 +114,8 @@
     spectral->classify_scan                 = 0;
     spectral->num_spectral_data             = 0;
     spectral->sc_spectral_scan              = 1;
+    spectral->sc_spectral_noise_pwr_cal     = 1;
+    spectral->params.ss_spectral_pri        = 1;    /* Reset Priority */
 
     p_sops->start_spectral_scan(spectral);
 }
diff -urN qca-wifi-org/lmac/spectral/spectral.h qca-wifi-mod/lmac/spectral/spectral.h
--- qca-wifi-org/lmac/spectral/spectral.h	2018-06-08 11:00:35.000000000 +0530
+++ qca-wifi-mod/lmac/spectral/spectral.h	2019-03-16 15:17:56.373308337 +0530
@@ -859,7 +859,7 @@
 extern int spectral_dump_header(SPECTRAL_PHYERR_HDR* phdr);
 extern int spectral_send_tlv_to_host(struct ath_spectral* spectral, u_int8_t* data, u_int32_t datalen);
 extern int spectral_process_phyerr(struct ath_spectral* spectral, u_int8_t* data, u_int32_t datalen, SPECTRAL_RFQUAL_INFO* p_rfqual,
-                              SPECTRAL_CHAN_INFO* p_chaninfo, u_int64_t tsf64, spectral_acs_stats_t *acs_stats);
+                              SPECTRAL_CHAN_INFO* p_chaninfo, u_int64_t tsf64, spectral_acs_stats_t *acs_stats,struct ieee80211com *ic);
 extern int8_t get_combined_rssi_sec80_segment(struct ath_spectral* spectral, SPECTRAL_SEARCH_FFT_INFO* p_sfft_sec80);
 /* BEGIN EACS related declarations */
 extern void spectral_read_mac_counters(struct ath_softc *sc);
diff -urN qca-wifi-org/lmac/spectral/spectral_phyerr.c qca-wifi-mod/lmac/spectral/spectral_phyerr.c
--- qca-wifi-org/lmac/spectral/spectral_phyerr.c	2018-06-08 11:00:35.000000000 +0530
+++ qca-wifi-mod/lmac/spectral/spectral_phyerr.c	2019-03-16 15:18:30.737188977 +0530
@@ -689,7 +689,7 @@
                               u_int32_t datalen, SPECTRAL_RFQUAL_INFO* p_rfqual,
                               SPECTRAL_CHAN_INFO* p_chaninfo,
                               u_int64_t tsf64,
-                              spectral_acs_stats_t *acs_stats)
+                              spectral_acs_stats_t *acs_stats, struct ieee80211com *ic)
 {
 
 
@@ -720,6 +720,7 @@
     SPECTRAL_SEARCH_FFT_INFO search_fft_info_sec80;
     SPECTRAL_SEARCH_FFT_INFO* p_sfft_sec80 = &search_fft_info_sec80;
     u_int32_t segid_skiplen = 0;
+    int16_t pow0, pow1;
 
     int8_t rssi_up  = 0;
     int8_t rssi_low = 0;
@@ -862,6 +863,14 @@
         params.pwr_count         = ptlv->length - sizeof(SPECTRAL_PHYERR_HDR) - segid_skiplen;
         params.tstamp            = (tsf64 & SPECTRAL_TSMASK);
 
+        //printk("RSSI %d %d Noise %d %d \n",params.chain_ctl_rssi[0],params.chain_ctl_rssi[1],p_rfqual->noise_floor[0],p_rfqual->noise_floor[1]);
+        pow0 =  params.chain_ctl_rssi[0] + p_rfqual->noise_floor[0];
+        pow1 =  params.chain_ctl_rssi[1] + p_rfqual->noise_floor[1];
+        ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain0 = 
+            max( pow0, ( ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain0 ) );
+        ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain1 = 
+            max( pow1, ( ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain1 ) );
+        //printk(": %d: Chain0: %d %d Chain1: %d %d \n",ic->kwn_scan.next_chan - 1, pow0, ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain0,  pow1, ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain1);
         acs_stats->ctrl_nf             = params.noise_floor;
         acs_stats->ext_nf              = params.noise_floor;
         acs_stats->nfc_ctl_rssi        = control_rssi;
diff -urN qca-wifi-org/lmac/spectral/spectral_sim.c qca-wifi-mod/lmac/spectral/spectral_sim.c
--- qca-wifi-org/lmac/spectral/spectral_sim.c	2018-06-08 11:00:35.000000000 +0530
+++ qca-wifi-mod/lmac/spectral/spectral_sim.c	2019-03-16 15:18:36.357169460 +0530
@@ -431,7 +431,7 @@
             &curr_report->rfqual_info,
             &curr_report->chan_info,
             curr_tsf64,
-            &acs_stats);
+            &acs_stats,ic);
 
     simctx->ssim_count++;
 
diff -urN qca-wifi-org/offload/os/linux/include/ol_ath.h qca-wifi-mod/offload/os/linux/include/ol_ath.h
--- qca-wifi-org/offload/os/linux/include/ol_ath.h	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/os/linux/include/ol_ath.h	2018-11-05 12:55:05.566815512 +0530
@@ -208,9 +208,9 @@
 #define ARXXXX_DEV_OTP_FILE                 "otp.bin"
 
 /* Configuration for statistics pushed by firmware */
-#define PDEV_DEFAULT_STATS_UPDATE_PERIOD    500
-#define VDEV_DEFAULT_STATS_UPDATE_PERIOD    500
-#define PEER_DEFAULT_STATS_UPDATE_PERIOD    500
+#define PDEV_DEFAULT_STATS_UPDATE_PERIOD    100
+#define VDEV_DEFAULT_STATS_UPDATE_PERIOD    100
+#define PEER_DEFAULT_STATS_UPDATE_PERIOD    100
 
 #ifdef CONFIG_AR900B_SUPPORT
 /*
diff -urN qca-wifi-org/offload/os/linux/ol_ath_iw_handler.c qca-wifi-mod/offload/os/linux/ol_ath_iw_handler.c
--- qca-wifi-org/offload/os/linux/ol_ath_iw_handler.c	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/os/linux/ol_ath_iw_handler.c	2018-07-03 13:48:53.081215623 +0530
@@ -1022,6 +1022,30 @@
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "acktimeout" },
     { OL_ATH_PARAM_TXACKTIMEOUT | OL_ATH_PARAM_SHIFT,
         0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_acktimeout" },
+    { OL_ATH_PARAM_TXDISTANCE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "distance" },
+    { OL_ATH_PARAM_TXDISTANCE | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_distance" },
+    { OL_ATH_PARAM_DYING_GASP | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dying_gasp" },
+    { OL_ATH_PARAM_DYING_GASP | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dying_gasp" },
+    { OL_ATH_PARAM_DG_TIMER_INTERVAL | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dgtimeout" },
+    { OL_ATH_PARAM_DG_TIMER_INTERVAL | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dgtimeout" },
+    { OL_ATH_PARAM_DG_ACK_DISABLE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "dgackdisable" },
+    { OL_ATH_PARAM_DG_ACK_DISABLE | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_dgackdisable" },
+    { OL_ATH_PARAM_LINKID | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "linkid" },
+    { OL_ATH_PARAM_STR_TYPE | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "str_type" },
+    { OL_ATH_PARAM_KWN_AMSDU | OL_ATH_PARAM_SHIFT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,         "kwn_amsdu" },
+    { OL_ATH_PARAM_KWN_AMSDU | OL_ATH_PARAM_SHIFT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,         "get_kwn_amsdu" },
     { OL_ATH_PARAM_BEST_UL_HYST | OL_ATH_PARAM_SHIFT,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0,       "ul_hyst" },
     { OL_ATH_PARAM_BEST_UL_HYST | OL_ATH_PARAM_SHIFT,
diff -urN qca-wifi-org/offload/os/linux/ol_ath_linux.c qca-wifi-mod/offload/os/linux/ol_ath_linux.c
--- qca-wifi-org/offload/os/linux/ol_ath_linux.c	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/os/linux/ol_ath_linux.c	2019-04-25 13:45:38.123691686 +0530
@@ -1332,6 +1332,7 @@
 {
     struct ol_ath_softc_net80211 *scn = ath_netdev_priv(dev);
     struct ieee80211com *ic = &scn->sc_ic;
+    struct ieee80211vap *vap;
     //struct ath_phy_stats *ps;
     int error=0;
     char *userdata = NULL;
@@ -1389,10 +1390,26 @@
         }
         break;
     case SIOCGATHSTATSCLR:
+        {
 #if 0
         as = scn->sc_ops->get_ath_stats(scn->sc_dev);
         error = 0;
 #endif
+            if (ol_ath_target_start(scn)) {
+                qdf_print("failed to start the target\n");
+                return -1;
+            }
+            vap = TAILQ_FIRST(&ic->ic_vaps);
+            if( vap != NULL ) {
+                vap->kwn_local_phy_err1 = scn->ath_stats.rx.phy_errs;
+                vap->kwn_local_mpdu_err1 = scn->ath_stats.rx.mpdu_errs;
+                vap->kwn_local_tx_mgmt1 = scn->scn_stats.tx_mgmt;
+                vap->kwn_local_rx_mgmt1 = scn->scn_stats.rx_mgmt;
+            }
+            memset( &scn->scn_stats, 0, sizeof(scn->scn_stats));
+            memset( &scn->ath_stats, 0, sizeof(struct wlan_dbg_stats));
+            memset( &scn->pdev_txrx_handle->stats.pub, 0, sizeof(struct ol_txrx_stats));
+        }            
         break;
     case SIOCGATHPHYSTATS:
          if(((dev->flags & IFF_UP) == 0)){
diff -urN qca-wifi-org/offload/wds/wds_addr.c qca-wifi-mod/offload/wds/wds_addr.c
--- qca-wifi-org/offload/wds/wds_addr.c	2018-06-08 11:00:46.000000000 +0530
+++ qca-wifi-mod/offload/wds/wds_addr.c	2019-01-23 18:05:27.659187093 +0530
@@ -105,9 +105,10 @@
     wds = _wds_entry_find(table, dest_mac);
     if (wds){
         qdf_mem_copy(peer_mac, wds->peer_mac, 6);
-        *vap = wds->vap;
-    } else
+        //*vap = wds->vap;
+    } else {
          ret = 1;
+    }
     read_unlock_bh(&table->wds_table_lock);
     return ret;
 }
@@ -118,9 +119,9 @@
     return wds_entry_find(&((struct ol_ath_softc_net80211 *)scn)->scn_wds_table, dest_mac, peer_mac, vap);
 }
 
-#if QCA_PARTNER_PLATFORM
+//#if QCA_PARTNER_PLATFORM
 EXPORT_SYMBOL(wds_find);
-#endif
+//#endif
 
 static int
 wds_entry_delete(struct wds_table *table, unsigned char *dest_mac)
@@ -183,6 +184,8 @@
     for (i = 0; i < (len / sizeof(u_int32_t)); i++, datap += sizeof(u_int32_t))
         *(u_int32_t *)datap = le32_to_cpu(*(u_int32_t *)datap);
 #endif
+    printk("Printing wds entries [no. of entries:%d]\n",wds_entry_dump_event->num_entries);
+    printk("\n \tDA\t\tNext Hop\t\tflags\n\n ");
 
     qdf_print("Printing wds entries [no. of entries:%d]\n",wds_entry_dump_event->num_entries);
     qdf_print("\n \tDA\t\tNext Hop\t\tflags\n\n ");
@@ -197,10 +200,13 @@
                    peer_mac[4+i] = ((u_int8_t*)&(wds_entry_dump_event->wds_entry[j].peer_macaddr.mac_addr47to32))[i];
                    wds_mac[4+i] = ((u_int8_t*)&(wds_entry_dump_event->wds_entry[j].wds_macaddr.mac_addr47to32))[i];
            }
-
            qdf_print("%s\t", ether_sprintf(wds_mac));
            qdf_print("%s\t", ether_sprintf(peer_mac));
            qdf_print("%d\n", wds_entry_dump_event->wds_entry[j].flags);
+
+           printk("%s\t", ether_sprintf(wds_mac));
+           printk("%s\t", ether_sprintf(peer_mac));
+           printk("%d\n", wds_entry_dump_event->wds_entry[j].flags);
     }
     return 0;
 }
@@ -208,13 +214,13 @@
 static int
 wds_peer_event_handler(ol_scn_t sc, u_int8_t *datap, u_int16_t len)
 {
-    wds_addr_event_t wds_ev, *wds_addr_event;
+    wds_addr_event_t wds_ev, *wds_addr_event = NULL;
     struct ol_ath_softc_net80211 *scn = (struct ol_ath_softc_net80211 *) sc;
     uint8_t *peer_mac, *dest_mac;
-    int i;
 
-    if(wmi_extract_wds_addr_event(scn->wmi_handle, datap, len, &wds_addr_event)) {
+    if(wmi_extract_wds_addr_event(scn->wmi_handle, datap, len, &wds_ev)) {
         qdf_print("Unable to extract wds addr event\n");
+        printk("Unable to extract wds addr event\n");
     } else {
         wds_addr_event = &wds_ev;
         peer_mac = wds_ev.peer_mac;
@@ -227,6 +233,13 @@
                     dest_mac[0], dest_mac[1],
                     dest_mac[2], dest_mac[3],
                     dest_mac[4], dest_mac[5]);
+            printk("Adding WDS entry through(%02x:%02x:%02x:%02x:%02x:%02x) of mac(%02x:%02x:%02x:%02x:%02x:%02x)\n",
+                    peer_mac[0], peer_mac[1],
+                    peer_mac[2], peer_mac[3],
+                    peer_mac[4], peer_mac[5],
+                    dest_mac[0], dest_mac[1],
+                    dest_mac[2], dest_mac[3],
+                    dest_mac[4], dest_mac[5]);
             wds_entry_add(scn, &scn->scn_wds_table, dest_mac, peer_mac);
 #if PEER_FLOW_CONTROL
             ol_txrx_ast_find_hash_add(scn->pdev_txrx_handle,
@@ -249,6 +262,14 @@
                     dest_mac[0], dest_mac[1],
                     dest_mac[2], dest_mac[3],
                     dest_mac[4], dest_mac[5]);
+            printk("Deleting WDS entry through(%02x:%02x:%02x:%02x:%02x:%02x) of mac(%02x:%02x:%02x:%02x:%02x:%02x)\n",
+                    peer_mac[0], peer_mac[1],
+                    peer_mac[2], peer_mac[3],
+                    peer_mac[4], peer_mac[5],
+                    dest_mac[0], dest_mac[1],
+                    dest_mac[2], dest_mac[3],
+                    dest_mac[4], dest_mac[5]);
+
             wds_entry_delete(&scn->scn_wds_table, dest_mac);
 #if PEER_FLOW_CONTROL
             if(ol_txrx_ast_find_hash_remove(scn->pdev_txrx_handle, dest_mac)) {
diff -urN qca-wifi-org/offload/wlan/include/ol_if_athvar.h qca-wifi-mod/offload/wlan/include/ol_if_athvar.h
--- qca-wifi-org/offload/wlan/include/ol_if_athvar.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/include/ol_if_athvar.h	2019-03-14 16:44:33.150668220 +0530
@@ -36,6 +36,7 @@
 #include "ieee80211_wds.h"
 #include "ieee80211_ique.h"
 #include "ieee80211_acs.h"
+#include "ieee80211_acs_internal.h"
 #include "ieee80211_csa.h"
 #include "asf_amem.h"
 #include "qdf_types.h"
@@ -340,14 +341,14 @@
 #define DEFAULT_PRINT_RATE_LIMIT_VALUE 100
 
 /*
- * Default TX ACK time out value (micro second)
- */
-#define DEFAULT_TX_ACK_TIMEOUT 0x40
-
-/*
  * Max TX ACK time out value (micro second)
  */
 #define MAX_TX_ACK_TIMEOUT 0xFF
+/*
+ * Default TX ACK time out value (micro second)
+ */
+#define DEFAULT_TX_ACK_TIMEOUT 0x40
+//#define DEFAULT_TX_ACK_TIMEOUT MAX_TX_ACK_TIMEOUT
 
 struct mute_error_types {
     u_int32_t  pn_errors;
@@ -1048,6 +1049,12 @@
 void ol_ath_vap_tx_lock(void *ptr);
 void ol_ath_vap_tx_unlock(void *ptr);
 
+
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap,u_int32_t send_ack,struct ieee80211_node *ni);
+void ieee80211_send_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni );
+void kwn_sa_set_channel( struct ieee80211com *ic );
+void disassoc_stations( void* arg, wlan_if_t vap );
+void kwn_beacon_chanutil_update( struct ieee80211vap *vap );
 int
 ol_transfer_target_eeprom_caldata(struct ol_ath_softc_net80211 *scn, u_int32_t address, bool compressed);
 
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath.c	2019-04-25 13:47:35.807631040 +0530
@@ -196,6 +196,8 @@
 int ol_ath_peer_mumimo_tx_count_event_handler (ol_scn_t scn, u_int8_t *data, u_int16_t datalen);
 int ol_ath_peer_gid_userpos_list_event_handler (ol_scn_t scn, u_int8_t *data, u_int16_t datalen);
 int ol_ath_pdev_caldata_version_check_event_handler (ol_scn_t scn, u_int8_t *data, u_int16_t datalen);
+void kwn_get_ol_stats( struct ieee80211vap *vap, struct ieee80211com *ic );
+void kwn_set_qboost( struct ieee80211vap *vap, struct ieee80211com *ic, struct ieee80211_node *ni, int value );
 
 #if QCA_AIRTIME_FAIRNESS
 int ol_ath_atf_peer_stats_event_handler(ol_scn_t scn, u_int8_t *data, u_int16_t datalen);
@@ -4488,7 +4490,7 @@
     param.cfreq1 = 0;
     param.cfreq2 = 0;
     if((chan_mode == IEEE80211_MODE_11AC_VHT80) ||(chan_mode == IEEE80211_MODE_11AC_VHT160) || (chan_mode == IEEE80211_MODE_11AC_VHT80_80)) {
-            if (chan->ic_ieee < 20)
+            if (chan->ic_freq < 4000)
                 param.cfreq1 = ieee80211_ieee2mhz(&scn->sc_ic,
                                                           chan->ic_vhtop_ch_freq_seg1, IEEE80211_CHAN_2GHZ);
             else
@@ -5102,7 +5104,8 @@
         /* There is a active STA mode vap.
          * for STA mode channel change will happen through resmgr channnel change
          */
-         return -1;
+        wlan_iterate_vap_list(ic, ol_vap_instant_restart_iter_func, (void *)chan);
+        return 0;
     }
     else {
         /* Call a new channel change WMI cmd for all VAPs in AP/monitor mode.  */
@@ -5221,7 +5224,7 @@
                 return ((freq * 10) +
                     (((freq % 5) == 2) ? 5 : 0) - 49400)/5;
             } else if (freq > 4900) {
-                return (freq - 4000) / 5;
+                return (freq - 3920) / 5;
             } else {
                 return 15 + ((freq - 2512) / 20);
             }
@@ -6743,6 +6746,542 @@
     OS_SET_TIMER(&ic->ic_inact_timer, IEEE80211_SESSION_WAIT*1000);
 }
 
+void kwn_total_retries( void *arg, struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+    ic->kwn_tx_pkts = ic->kwn_tx_pkts + ni->ni_stats.ns_tx_data;
+    ic->kwn_retries = ic->kwn_retries + ni->kwn_local_retries;
+    //printk(": DCS: Node Local Tx: %d Local Retries: %d \n",ic->kwn_tx_pkts,ic->kwn_retries);
+}
+
+static OS_TIMER_FUNC( ol_rtx_timer_fun )
+{
+	struct ol_ath_softc_net80211 *scn ;
+	wlan_dev_t ic;
+    wlan_if_t vap = NULL;
+    int sta_count;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+	ic = &scn->sc_ic;
+    vap = TAILQ_FIRST(&ic->ic_vaps);
+    if( vap == NULL ) {
+        printk(": DCS: VAP is NULL\n");
+        return;
+    }
+    sta_count = wlan_iterate_station_list( vap, NULL, NULL );
+    if( sta_count == 0 ) {
+        ic->kwn_tx_pkts = 0;
+        ic->kwn_retries = 0;
+        OS_SET_TIMER( &ic->kwn_rtx_timer, KWN_RTX_TIME );
+        return;
+    }
+    if( ic->kwn_tx_pkts == 0 ) {
+        ic->kwn_tx_pkts = 0;
+        ic->kwn_retries = 0;
+        wlan_iterate_station_list( vap, kwn_total_retries, NULL );
+    }
+    else
+    {
+        uint32_t tx, rtx, last_tx, last_retries;
+        uint8_t rtx_per = 0;
+
+        last_tx = ic->kwn_tx_pkts;
+        last_retries = ic->kwn_retries;
+        ic->kwn_tx_pkts = 0;
+        ic->kwn_retries = 0;
+        wlan_iterate_station_list( vap, kwn_total_retries, NULL );
+        tx = ic->kwn_tx_pkts - last_tx;
+        rtx = ic->kwn_retries - last_retries;
+        if( tx > 8 ) {
+            rtx_per = ( u_int8_t ) ( ( rtx * 100 ) / tx );
+        }
+        vap->kwn_local_rtx = rtx_per;
+        //printk(": DCS: Tx %u rtx %u rtx_per %d \n",tx,rtx,rtx_per);
+    }
+    OS_SET_TIMER( &ic->kwn_rtx_timer, KWN_RTX_TIME );
+    return;
+}
+
+u_int16_t kwn_get_next_frequency( struct ieee80211com *ic, u_int16_t freq )
+{
+    u_int8_t i;
+    u_int16_t next_freq = 0;
+
+    for( i = 0; i < ic->kwn_scan.acs_result.cnt; i++ )
+    {
+        //printk("Freq %d Utility %d Blacklsit %d \n",ic->kwn_scan.acs_result.acs_entry[i].frequency, ic->kwn_scan.acs_result.acs_entry[i].utility, ic->kwn_scan.acs_result.acs_entry[i].blacklist);
+        if( freq == ic->kwn_scan.acs_result.acs_entry[i].frequency ) {
+            if( i < ( ic->kwn_scan.acs_result.cnt - 1 ) && 
+                    ic->kwn_scan.acs_result.acs_entry[ i + 1 ].blacklist == 0 ) {
+                next_freq = ic->kwn_scan.acs_result.acs_entry[ i + 1 ].frequency;
+                return next_freq;
+            }
+            else if( i == ( ic->kwn_scan.acs_result.cnt - 1 ) && 
+                    ic->kwn_scan.acs_result.acs_entry[ 0 ].blacklist == 0 ) {
+                next_freq = ic->kwn_scan.acs_result.acs_entry[ 0 ].frequency;
+                return next_freq;
+            }
+            else {
+                return next_freq;
+            }
+        }
+    }
+    return next_freq;
+}
+
+void kwn_send_rx_channel( void *arg, struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap = NULL;
+
+    vap = ni->ni_vap;
+    ni->kwn_rxrate = -1;
+    ni->kwn_rxpwr = -1;
+    ni->kwn_rxchan = vap->kwn_rxchan;
+    ieee80211_send_txparams( vap, ni );
+}
+
+static OS_TIMER_FUNC( ol_bl_timer_fun )
+{
+	wlan_dev_t ic;
+	struct ol_ath_softc_net80211 *scn ;
+    int i, bl_found = 0;
+    unsigned long diff;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+	ic = &scn->sc_ic;
+    for( i = 0; i < ic->kwn_scan.acs_result.cnt; i++ )
+    {
+        if( ic->kwn_scan.acs_result.acs_entry[i].blacklist == 1 ) {
+            bl_found = 1;
+            diff = jiffies - ic->kwn_scan.acs_result.acs_entry[i].jiffies;
+            if( ( diff / 1000 ) > ic->kwn_dcs.bl_int )
+            {
+                ic->kwn_scan.acs_result.acs_entry[i].blacklist = 0;
+                ic->kwn_scan.acs_result.acs_entry[i].jiffies = 0;
+                printk(": DCS: Deblacklisted channel %d ( %d MHz )\n",ic->kwn_scan.acs_result.acs_entry[i].channel,
+                        ic->kwn_scan.acs_result.acs_entry[i].frequency);
+            }
+        }
+    }
+    ic->kwn_dcs.bl_timer_started = 0;
+    if( bl_found ) {
+        ic->kwn_dcs.bl_timer_started = 1;
+        OS_SET_TIMER( &ic->kwn_dcs.bl_timer, KWN_BL_TIME );
+    }
+}
+
+void kwn_blacklist_currnet_channel( struct ieee80211com *ic, u_int8_t bl_chan )
+{
+    int i;
+
+    for( i = 0; i < ic->kwn_scan.acs_result.cnt; i++ )
+    {
+        if( ic->kwn_scan.acs_result.acs_entry[i].channel == bl_chan )
+        {
+            ic->kwn_scan.acs_result.acs_entry[i].blacklist = 1;
+            ic->kwn_scan.acs_result.acs_entry[i].jiffies = jiffies;
+        }
+    }
+}
+
+void kwn_update_channel_list( struct ieee80211com *ic )
+{
+#define IS_NEW_CHANNEL(c)	isclr(reported, (c)->ic_ieee)
+    u_int8_t reported[IEEE80211_CHAN_BYTES];
+    int i, cnt = 0;
+
+    memset(reported, 0, sizeof(reported));
+    for (i = 0; i < ic->ic_nchans; i++) {
+        const struct ieee80211_channel *c = &ic->ic_channels[i];
+        if( IS_NEW_CHANNEL(c) ) {
+            setbit( reported, c->ic_ieee );
+            ic->kwn_scan.acs_result.acs_entry[cnt].channel = c->ic_ieee;
+            ic->kwn_scan.acs_result.acs_entry[cnt].frequency = c->ic_freq;
+            ic->kwn_scan.acs_result.acs_entry[cnt].utility = 0;
+            ic->kwn_scan.acs_result.acs_entry[cnt].blacklist = 0;
+            printk("channel %d %d %d \n",ic->kwn_scan.acs_result.acs_entry[cnt].channel, ic->kwn_scan.acs_result.acs_entry[cnt].frequency, ic->kwn_scan.acs_result.acs_entry[cnt].utility);
+            cnt++;
+        }
+    }
+    ic->kwn_scan.acs_result.cnt = cnt;
+    printk("Count %d \n",ic->kwn_scan.acs_result.cnt);
+}
+
+static OS_TIMER_FUNC( ol_dcs_timer_fun )
+{
+	wlan_dev_t ic;
+	wlan_if_t vap;
+	struct ol_ath_softc_net80211 *scn ;
+    //u_int16_t next_freq;
+    //struct ieee80211_channel *c;
+    int sta_count;
+    int i;
+    u_int16_t start_freq = 0, end_freq = 0;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+	ic = &scn->sc_ic;
+    vap = ic->kwn_dcs.dcs_vap;
+    sta_count = wlan_iterate_station_list( vap, NULL, NULL );
+
+    if( vap->iv_opmode != IEEE80211_M_HOSTAP || sta_count < 1 ) {
+        printk(": DCS: Radio Mode is not Outdoor Base or station count is %d\n",sta_count);
+        OS_SET_TIMER( &ic->kwn_dcs.dcs_timer, ic->kwn_dcs.dcs_time * 1000 );
+        return;
+    }
+    if( ic->enable_acs || ic->enable_sa_scan ) {
+        printk(": DCS: ACS or Spectral scan is enabled \n");
+        OS_SET_TIMER( &ic->kwn_dcs.dcs_timer, ic->kwn_dcs.dcs_time * 1000 );
+        return;
+    }
+#if 0
+    if( ic->kwn_scan.acs_result.cnt == 0 ) {
+        printk(": DCS: Last scanned results are not available, Update channel list\n");
+        kwn_update_channel_list( ic );
+    }
+#endif
+    if( vap->kwn_local_rtx > ic->kwn_dcs.dcs_thrld ) {
+        ic->kwn_dcs.dcs_triggered = 1;
+        wlan_iterate_vap_list(ic, disassoc_stations, NULL);
+        for (i = 0; i < ic->ic_nchans; i++) {
+            struct ieee80211_channel *c;
+            u_int16_t freq = ic->ic_channels[i].ic_freq;
+
+            c = kwn_find_channel( ic, vap, freq );
+            if( c != NULL ) {
+                if( start_freq == 0 )
+                    start_freq = c->ic_freq;
+                else
+                    end_freq = c->ic_freq;
+            }
+        }
+        printk(": DCS: start freq %d end freq %d \n",start_freq,end_freq);
+            printk(": DCS: Traggiered..Scanning module enabled \n");
+            memset( &ic->kwn_scan.sa_result, 0, sizeof( struct kwn_sa_scan_result ) );
+            ic->kwn_scan.scan_vap = vap;
+            ic->kwn_scan.oper_freq = ic->ic_curchan->ic_freq;
+            ic->kwn_scan.start_freq = start_freq;
+            ic->kwn_scan.end_freq = end_freq;
+            ic->kwn_scan.curr_freq = 0;
+            ic->kwn_scan.next_chan = 0;
+            ic->kwn_scan.scan_time = ic->kwn_scan.acs_scan_time;
+            ic->kwn_scan.util_time = 400;
+            ic->kwn_scan.start_scan = 1;
+            ic->enable_acs = 1;
+            OS_SET_TIMER(&ic->kwn_scan.scan_timer, 1000);
+
+#if 0
+        next_freq = kwn_get_next_frequency( ic, ic->ic_curchan->ic_freq );
+        if( next_freq != 0 ) {
+            c = kwn_find_channel( ic, vap, next_freq );
+            if( c != NULL ) {
+                printk(": DCS: DCS triggered, next available channel %d ( %d MHz ) \n",c->ic_ieee, c->ic_freq);
+                kwn_blacklist_currnet_channel( ic, ic->ic_curchan->ic_ieee );
+                if( !ic->kwn_dcs.bl_timer_started ) {
+                    printk(": DCS: Check Blacklist timer\n");
+                    OS_SET_TIMER( &ic->kwn_dcs.bl_timer, KWN_BL_TIME );
+                    ic->kwn_dcs.bl_timer_started = 1;
+                }
+                vap->kwn_rxchan = c->ic_ieee;
+                wlan_iterate_station_list( vap, kwn_send_rx_channel, NULL );
+                ic->ic_prevchan = ic->ic_curchan;
+                ic->ic_curchan = c;
+                kwn_sa_set_channel( ic );
+            }
+        }
+        else {
+            printk(": DCS: DCS triggered, next channel is not available \n");
+        }
+#endif
+    }
+    OS_SET_TIMER( &ic->kwn_dcs.dcs_timer, ic->kwn_dcs.dcs_time * 1000 );
+}
+
+void kwn_last_acs_result( struct ieee80211com *ic )
+{
+    u_int8_t i, j;
+    struct kwn_acs_entries temp;
+
+    memset( &ic->kwn_scan.acs_result, 0, sizeof( struct kwn_acs_result ) );
+    ic->kwn_scan.acs_result.cnt = ic->kwn_scan.sa_result.cnt;
+    for( i = 0; i < ic->kwn_scan.sa_result.cnt; i++ )
+    {
+        ic->kwn_scan.acs_result.acs_entry[i].channel = ic->kwn_scan.sa_result.sa_entry[i].channel;
+        ic->kwn_scan.acs_result.acs_entry[i].frequency = ic->kwn_scan.sa_result.sa_entry[i].frequency;
+        ic->kwn_scan.acs_result.acs_entry[i].utility = ic->kwn_scan.sa_result.sa_entry[i].utility;
+    }
+    for( i = 0; i < ic->kwn_scan.acs_result.cnt - 1; i++ )
+    {
+        for( j = i+1; j < ic->kwn_scan.acs_result.cnt; j++ )
+        {
+            if( ic->kwn_scan.acs_result.acs_entry[i].utility > ic->kwn_scan.acs_result.acs_entry[j].utility )
+            {
+                temp.channel = ic->kwn_scan.acs_result.acs_entry[j].channel;
+                temp.frequency = ic->kwn_scan.acs_result.acs_entry[j].frequency;
+                temp.utility = ic->kwn_scan.acs_result.acs_entry[j].utility;
+                ic->kwn_scan.acs_result.acs_entry[j].channel = ic->kwn_scan.acs_result.acs_entry[i].channel;
+                ic->kwn_scan.acs_result.acs_entry[j].frequency = ic->kwn_scan.acs_result.acs_entry[i].frequency;
+                ic->kwn_scan.acs_result.acs_entry[j].utility = ic->kwn_scan.acs_result.acs_entry[i].utility;
+                ic->kwn_scan.acs_result.acs_entry[i].channel = temp.channel;
+                ic->kwn_scan.acs_result.acs_entry[i].frequency = temp.frequency;
+                ic->kwn_scan.acs_result.acs_entry[i].utility = temp.utility;
+            }
+        }
+    }
+    printk("#########  ACS Sort Entries  ##############\n");
+    printk("Frequency Channel Utility\n");
+    for( i = 0; i < ic->kwn_scan.acs_result.cnt; i++ )
+    {
+        printk("%d       %d     %d \n",ic->kwn_scan.acs_result.acs_entry[i].frequency,
+                ic->kwn_scan.acs_result.acs_entry[i].channel,ic->kwn_scan.acs_result.acs_entry[i].utility);
+    }
+    printk("#######################################\n");
+}
+
+void kwn_calculate_best_channel( struct ieee80211com *ic, struct ieee80211vap *vap )
+{
+    u_int8_t i;
+    u_int16_t best_freq = ic->kwn_scan.sa_result.sa_entry[0].frequency;
+    struct ieee80211_channel *c;
+    int16_t pow;
+
+    pow = max( ic->kwn_scan.sa_result.sa_entry[0].pow_chain0, ic->kwn_scan.sa_result.sa_entry[0].pow_chain1 );
+    //kwn_last_acs_result( ic );
+    printk(": ACS: Calculate best channel\n");
+    for( i = 0; i < ic->kwn_scan.sa_result.cnt; i++ )
+    {
+        if( ic->kwn_dcs.dcs_triggered == 1 && ic->kwn_scan.sa_result.sa_entry[i].frequency == ic->kwn_scan.oper_freq ) {
+            printk("DCS: Skipping the current operating channel %d while calculating best channel\n",ic->kwn_scan.oper_freq);
+            continue;
+        }
+        if( pow > max( ic->kwn_scan.sa_result.sa_entry[i].pow_chain0, ic->kwn_scan.sa_result.sa_entry[i].pow_chain1 ) ) {
+            pow = max( ic->kwn_scan.sa_result.sa_entry[i].pow_chain0, ic->kwn_scan.sa_result.sa_entry[i].pow_chain1 );
+            best_freq = ic->kwn_scan.sa_result.sa_entry[i].frequency;
+        }
+    }
+    c = kwn_find_channel( ic, vap, best_freq );
+    if( c != NULL ) {
+
+        union iwreq_data wreq = {{0}};
+        struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+
+        /* Send an event to apl as DCS Triggered */
+        memset(&wreq, 0, sizeof(wreq));
+        wreq.addr.sa_family = ARPHRD_ETHER;
+        memcpy(wreq.addr.sa_data, vap->iv_bss, 6);
+        if( ic->kwn_dcs.dcs_triggered == 1 ) {
+           wreq.addr.sa_data[6] = IEEE80211_EV_DCS_BEST_CHANNEL;
+           ic->kwn_dcs.dcs_triggered = 0;
+        }
+        else {
+           wreq.addr.sa_data[6] = IEEE80211_EV_ACS_BEST_CHANNEL;
+        }
+        wreq.addr.sa_data[7] = c->ic_ieee;
+        wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+        dev_put(dev);
+
+        printk(": ACS: Best channel %d %d \n",c->ic_ieee, c->ic_freq);
+        ic->ic_prevchan = ic->ic_curchan;
+        ic->ic_curchan = c;
+        kwn_sa_set_channel( ic );
+    }
+}
+
+static OS_TIMER_FUNC( ol_chan_util_timer_fun )
+{
+	wlan_dev_t ic;
+	wlan_if_t vap;
+	struct ol_ath_softc_net80211 *scn ;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+	ic = &scn->sc_ic;
+    vap = ic->kwn_scan.scan_vap;
+    kwn_beacon_chanutil_update( vap );
+    OS_SET_TIMER(&ic->kwn_scan.util_timer, ic->kwn_scan.util_time);
+}
+
+static OS_TIMER_FUNC( ol_scan_timer_fun )
+{
+	wlan_dev_t ic;
+	wlan_if_t vap;
+	struct ol_ath_softc_net80211 *scn ;
+    struct ieee80211_channel *c;
+    u_int16_t  curr_freq;
+    u_int8_t i, utility;
+
+	OS_GET_TIMER_ARG(scn, struct ol_ath_softc_net80211 *);
+    ic = &scn->sc_ic;
+    vap = ic->kwn_scan.scan_vap;
+  
+    if( !ic->enable_acs && !ic->enable_sa_scan && !ic->kwn_dcs.dcs_triggered ) {
+        printk(": SPECTRAL: ACS or DCS or Spectral scan is not enabled ");
+        ic->enable_sa_scan = 0;
+        ic->enable_acs = 0;
+        return;
+    }
+    if( ic->kwn_scan.next_chan == KWN_CHAN_MAX ) {
+        printk(": SPECTRAL: Channel list exceeds sa max list 250\n");
+        ic->enable_sa_scan = 0;
+        ic->enable_acs = 0;
+        return;
+    }
+    curr_freq = ic->kwn_scan.curr_freq;
+    if( curr_freq == 0 ) {
+        union iwreq_data wreq = {{0}};
+        struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+
+        /* Send an event to apl as DCS Triggered */
+        memset(&wreq, 0, sizeof(wreq));
+        wreq.addr.sa_family = ARPHRD_ETHER;
+        memcpy(wreq.addr.sa_data, vap->iv_bss, 6);
+        if( ic->enable_sa_scan ) {
+            wreq.addr.sa_data[6] = IEEE80211_EV_SA_START;
+        }
+        else if( ic->kwn_dcs.dcs_triggered == 1 ) {
+            wreq.addr.sa_data[6] = IEEE80211_EV_DCS_TRIGGERED;
+        }
+        else {
+            wreq.addr.sa_data[6] = IEEE80211_EV_ACS_START;
+        }
+        wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+        dev_put(dev);
+    }
+    if( curr_freq == 0 ) {
+        printk(": SPECTRAL: SA scan is started\n");
+        curr_freq = ic->kwn_scan.start_freq;
+    }
+    else {
+        curr_freq = ic->kwn_scan.curr_freq + 5;
+    }
+    if( curr_freq > ic->kwn_scan.end_freq ) {
+        if( vap->kwnchanutil_info.total > 0 ) {
+            utility = ( u_int8_t ) ( vap->kwnchanutil_info.total / vap->kwnchanutil_info.count );
+            ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].utility = ( u_int8_t ) ( ( utility * 100 ) / 255 );
+        }
+        printk("LEVEL Chain0 %d Chain1 %d\n",ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain0,
+                ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain1);
+        kwn_get_ol_stats( vap, ic );
+        ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].noise = vap->kwn_local_noise_floor;
+        ic->kwn_scan.sa_result.cnt = ic->kwn_scan.next_chan;
+        ic->kwn_scan.scan_vap = NULL;
+        OS_CANCEL_TIMER(&ic->kwn_scan.util_timer);
+        OS_CANCEL_TIMER(&ic->kwn_scan.scan_timer);
+        printk(": SPECTRAL: SA/ACS scan is stopped\n");
+        printk("#######################################\n");
+        printk("Frequency Channel Chain0 Chain1 Max.Power\n");
+        for( i = 0; i < ic->kwn_scan.sa_result.cnt; i++ )
+        {
+            printk("%d       %d     %d     %d    %d\n", ic->kwn_scan.sa_result.sa_entry[i].frequency, 
+                    ic->kwn_scan.sa_result.sa_entry[i].channel,
+                    ic->kwn_scan.sa_result.sa_entry[i].pow_chain0,
+                    ic->kwn_scan.sa_result.sa_entry[i].pow_chain1,
+                    max( ic->kwn_scan.sa_result.sa_entry[i].pow_chain0, ic->kwn_scan.sa_result.sa_entry[i].pow_chain1 ) );
+        }
+        printk("#######################################\n");
+        if( ic->enable_acs )
+            kwn_calculate_best_channel( ic, vap );
+        if( ic->enable_sa_scan ) {
+            union iwreq_data wreq = {{0}};
+            struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+
+            /* Send an event to apl as DCS Triggered */
+            memset(&wreq, 0, sizeof(wreq));
+            wreq.addr.sa_family = ARPHRD_ETHER;
+            memcpy(wreq.addr.sa_data, vap->iv_bss, 6);
+            wreq.addr.sa_data[6] = IEEE80211_EV_SA_STOP;
+            wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+            dev_put(dev);
+            
+            printk(": SPECTRAL: Revert back to operating frequnecy %d \n",ic->kwn_scan.oper_freq);
+            c = kwn_find_channel(ic, vap, ic->kwn_scan.oper_freq );
+            ic->ic_prevchan = ic->ic_curchan;
+            ic->ic_curchan = c;
+            kwn_sa_set_channel( ic );
+        }
+        ic->kwn_scan.start_scan = 0;
+        ic->enable_sa_scan = 0;
+        ic->enable_acs = 0;
+        return;
+    }
+    ic->kwn_scan.curr_freq = curr_freq;
+    c = kwn_find_channel( ic, vap, ic->kwn_scan.curr_freq );
+    if( c == NULL ) {
+        OS_SET_TIMER(&ic->kwn_scan.scan_timer, 0);
+        return;
+    }
+    if( ic->kwn_dcs.dcs_triggered == 1 && ic->kwn_scan.curr_freq == ic->kwn_scan.oper_freq ) {
+        OS_SET_TIMER(&ic->kwn_scan.scan_timer, 0);
+        return;
+    }
+    if( ic->kwn_scan.next_chan != 0 ) {
+        if( vap->kwnchanutil_info.total > 0 ) {
+            utility = ( u_int8_t ) ( vap->kwnchanutil_info.total / vap->kwnchanutil_info.count );
+            ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].utility = ( u_int8_t ) ( ( utility * 100 ) / 255 );
+        }
+        printk("LEVEL Chain0 %d Chain1 %d\n",ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain0,
+                ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].pow_chain1);
+        kwn_get_ol_stats( vap, ic );
+        ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan - 1].noise = vap->kwn_local_noise_floor;
+    }
+    memset( &vap->kwnchanutil_info, 0, sizeof( struct kwn_chanutil_info ) );
+    ic->ic_prevchan = ic->ic_curchan;
+    ic->ic_curchan = c;
+    ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan].channel = ic->ic_curchan->ic_ieee;
+    ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan].frequency = ic->ic_curchan->ic_freq;
+    printk(": SPECTRAL: Set Channel %d %d : %d \n",ic->ic_curchan->ic_ieee, ic->ic_curchan->ic_freq, ic->kwn_scan.next_chan);
+    kwn_sa_set_channel( ic );
+    ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan].pow_chain0 = -110;
+    ic->kwn_scan.sa_result.sa_entry[ic->kwn_scan.next_chan].pow_chain1 = -110;
+    ic->kwn_scan.next_chan++;
+    ic->kwn_scan.sa_result.cnt = ic->kwn_scan.next_chan;
+    OS_SET_TIMER(&ic->kwn_scan.util_timer, ic->kwn_scan.util_time);
+    OS_SET_TIMER(&ic->kwn_scan.scan_timer, ic->kwn_scan.scan_time);
+}
+
+void kwn_get_ol_stats( struct ieee80211vap *vap, struct ieee80211com *ic )
+{
+    struct ol_ath_softc_net80211 *scn;
+	struct ol_stats *stats;
+
+    scn = OL_ATH_SOFTC_NET80211(ic);
+
+	stats = OS_MALLOC(&scn->sc_osdev,
+			sizeof(struct ol_stats), GFP_KERNEL);
+	if (stats == NULL)
+		return;
+	TAILQ_FOREACH(vap, &ic->ic_vaps, iv_next) {
+        if (vap != NULL) {
+            ol_get_wlan_dbg_stats( scn, &stats->stats );
+            ol_get_radio_stats( scn, &stats->interface_stats );
+            vap->kwn_local_snr_a1 = stats->interface_stats.rx_rssi_chain0.rx_rssi_pri20 > 128 ? 0 : stats->interface_stats.rx_rssi_chain0.rx_rssi_pri20;
+            vap->kwn_local_snr_a2 = stats->interface_stats.rx_rssi_chain1.rx_rssi_pri20 > 128 ? 0 : stats->interface_stats.rx_rssi_chain1.rx_rssi_pri20;
+            vap->kwn_local_noise_floor = stats->interface_stats.chan_nf;
+            vap->kwn_local_phy_err = ( stats->stats.rx.phy_errs > vap->kwn_local_phy_err1 ?  
+                    ( stats->stats.rx.phy_errs - vap->kwn_local_phy_err1 ) : 0 );
+            vap->kwn_local_mpdu_err = ( stats->stats.rx.mpdu_errs > vap->kwn_local_mpdu_err1 ? 
+                    ( stats->stats.rx.mpdu_errs - vap->kwn_local_mpdu_err1 ) : 0 );
+            vap->kwn_local_tx_mgmt = ( scn->scn_stats.tx_mgmt > vap->kwn_local_tx_mgmt1 ?  
+                    ( scn->scn_stats.tx_mgmt - vap->kwn_local_tx_mgmt1 ) : 0 );
+            vap->kwn_local_rx_mgmt = ( scn->scn_stats.rx_mgmt > vap->kwn_local_rx_mgmt1 ?  
+                    ( scn->scn_stats.rx_mgmt - vap->kwn_local_rx_mgmt1 ) : 0 );
+            break;
+        }
+	}
+	OS_FREE(stats);
+}
+
+void kwn_set_qboost( struct ieee80211vap *vap, struct ieee80211com *ic, struct ieee80211_node *ni, int value )
+{
+    struct ol_ath_softc_net80211 *scn;
+
+    scn = OL_ATH_SOFTC_NET80211(ic);
+    scn->scn_qboost_enable = value;
+	qboost_config( vap, ni, value );
+}
+
 static int
 ol_ath_set_mgmt_retry_limit(struct ieee80211com *ic , u_int8_t limit)
 {
@@ -7156,6 +7695,8 @@
     ic->ic_atf_logging = 0;
 
     ic->ic_bestUL_hyst = BEST_UL_HYST_DEF;
+    ic->ic_kwn_get_ol_stats = kwn_get_ol_stats;
+    ic->ic_kwn_set_qboost = kwn_set_qboost;
 
     return EOK;
 }
@@ -8133,6 +8674,11 @@
                                                 ol_ath_esp_estimate_event_handler, WMI_RX_UMAC_CTX);
 #endif
 
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_scan.scan_timer, ol_scan_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_scan.util_timer, ol_chan_util_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_dcs.dcs_timer, ol_dcs_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_dcs.bl_timer, ol_bl_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
+        OS_INIT_TIMER(scn->sc_osdev, &ic->kwn_rtx_timer, ol_rtx_timer_fun, (void * )(scn), QDF_TIMER_TYPE_WAKE_APPS);
 #if OL_ATH_SUPPORT_LED
         if (scn->target_version == AR9888_REV2_VERSION || scn->target_version == AR9887_REV1_VERSION) {
             scn->scn_led_gpio = PEREGRINE_LED_GPIO ;
@@ -8475,6 +9021,13 @@
     u_int32_t num_mem_chunks;
     ic = &scn->sc_ic;
 
+    memset( &ic->kwn_scan.sa_result, 0, sizeof(struct kwn_sa_scan_result) );
+    memset( &ic->kwn_scan.acs_result, 0, sizeof(struct kwn_acs_result) );
+    OS_FREE_TIMER(&ic->kwn_scan.scan_timer);
+    OS_FREE_TIMER(&ic->kwn_scan.util_timer);
+    OS_FREE_TIMER(&ic->kwn_dcs.dcs_timer);
+    OS_FREE_TIMER(&ic->kwn_dcs.bl_timer);
+    OS_FREE_TIMER(&ic->kwn_rtx_timer);
 #if ATH_DATA_TX_INFO_EN
     /*Free buffer for data TX info*/
     qdf_mem_free(scn->tx_status_buf);
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath_config.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath_config.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_ath_config.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_ath_config.c	2019-02-05 00:55:51.092691608 +0530
@@ -53,6 +53,8 @@
 #endif
 void ol_ath_reset_vap_stat(struct ieee80211com *ic);
 uint32_t promisc_is_active (struct ieee80211com *ic);
+extern void (*intimate_dying_gasp)(void *arg);
+extern void dying_gasp_fn ( void * arg ) ;
 
 extern int ol_ath_target_start(struct ol_ath_softc_net80211 *scn);
 extern void ol_ath_dump_target(struct ol_ath_softc_net80211 *scn);
@@ -1839,7 +1841,69 @@
             }
             break;
 #endif /* OL_ATH_CE_DEBUG */
-        case OL_ATH_PARAM_TXACKTIMEOUT:
+	case OL_ATH_PARAM_DYING_GASP:
+            {
+                if (value < 1 || value > 2) {
+                    retval = -EINVAL;
+                }
+                ic->dying_gasp = value;
+    		/*Dying gasp initialization only when enabled */
+		if ( value == 1) {
+    			intimate_dying_gasp = dying_gasp_fn;
+			printk("%s:Dying gasp enabled---->HZ: %d \n",__func__,HZ);
+		}
+		else if ( value == 2) {
+    			intimate_dying_gasp = NULL;
+			printk("%s:Dying gasp disabled---->HZ: %d \n",__func__,HZ);
+		}
+            }
+	    break;
+        case OL_ATH_PARAM_DG_TIMER_INTERVAL:
+            {
+            	ic->ic_dg_timer_interval = value;
+            }
+            break;
+        case OL_ATH_PARAM_DG_ACK_DISABLE:
+            {
+            	ic->ic_dg_ack_disable = value;
+            }
+            break;
+#if 0
+        case OL_ATH_PARAM_LINKID:
+            {
+            	ic->ic_link_id = value;
+            }
+            break;
+#endif
+        case OL_ATH_PARAM_STR_TYPE:
+            {
+            	ic->ic_str_type = value;
+            }
+            break;
+	case OL_ATH_PARAM_KWN_AMSDU:
+            {
+                if (value < 1 || value > 2) {
+                    retval = -EINVAL;
+                }
+                ic->kwn_amsdu = value;
+            }
+            break;
+	case OL_ATH_PARAM_TXDISTANCE: 
+	    value = value * 1000; //Distance in meters
+	    if ( value >= 0 && value < 53100 ) {
+		    u_int32_t acktimeout = (9+(value/300) + ((value % 300)?1:0));
+		    acktimeout = acktimeout * 2 + 3;
+
+		    if (acktimeout < DEFAULT_TX_ACK_TIMEOUT )
+			    acktimeout = DEFAULT_TX_ACK_TIMEOUT;
+		    else if (acktimeout > MAX_TX_ACK_TIMEOUT)
+			    acktimeout = MAX_TX_ACK_TIMEOUT;
+		    (void)ol_ath_pdev_set_param(scn,
+				    wmi_pdev_param_tx_ack_timeout, acktimeout, 0);
+		    scn->tx_ack_timeout = acktimeout;
+	    } 
+	    break;
+	case OL_ATH_PARAM_TXACKTIMEOUT:
             {
                 if ((scn->target_type == TARGET_TYPE_AR900B) || (scn->target_type == TARGET_TYPE_QCA9984) ||
                    (scn->target_type == TARGET_TYPE_QCA9888) || (scn->target_type == TARGET_TYPE_IPQ4019))
@@ -2374,6 +2438,25 @@
             }
             break;
 #endif /* OL_ATH_CE_DEBUG */
+        case OL_ATH_PARAM_DYING_GASP:
+                *(int *)buff = ic->dying_gasp;
+	    break;
+        case OL_ATH_PARAM_DG_TIMER_INTERVAL:
+            {
+            	*(int *)buff = ic->ic_dg_timer_interval;
+            }
+            break;
+        case OL_ATH_PARAM_KWN_AMSDU:
+                *(int *)buff = ic->kwn_amsdu;
+	    break;
+        case OL_ATH_PARAM_DG_ACK_DISABLE:
+            {
+            	*(int *)buff = ic->ic_dg_ack_disable ;
+            }
+            break;
+        case OL_ATH_PARAM_TXDISTANCE:
+                *(int *)buff = scn->tx_ack_timeout;
+	    break;
         case OL_ATH_PARAM_TXACKTIMEOUT:
             if ((scn->target_type == TARGET_TYPE_AR900B) || (scn->target_type == TARGET_TYPE_QCA9984) ||
                (scn->target_type == TARGET_TYPE_QCA9888) || (scn->target_type == TARGET_TYPE_IPQ4019))
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_phyerr.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_phyerr.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_phyerr.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_phyerr.c	2019-03-16 15:21:02.308662873 +0530
@@ -120,7 +120,7 @@
                 OS_MEMCPY(&chan_info, &phyerr.chan_info, sizeof(wmi_host_chan_info_t));
 
                 if (phyerr.phy_err_code == PHY_ERROR_SPECTRAL_SCAN) {
-                    spectral_process_phyerr(ic->ic_spectral, phyerr.bufp, phyerr.buf_len, &rfqual_info, &chan_info, phyerr.tsf64, &acs_stats);
+                    spectral_process_phyerr(ic->ic_spectral, phyerr.bufp, phyerr.buf_len, &rfqual_info, &chan_info, phyerr.tsf64, &acs_stats, ic);
                 }
 
 #if ATH_ACS_SUPPORT_SPECTRAL && ATH_SUPPORT_SPECTRAL
@@ -180,7 +180,7 @@
             OS_MEMCPY(&chan_info, &phyerr.chan_info, sizeof(wmi_host_chan_info_t));
 
             if ( phyerr.phy_err_mask0 & AR900B_SPECTRAL_PHYERR_MASK) {
-                spectral_process_phyerr(ic->ic_spectral, phyerr.bufp, phyerr.buf_len, &rfqual_info, &chan_info, phyerr.tsf64, &acs_stats);
+                spectral_process_phyerr(ic->ic_spectral, phyerr.bufp, phyerr.buf_len, &rfqual_info, &chan_info, phyerr.tsf64, &acs_stats,ic);
              }
 
 #if ATH_ACS_SUPPORT_SPECTRAL && ATH_SUPPORT_SPECTRAL
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_stats.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_stats.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_stats.c	2018-06-08 11:00:44.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_stats.c	2019-05-08 11:57:17.866151476 +0530
@@ -1467,6 +1467,10 @@
             while (msdu) {
                 rx_desc = htt_rx_msdu_desc_retrieve(txrx_pdev->htt_pdev,
                                                                     msdu);
+#if 0
+                hdr_des = txrx_pdev->htt_pdev->ar_rx_ops->wifi_hdr_retrieve(rx_desc);
+                wh = (struct ieee80211_frame*)hdr_des;
+#endif
                 /*  Here the mcast packets are decided on the basis that
                     the target sets "only" the forward bit for mcast packets.
                     If it is a normal packet then "both" the forward bit and
@@ -1507,6 +1511,11 @@
                 scn->scn_stats.rx_num_data++;
                 scn->scn_stats.rx_bytes += data_length;
                 scn->scn_stats.rx_data_bytes += data_length;
+#if 0
+                if( wh->i_fc[1] & IEEE80211_FC1_RETRY ) {
+                    ni->kwn_remote_retries++;
+                }
+#endif
             }
             ieee80211_free_node(ni);
             scn->scn_stats.rx_aggr = txrx_pdev->stats.priv.rx.normal.rx_aggr;
diff -urN qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_vap.c qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_vap.c
--- qca-wifi-org/offload/wlan/lmac_offload_if/ol_if_vap.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/lmac_offload_if/ol_if_vap.c	2019-05-01 20:34:47.514286489 +0530
@@ -32,6 +32,7 @@
 #if ATH_SUPPORT_GREEN_AP
 #include "ath_green_ap.h"
 #endif
+#include <linux/inetdevice.h>
 
 #define DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS  (IEEE80211_INACT_RUN * IEEE80211_INACT_WAIT)
 #define DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_IDLE_TIME_SECS          (DEFAULT_WLAN_VDEV_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS - 5)
@@ -65,6 +66,8 @@
 #define MAX_UNRESPONSIVE_TIME_MIN_THRESHOLD_SECS  5
 #define MAX_UNRESPONSIVE_TIME_MAX_THRESHOLD_SECS  (u_int16_t)~0
 
+struct timer_list       dg_timer;
+extern int dg_ack_rcvd;
 extern int ol_ath_set_vap_dscp_tid_map(struct ieee80211vap *vap);
 extern int ol_ath_ucfg_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
 static int wlan_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid)
@@ -728,6 +731,42 @@
 }
 #endif
 
+static int
+ol_kwn_ath_vap_set_param( struct ieee80211vap *vap,
+        ieee80211_param param, u_int32_t val )
+{
+    struct ieee80211com *ic = vap->iv_ic;
+    struct ol_ath_softc_net80211 *scn = OL_ATH_SOFTC_NET80211( ic );
+    struct ol_ath_vap_net80211 *avn = OL_ATH_VAP_NET80211( vap );
+    int retval = 0;
+
+    switch ( param ) {
+        case IEEE80211_FIXED_RATE:
+            {
+                if( vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_NONE ) {
+                    val = WMI_HOST_FIXED_RATE_NONE;
+                }
+                //printk(": WMI: HT Rate set val %d\n",val);
+                retval = ol_ath_wmi_send_vdev_param( scn, avn->av_if_id,
+                        wmi_vdev_param_fixed_rate, val );
+            }
+            break;
+        case IEEE80211_FIXED_VHT_MCS:
+            {
+                if( vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_NONE ) {
+                    val = WMI_HOST_FIXED_RATE_NONE;
+                }
+                //printk(": WMI: VHT Rate Set val %d \n",val);
+                retval = ol_ath_wmi_send_vdev_param( scn,avn->av_if_id,
+                        wmi_vdev_param_fixed_rate, val );
+            }
+            break;
+        default:
+            break;
+    }
+    return retval;
+}
+
 /* Vap interface functions */
 static int
 ol_ath_vap_set_param(struct ieee80211vap *vap,
@@ -852,6 +891,7 @@
                     }
                     val = (preamble << 6) | (nss << 4) | rix;
                 }
+                //printk(": WMI: HT Rate Set preamble %d nss %d rix %d val %d \n",preamble,nss,rix,val);
                 retval = ol_ath_wmi_send_vdev_param(scn,avn->av_if_id,
                                               wmi_vdev_param_fixed_rate, val);
            }
@@ -860,6 +900,9 @@
            {
                 if (vap->iv_fixed_rate.mode == IEEE80211_FIXED_RATE_VHT) {
                     val = (WMI_HOST_RATE_PREAMBLE_VHT << 6) | ((vap->iv_nss -1) << 4) | vap->iv_vht_fixed_mcs;
+                    //printk(": WMI: VHT Rate set val %d \n",val);
+                    ol_ath_wmi_send_vdev_param( scn, avn->av_if_id,
+                            wmi_vdev_param_nss, vap->iv_nss);
                 }
                 else {
                     /* Note: Event though val is 32 bits, only the lower 8 bits matter */
@@ -3254,7 +3297,30 @@
     vap->iv_256qam = 1;
 
     vap->iv_no_cac = 0;
-
+    /* Reset link profile tx parameters */
+    vap->kwn_txparam.spatial_stream = KWN_STREAM_AUTO;
+    vap->kwn_txparam.min_rate = 0;
+    vap->kwn_txparam.max_rate = 0;
+    vap->kwn_txparam.curr_inc_timer = 2;
+    vap->kwn_txparam.inc_timer = 2;
+    vap->kwn_txparam.dec_timer = 1;
+    vap->kwn_txparam.backoff_int = KWN_DDRS_BACKOFF_INT;
+    vap->kwn_txparam.rate_incr_thrld = 3;
+    vap->kwn_txparam.rtx_inc_thrld = 10;
+    vap->kwn_txparam.rtx_dec_thrld = 15;
+    vap->kwn_txparam.atpc_status = 0;
+    vap->kwn_txparam.power = 26;
+    vap->kwn_txparam.max_eirp = 0;
+
+    /* Initialize SCAN Parameters */
+    ic->enable_sa_scan = 0;
+    ic->enable_acs = 0;
+    ic->kwn_scan.sa_scan_time = 1000;
+    ic->kwn_scan.acs_scan_time = 1000;
+    ic->kwn_dcs.dcs_time = 30;
+    ic->kwn_dcs.dcs_triggered = 0;
+    ic->kwn_dcs.bl_timer_started = 0;
+    ic->kwn_dcs.bl_int = 1800;
     /* Intialize VAP interface functions */
     vap->iv_up = ol_ath_vap_up;
     vap->iv_join = ol_ath_vap_join;
@@ -3534,12 +3600,20 @@
 {
     struct ol_ath_vap_net80211 *avn = OL_ATH_VAP_NET80211(vap);
     struct ol_ath_softc_net80211 *scn = avn->av_sc;
+    struct ieee80211com *ic;
 
     if (!vap) {
         qdf_print("VAP is NULL!!!\n");
         return;
     }
 
+    ic = vap->iv_ic;
+    memset( &ic->kwn_scan.sa_result, 0, sizeof(struct kwn_sa_scan_result) );
+    memset( &ic->kwn_scan.acs_result, 0, sizeof(struct kwn_acs_result) );
+    OS_FREE_TIMER(&ic->kwn_scan.scan_timer);
+    OS_FREE_TIMER(&ic->kwn_scan.util_timer);
+    OS_FREE_TIMER(&ic->kwn_dcs.dcs_timer);
+    OS_FREE_TIMER(&ic->kwn_dcs.bl_timer);
     /* delete key before vdev delete */
     delete_default_vap_keys(vap);
 
@@ -3717,6 +3791,92 @@
     return 0;
 }
 
+#define WIFI1_INTERFACE "ath1"
+#define BRIDGE_INTERFACE "br-lan"
+
+void dying_gasp_fn ( void * arg ) 
+{
+    struct net_device *dev = dev_get_by_name ( &init_net, WIFI1_INTERFACE );
+
+    if ( dev != NULL ) {
+        osif_dev  *osdev = ath_netdev_priv(dev);
+        wlan_if_t vap = osdev->os_if;
+        struct ieee80211_node   *ni = NULL; 
+        union iwreq_data wreq = {{0}};
+
+        ni = vap->iv_bss;
+        if ( ni == NULL ) {
+            return;
+        }
+        /* Return from IRQ immediately by scheduling a timer */
+        if( ni->dg_count == 0 ) {
+            ni->dg_count++;
+            mod_timer(&dg_timer, jiffies + 1 );
+            dev_put(dev);
+            return;
+        }
+
+        /* Step1: Application Wireless Netlink Event for SNMP Trap */
+        if( ni->dg_count == 1 ) {
+            memset( &wreq, 0, sizeof( wreq ) );
+            wreq.addr.sa_family = ARPHRD_ETHER;
+            memcpy( wreq.addr.sa_data, ni->ni_macaddr, 6 );
+            if( ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP ) {
+                wreq.addr.sa_data[6] = IEEE80211_EV_BASE_DYING_GASP;
+            } else {
+                wreq.addr.sa_data[6] = IEEE80211_EV_SU_DYING_GASP;
+            }
+            wireless_send_event( dev, IWEVEXPIRED, &wreq, NULL );
+            /* Start Timer and return: This logic is added to make sure to get SNMP Trap get 
+               delivered over Ethernet interface */
+            ni->dg_count++;
+            mod_timer(&dg_timer, jiffies + ( (vap->iv_ic->ic_dg_timer_interval * HZ) /1000 ) );
+            dev_put(dev);
+            return;
+        }
+
+        /* Step2: DyingGasp Event(802.11 Action Frame) to remote partners */
+        ieee80211_send_dying_gasp( vap, 0, NULL );
+
+        /* Step3: DyingGasp Timer handling */
+        if( !dg_ack_rcvd ) {
+            if( vap->iv_ic->ic_dg_triggered ) {
+                u_int64_t curr_jiffies = jiffies;
+                unsigned long diff = curr_jiffies - vap->iv_ic->ic_dg_jiffies;
+                /* Issue: In the case when power is down and up within 20ms, DG Timer gets triggered and keeps on sending DG packets forever
+                 * which creates no link issue. This issue happens only in BSU.
+                 * Fix: In this case stop the DG Timer after 1sec and reset the dg triggered flag */
+                if( diff >= 5000 ) {
+                    printk(": DG: DeleteTimer: current jiffies %llu  last jiffies %llu diff %lu \n",
+                            curr_jiffies, vap->iv_ic->ic_dg_jiffies,diff);
+                    vap->iv_ic->ic_dg_triggered = 0;
+                    del_timer(&dg_timer);
+                    dev_put(dev);
+                    return;
+                } else {
+                    mod_timer(&dg_timer, jiffies + ( (vap->iv_ic->ic_dg_timer_interval * HZ) /1000 ) );
+                }
+            } else {
+                mod_timer(&dg_timer, jiffies + ( (vap->iv_ic->ic_dg_timer_interval * HZ) /1000 ));
+            }
+        } else {
+            del_timer(&dg_timer);
+        }
+        if( !vap->iv_ic->ic_dg_triggered ) {
+            vap->iv_ic->ic_dg_triggered = 1;
+            vap->iv_ic->ic_dg_jiffies = jiffies;
+        }
+
+        dev_put(dev);
+    }
+    return;
+}
+
+void dying_gasp_timer ( unsigned long  arg )
+{
+	struct ol_ath_softc_net80211 *scn = ( struct ol_ath_softc_net80211 *)arg;
+	dying_gasp_fn(scn);
+}
 /* Intialization functions */
 void
 ol_ath_vap_attach(struct ieee80211com *ic)
@@ -3728,6 +3888,7 @@
     ic->ic_vap_alloc_macaddr = ol_ath_vap_alloc_macaddr;
     ic->ic_vap_free_macaddr = ol_ath_vap_free_macaddr;
     ic->ic_vap_set_param = ol_ath_vap_set_param;
+    ic->ic_kwn_vap_set_param = ol_kwn_ath_vap_set_param;
     ic->ic_vap_sifs_trigger = ol_ath_vap_sifs_trigger;
     ic->ic_vap_set_ratemask = ol_ath_vap_set_ratemask;
     ic->ic_vap_dyn_bw_rts = ol_ath_vap_dyn_bw_rts;
@@ -3754,6 +3915,7 @@
         ath_green_ap_start(ic);
     }
 #endif  /* ATH_SUPPORT_GREEN_AP */
+   setup_timer(&dg_timer, dying_gasp_timer, (unsigned long)scn );
 }
 
 
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain.c qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.c
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.c	2018-07-22 10:56:39.796784660 +0530
@@ -1525,12 +1525,21 @@
     if (regdmn == OVERRIDE_RD && ol_regdmn_duplicate_channel(icv, chans, *next+1))
         return;
     icv->ic_ieee = ol_ath_mhz2ieee(ic, icv->ic_freq, icv->ic_flags);
+#if 0
     if(vht_ch_freq_seg1) {
         icv->ic_vhtop_ch_freq_seg1 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg1, icv->ic_flags);
     }
     else {
         icv->ic_vhtop_ch_freq_seg1 = 0;
     }
+#else
+    if( cm->mode == REGDMN_MODE_11AC_VHT80 ) {
+        icv->ic_vhtop_ch_freq_seg1 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg1, icv->ic_flags);
+    }
+    else {
+        icv->ic_vhtop_ch_freq_seg1 = 0;
+    }
+#endif
     if(vht_ch_freq_seg2) {
         icv->ic_vhtop_ch_freq_seg2 = ol_ath_mhz2ieee(ic, vht_ch_freq_seg2, icv->ic_flags);
     }
@@ -1566,13 +1575,14 @@
     u_int16_t chanSep;
     ol_scn_t scn_handle;
     struct ieee80211com *ic;
-    u_int32_t ch144, ch144_eppr_ovrd;
+    //int i;
+    //u_int32_t ch144, ch144_eppr_ovrd;
 
     struct ol_ath_softc_net80211 *scn = NULL;
     scn_handle = ol_regdmn_handle->scn_handle;
     ic = &scn_handle->sc_ic;
     sec_channel_count = 0;
-    ch144_eppr_ovrd = 0;
+    //ch144_eppr_ovrd = 0;
 
     scn = OL_ATH_SOFTC_NET80211(ic);
     /*
@@ -1898,6 +1908,7 @@
         // Walk through the 5G band to find 80 Mhz channel
         else  if ((cm->mode == REGDMN_MODE_11AC_VHT80) && (rd == &rd5GHz))
         {
+#if 0
             ol_regdmn_init_vht80_chan(&vht80_chans);
 
             if (regdmn != OVERRIDE_RD) {
@@ -1925,6 +1936,10 @@
                 ol_regdmn_add_vht80_chan(&vht80_chans, 5690);
                 ol_regdmn_add_vht80_chan(&vht80_chans, 5775);
             }
+#else
+                hi_adj = -30;
+                low_adj = 30;
+#endif
         }
 
         if(rd == &rd2GHz) {
@@ -1959,6 +1974,7 @@
                     (!is_49ghz_cap) && (regdmn != OVERRIDE_RD))
                     continue;
 
+#if 0
                 if (((IS_HT40_MODE(cm->mode)) || (IS_VHT40_MODE(cm->mode))) && (rd == &rd5GHz)) {
                     /* For 5G HT40 mode, channel seperation should be 40. */
                     chanSep = 40;
@@ -1993,7 +2009,9 @@
                         }
                     }
                 }
-
+#else
+                    chanSep = fband->channelSep;
+#endif
                 for (c=fband->lowChannel + low_adj;
                      ((c <= (fband->highChannel + hi_adj)) &&
                       (c >= (fband->lowChannel + low_adj)));
@@ -2069,6 +2087,7 @@
                         QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Skipping HT40 channel (en_jap_dfs_ht40 = 0)\n");
                         continue;
                     }
+#if 0
                     if(rd == &rd5GHz)
                     {
                         /*
@@ -2125,7 +2144,7 @@
                             }
                         }
                     }
-
+#endif
                     OS_MEMZERO(&icv, sizeof(icv));
                     if(cm->mode == REGDMN_MODE_11AC_VHT80_80) {
 
@@ -2188,16 +2207,18 @@
                          * For all 4.9G, VHT80 is not allowed.
                          * Except for CTRY_DEBUG.
                          */
-                        if ((fband->lowChannel < 5180) && (cc != CTRY_DEBUG) && (regdmn != OVERRIDE_RD)) {
+                        if ((fband->lowChannel < 4920) && (cc != CTRY_DEBUG) && (regdmn != OVERRIDE_RD)) {
                             continue;
                         }
-
+#if 0
                         if(!ol_regdmn_find_vht80_chan(&vht80_chans, c, &vht_ch_freq_seg1)) {
                             if (regdmn != OVERRIDE_RD){
                                 QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, KERN_INFO"Skipping VHT80 channel %d\n", c);
                             }
                             continue;
                         }
+#endif
+                        vht_ch_freq_seg1 = c;
                         vht_ch_freq_seg2 = 0;
                         if (ol_validate_restricted_channel(scn_handle, cm, c, vht_ch_freq_seg1, vht_ch_freq_seg2)) {
                             populate_icv(&icv, c, vht_ch_freq_seg1, vht_ch_freq_seg2, fband, 0,  cm, rd, rd5GHz, dfsDomain, scn_handle, regdmn, chans, &next);
@@ -2234,6 +2255,16 @@
 
     ieee80211_set_nchannels(ic, next);
 
+    {
+	    uint32_t m;
+	    for( m = 0; m < ic->ic_nchans; m++ )
+	    {
+		    if( m == 0 )
+			    ic->kwn_start_freq = ic->ic_channels[m].ic_freq;	
+		    ic->kwn_end_freq = ic->ic_channels[m].ic_freq;	
+	    }
+	    ic->kwn_curr_freq = ic->kwn_start_freq;
+    }
     /* save for later query */
     ol_regdmn_handle->ol_regdmn_currentRDInUse = regdmn;
     ol_regdmn_handle->ol_regdmn_currentRD5G = rd5GHz.regDmnEnum;
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain_common.h qca-wifi-mod/offload/wlan/regdmn/ol_regdomain_common.h
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain_common.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain_common.h	2019-01-18 18:19:42.607585601 +0530
@@ -52,6 +52,16 @@
 	NO_ENUMRD	= 0x00,
     OVERRIDE_RD = 0x01,
 	NULL1_WORLD	= 0x03,		/* For 11b-only countries (no 11a allowed) */
+	SF_RUSSIA_49_51 = 0x04,		/* Sify custom  */
+	SF_RUSSIA_51_53 = 0x05,		/* Sify custom */
+	SF_RUSSIA_53_56 = 0x06,		/* Sify custom */
+	SF_RUSSIA_56_58 = 0x09,		/* Sify custom */
+	SF_RUSSIA_58_59 = 0x24,		/* Sify custom */
+	SF_INDIA_UL     = 0x25,		/* Sify custom */
+	SF_INDIA_L      = 0x27,		/* Sify custom */
+	SF_INDIA        = 0x28,		/* Sify custom */
+	SF_INDIA_5      = 0x29,		/* Sify custom */
+
 	NULL1_ETSIB	= 0x07,		/* Israel */
 	NULL1_ETSIC	= 0x08,
 	FCC1_FCCA	= 0x10,		/* USA */
@@ -216,7 +226,16 @@
 
 	NULL1		= 0x0198,
 	WORLD		= 0x0199,
-	DEBUG_REG_DMN	= 0x01ff,
+    DEBUG_REG_DMN	= 0x01ff,
+    RUSSIA01    = 0x0201,   /* Sify custom */ 
+    RUSSIA02    = 0x0202,   /* Sify custom */
+    RUSSIA03    = 0x0203,   /* Sify custom */
+    RUSSIA04    = 0x0204,   /* Sify custom */
+    RUSSIA05    = 0x0205,   /* Sify custom */
+    INDIAUL     = 0x0206,   /* Sify custom */
+    INDIAL      = 0x0207,   /* Sify custom */
+    INDIA       = 0x0208,   /* Sify custom */
+    INDIA_5     = 0x0209,   /* Sify custom */
     OVER1_OVERA = 0x0200,
 };
 
@@ -354,6 +373,15 @@
 	{WORA_WORLD,	WORA_WORLD,	WORA_WORLD,	DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{WORB_WORLD,	WORB_WORLD,	WORB_WORLD,	DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 },
 	{WORC_WORLD,	WORC_WORLD,	WORC_WORLD,	NO_REQ, NO_REQ, PSCAN_DEFER, 0 },
+	{SF_RUSSIA_49_51,	RUSSIA01,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_51_53,	RUSSIA02,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_53_56,	RUSSIA03,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_56_58,	RUSSIA04,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_RUSSIA_58_59,	RUSSIA05,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_INDIA_UL,	    INDIAUL,		WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_INDIA_L,	    INDIAL,		    WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_INDIA,	        INDIA,		    WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }, /* Sify custom */
+	{SF_INDIA_5,        INDIA_5,	    WORLD,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB, NO_REQ, PSCAN_DEFER, 0 }  /* Sify custom */
 };
 
 /*
@@ -561,7 +589,16 @@
     {CTRY_VIRGIN_ISLANDS, FCC3_FCCA,  "VI", "VIRGIN ISLANDS", YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_WALLIS_FUTUNA, ETSI1_WORLD, "WF", "WALLIS AND FUTUNA", YES, YES, YES, YES, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, NO, NO, 7000 },
-    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  YES,  YES, YES, YES, YES, 7000 }
+    {CTRY_ZIMBABWE,    ETSI1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  YES,  YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_1, SF_RUSSIA_49_51,  "S1", "RUSSIA1",        YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_2, SF_RUSSIA_51_53,  "S2", "RUSSIA2",        YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_3, SF_RUSSIA_53_56,  "S3", "RUSSIA3",        YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_4, SF_RUSSIA_56_58,  "S4", "RUSSIA4",        YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_RUSSIA_5, SF_RUSSIA_58_59,  "S5", "RUSSIA5",        YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_INDIA_UL,     SF_INDIA_UL,  "S6", "INDIA1",         YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_INDIA_L,      SF_INDIA_L,   "S7", "INDIA2",         YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_SIFY_INDIA,   SF_INDIA,     "S8", "INDIA3",         YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 },
+    {CTRY_SIFY_INDIA_5, SF_INDIA_5,   "S9", "INDIA4",         YES,  NO,  NO, YES, YES, YES, YES, YES, YES, YES, 7000 }
 };
 
 
@@ -705,6 +742,16 @@
 	W1_5260_5320,
 	W1_5745_5825,
 	W1_5500_5700,
+    RU_4920_5925,
+    RU_5150_5350,   /* Sify custom */
+    RU_5350_5600,   /* Sify custom */
+    RU_5600_5850,   /* Sify custom */
+    RU_5850_5925,   /* Sify custom */
+    INUL_5825_5875, /* Sify custom */
+    INL_5725_5875,  /* Sify custom */
+    IN_5110_5340,   /* Sify custom */
+    IN_5480_5915,   /* Sify custom */
+    IN5_5110_5915,  /* Sify custom */
 	A_DEMO_ALL_CHANNELS,
     OVERRIDE_MODE_ALL_CHANNELS_5,
     OVERRIDE_MODE_ALL_CHANNELS_10,
@@ -844,6 +891,18 @@
 	{ 5260, 5320, 30, 0, 20, 20, DFS_FCC3 | DFS_ETSI, PSCAN_WWR, 0 },		/* W1_5260_5320 */
 	{ 5745, 5825, 30, 0, 20, 20, NO_DFS, PSCAN_WWR, 0 },				/* W1_5745_5825 */
 	{ 5500, 5700, 30, 0, 20, 20, DFS_FCC3 | DFS_ETSI, PSCAN_WWR, 0 },		/* W1_5500_5700 */
+
+    { 4920, 5925, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_4920_5925 custom */
+    { 5150, 5350, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5150_5350 custom */
+    { 5350, 5600, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5350_5600 custom */
+    { 5600, 5850, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5600_5850 custom */
+    { 5850, 5925, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* RU_5850_5925 custom */
+    { 5825, 5875, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* INUL_5825_5875 custom */
+    { 5725, 5875, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* INL_5725_5875 custom */
+    { 5110, 5340, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* IN_5110_5340 custom */
+    { 5480, 5915, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* IN_5480_5915 custom */
+    { 5110, 5915, 30, 0, 20, 5, NO_DFS, PSCAN_ETSI, 0 },                /* IN5_5110_5915 custom */
+
 	{ 4920, 6100, 30, 6, 20, 20, NO_DFS, NO_PSCAN, 0 },				/* A_DEMO_ALL_CHANNELS */
     { 4920, 6100, 50, 20, 20, 5,  DFS_FCC3 | DFS_ETSI | DFS_MKK4, NO_PSCAN, 0 },             /* OVERRIDE_MODE_ALL_CHANNELS_5 */
     { 4920, 6100, 50, 20, 20, 10, DFS_FCC3 | DFS_ETSI | DFS_MKK4, NO_PSCAN, 0 },             /* OVERRIDE_MODE_ALL_CHANNELS_10 */
@@ -1066,7 +1125,7 @@
 	{ 2412, 2472, 5,  6, 20, 5, NO_DFS, NO_PSCAN, 0},	/* F1_2412_2472 */
 	{ 2412, 2472, 20, 0, 20, 5, NO_DFS, PSCAN_MKKA, 30},/* F2_2412_2472 */
 	{ 2412, 2472, 30, 0, 20, 5, NO_DFS, NO_PSCAN, 4},	/* F3_2412_2472 */
-	{ 2412, 2472, 20, 0, 20, 5, NO_DFS, PSCAN_MKKA, 0},	/* F4_2412_2472 */
+	{ 2412, 2472, 30, 0, 20, 5, NO_DFS, PSCAN_MKKA, 0},	/* F4_2412_2472 */
 
 	{ 2412, 2462, 30, 6, 20, 5, NO_DFS, NO_PSCAN, 12},	/* F1_2412_2462 */
 	{ 2412, 2462, 20, 0, 20, 5, NO_DFS, PSCAN_MKKA, 30},	/* F2_2412_2462 */
@@ -1145,7 +1204,7 @@
 	{ 2412, 2472, 5,  6, 20, 5, NO_DFS, NO_PSCAN, 0},	/* G1_2412_2472 */
 	{ 2412, 2472, 20, 0, 20, 5,  NO_DFS, PSCAN_MKKA_G | PSCAN_MKKA2 | PSCAN_MKKA | PSCAN_EXT_CHAN, 30},	/* G2_2412_2472 */
 	{ 2412, 2472, 30, 0, 20, 5, NO_DFS, NO_PSCAN, 4},	/* G3_2412_2472 */
-	{ 2412, 2472, 20, 0, 20, 5,  NO_DFS, PSCAN_MKKA_G | PSCAN_MKKA2 | PSCAN_MKKA | PSCAN_EXT_CHAN, 0},	/* G4_2412_2472 */
+	{ 2412, 2472, 30, 0, 20, 5,  NO_DFS, PSCAN_MKKA_G | PSCAN_MKKA2 | PSCAN_MKKA | PSCAN_EXT_CHAN, 0},	/* G4_2412_2472 */
 
 	{ 2412, 2462, 30, 6, 20, 5, NO_DFS, NO_PSCAN, 12},	/* G1_2412_2462 */
 	{ 2412, 2462, 20, 0, 20, 5, NO_DFS, PSCAN_MKKA_G, 30},	/* G2_2412_2462 */
@@ -1189,7 +1248,7 @@
 static const REG_DMN_FREQ_BAND regDmn2Ghz11gTurboFreq[] = {
 	{ 2312, 2372, 5,  6, 40, 40, NO_DFS, NO_PSCAN, 0},  /* T1_2312_2372 */
 	{ 2437, 2437, 5,  6, 40, 40, NO_DFS, NO_PSCAN, 0},  /* T1_2437_2437 */
-	{ 2437, 2437, 20, 6, 40, 40, NO_DFS, NO_PSCAN, 0},  /* T2_2437_2437 */
+	{ 2437, 2437, 30, 6, 40, 40, NO_DFS, NO_PSCAN, 0},  /* T2_2437_2437 */
 	{ 2437, 2437, 18, 6, 40, 40, NO_DFS, PSCAN_WWR, 0}, /* T3_2437_2437 */
 	{ 2512, 2732, 5,  6, 40, 40, NO_DFS, NO_PSCAN, 0},  /* T1_2512_2732 */
 };
@@ -1221,6 +1280,88 @@
      CHAN_TURBO_G_BMZERO
      },
 
+    {RUSSIA01, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_4920_5925, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA02, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5150_5350, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA03, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5350_5600, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA04, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5600_5850, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {RUSSIA05, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(RU_5850_5925, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIAUL, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(INUL_5825_5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIAL, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(INL_5725_5875, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIA, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(IN_5110_5340, IN_5480_5915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+    {INDIA_5, ETSI, NO_DFS, NO_PSCAN, DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB,
+        BM(IN5_5110_5915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        BMZERO,
+        CHAN_TURBO_G_BMZERO
+    },
+
+
 #ifndef ATH_NO_5G_SUPPORT
 	{APL1, FCC, NO_DFS, NO_PSCAN, NO_REQ,
 	 BM(F4_5745_5825, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
diff -urN qca-wifi-org/offload/wlan/regdmn/ol_regdomain.h qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.h
--- qca-wifi-org/offload/wlan/regdmn/ol_regdomain.h	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/regdmn/ol_regdomain.h	2019-01-18 18:19:32.819676302 +0530
@@ -1063,7 +1063,16 @@
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
     CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
     CTRY_ARGENTINA2           = 5003,    /* Argentina for AP only */
-    CTRY_INDIA2               = 5006     /* India with 5.9GHz support */
+    CTRY_INDIA2               = 5006,    /* India with 5.9GHz support */
+    CTRY_RUSSIA_1             = 5011,    /* Russia 4920-5150 support */
+    CTRY_RUSSIA_2             = 5012,    /* Russia 5150-5350 support */
+    CTRY_RUSSIA_3             = 5013,    /* Russia 5350-5600 support */
+    CTRY_RUSSIA_4             = 5014,    /* Russia 5600-5850 support */
+    CTRY_RUSSIA_5             = 5015,    /* Russia 5850-5925 support */
+    CTRY_INDIA_UL             = 5016,    /* India 5825-5875 support */
+    CTRY_INDIA_L              = 5017,    /* India 5725-5875 support */
+    CTRY_SIFY_INDIA           = 5018,    /* India 5100-5925 support */
+    CTRY_SIFY_INDIA_5         = 5019     /* 5GHz 5100-5925 support */
 };
 
 
diff -urN qca-wifi-org/offload/wlan/txrx/ol_rx.c qca-wifi-mod/offload/wlan/txrx/ol_rx.c
--- qca-wifi-org/offload/wlan/txrx/ol_rx.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/txrx/ol_rx.c	2019-05-08 11:57:42.526329144 +0530
@@ -1377,7 +1377,59 @@
         }
     }
 #endif
+#if 1
+    /* Updating Local SNR per node */
+    {
+        struct ieee80211_node *ni = NULL;
+        struct ieee80211vap *vap = NULL;
+        //u_int8_t i;
+        void *rx_desc = htt_rx_msdu_desc_retrieve( pdev->htt_pdev, deliver_list_head );
+        //uint32_t ppdu_start;
+        //uint32_t *ppdu;
+        struct ieee80211_frame *wh;
+
+        //ppdu_start = pdev->htt_pdev->ar_rx_ops->get_ppdu_start_word( rx_desc );
+        wh = (struct ieee80211_frame *)htt_pdev->ar_rx_ops->wifi_hdr_retrieve(rx_desc);
+        //ppdu = &ppdu_start;
 
+        vap = ol_ath_getvap( vdev );
+        ni = ieee80211_vap_find_node( vap, peer->mac_addr.raw );
+        if( ni ) {
+            //ni->kwn_rx_pkts++;
+            if( wh->i_fc[1] & IEEE80211_FC1_RETRY ) {
+                ni->kwn_remote_retries++;
+               // ni->remote_retries++;
+               // ni->kwn_rx_pkts++;
+               // ni->kwn_rrx_pkts++;
+            }
+#if 0
+            if( ni->kwn_snr_avg.snr_indx > KWN_SNR_SAMPLES_MAX )
+                ni->kwn_snr_avg.snr_indx = 0;
+            if( ni->kwn_snr_avg.sample_count < KWN_SNR_SAMPLES_MAX )
+                ni->kwn_snr_avg.sample_count++;
+            //printk(" ppdu %x %x %x %x %x %x %x %x %x %x %x \n",ppdu[0],ppdu[1],ppdu[2],ppdu[3],ppdu[4],ppdu[5],ppdu[6],ppdu[7],ppdu[8],ppdu[9],ppdu[10]);
+            for (i = 0; i < IEEE80211_MAX_ANTENNA; i++) {
+                switch(i) {
+                    case 0:
+                        ni->kwn_snr_avg.local_snr[i][ni->kwn_snr_avg.snr_indx] = (ppdu[1] & 0x000000ff ); /* rssi ctl0 */
+                        break;
+                    case 1:
+                        ni->kwn_snr_avg.local_snr[i][ni->kwn_snr_avg.snr_indx] = ( ppdu[2] & 0x000000ff ); /* rssi ctl1 */
+                        break;
+                    case 2:
+                        ni->kwn_snr_avg.local_snr[i][ni->kwn_snr_avg.snr_indx] = ( ppdu[3] & 0x000000ff ); /* rssi ctl2 */;
+                        break;
+                    default:
+                        break;
+                }
+            }
+            ni->kwn_snr_avg.snr_indx++;
+#endif
+            /* remove extra node ref count added by find_node above */
+            ieee80211_free_node(ni);
+        }
+    }
+#endif
     vdev->osif_rx(vdev->osif_vdev, deliver_list_head);
 #if OL_ATH_SUPPORT_LED
     {
diff -urN qca-wifi-org/offload/wlan/txrx/ol_tx.c qca-wifi-mod/offload/wlan/txrx/ol_tx.c
--- qca-wifi-org/offload/wlan/txrx/ol_tx.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/txrx/ol_tx.c	2019-04-12 18:53:15.693391577 +0530
@@ -1768,6 +1768,14 @@
         htt_ffcache_update_extvalid(hdr_cache, 0);
     }
 #endif
+    tid = wbuf_get_priority(netbuf);
+    if( tid > 8 ) {
+      /* BE: 0, BK: 1, VI: 4, VO: 6 */
+      tid = 6;
+    }
+    else {
+      tid = 0;
+    }
     htt_ffcache_update_tid(hdr_cache, tid);
 
     data = skb_push(netbuf, vdev->htc_htt_hdr_size);//qdf_nbuf_push_head(netbuf, vdev->htc_htt_hdr_size);
diff -urN qca-wifi-org/offload/wlan/txrx/ol_tx_send.c qca-wifi-mod/offload/wlan/txrx/ol_tx_send.c
--- qca-wifi-org/offload/wlan/txrx/ol_tx_send.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/txrx/ol_tx_send.c	2019-02-04 10:43:22.560630518 +0530
@@ -346,7 +346,7 @@
     }
 }
 
-void populate_tx_info(struct ol_ath_softc_net80211 *scn, qdf_nbuf_t  netbuf,  int i, int num_msdus, enum htt_tx_status status, struct ieee80211_tx_status  *ts, uint8_t mhdr_len, bool is_raw)
+void populate_tx_info(struct ol_ath_softc_net80211 *scn, qdf_nbuf_t  netbuf,  int i, int num_msdus, enum htt_tx_status status, struct ieee80211_tx_status  *ts, uint8_t mhdr_len, bool is_raw, struct ol_txrx_peer_t *peer)
 {
     struct ieee80211com *ic = &(scn->sc_ic);
     struct ethhdr * eh = NULL;
@@ -358,6 +358,9 @@
 #endif
     struct ieee80211_frame *mac_hdr = NULL;
     uint8_t *dest_addr = NULL;
+    struct ieee80211vap *vap = NULL;
+    struct ieee80211_node *ni = NULL;
+    uint8_t retry = 0;
 
 /* Access MAC header at offset of mhdr_len since we expect meta header
  * of size mhdr_len incase of mesh vap mode.
@@ -372,18 +375,30 @@
 
     is_mcast = (IS_MULTICAST(dest_addr)) ? 1 : 0;
 
+    vap = TAILQ_FIRST( &ic->ic_vaps );
     if (qdf_likely(!is_mcast)) {
         if (qdf_likely(status == htt_tx_status_ok)){
             ts->ts_flags |= IEEE80211_TX_SUCCESS;
         } else if(status == htt_tx_status_discard) {
+            retry = 1;
             ts->ts_flags |= IEEE80211_TX_DROP;
         } else if(status == htt_tx_status_no_ack) {
+            retry = 1;
             ts->ts_flags |= IEEE80211_TX_XRETRY;
         } else {
+            retry = 1;
             ts->ts_flags |= IEEE80211_TX_ERROR;
         }
         ts->msdu_length = qdf_nbuf_len(netbuf);
 
+        if( retry ) 
+        {
+            ni = ieee80211_vap_find_node( vap, peer->mac_addr.raw );
+            if( ni != NULL ) {
+                ni->kwn_send_retry = 1;
+                ieee80211_free_node(ni);
+            }
+        }
 #ifdef QCA_NSS_WIFI_OFFLOAD_SUPPORT
         pdev = (struct ol_txrx_pdev_t *) scn->pdev_txrx_handle;
         if (pdev && pdev->nss_wifiol_ctx) {
@@ -408,7 +423,7 @@
         }
 
         /* replace tx_info_dump() with callback here */
-        tx_info_dump(ic, ts, dest_addr);
+        //tx_info_dump(ic, ts, dest_addr);
 
         /*reset the tx info*/
         ts->ts_flags = 0;
@@ -563,7 +578,7 @@
 
 #if ATH_DATA_TX_INFO_EN
             if(scn->enable_perpkt_txstats) {
-                populate_tx_info(scn, netbuf, i, num_msdus, status, scn->tx_status_buf, mhdr_len, is_raw);
+                populate_tx_info(scn, netbuf, i, num_msdus, status, scn->tx_status_buf, mhdr_len, is_raw, peer);
             }
 #endif
             if (ppdu_peer_id_filled) {
diff -urN qca-wifi-org/offload/wlan/umac_offload_if/ol_if_mgmt.c qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_mgmt.c
--- qca-wifi-org/offload/wlan/umac_offload_if/ol_if_mgmt.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_mgmt.c	2019-05-14 19:05:09.879721234 +0530
@@ -666,11 +666,14 @@
 #define QBOOST_ENABLE  1
 #define QBOOST_DISABLE 0
 	if(qboost_cfg) {
+        printk("#################### Enable QBOOST \n");
 		(void)wmi_unified_set_qboost_param(OL_ATH_VAP_NET80211(vap),
 				OL_ATH_NODE_NET80211(ni), QBOOST_ENABLE);
-	}else
+	}else {
+        printk("#################### Disable QBOOST \n");
 		(void)wmi_unified_set_qboost_param(OL_ATH_VAP_NET80211(vap),
 				OL_ATH_NODE_NET80211(ni), QBOOST_DISABLE);
+    }
 }
 
 void
@@ -1028,9 +1031,10 @@
     uint8_t *bufp;
     uint32_t len;
     wbuf_t wbuf;
+    struct ieee80211vap *vap = NULL;
 #if BCN_PROCESS_OPTIMIZE
+    struct ieee80211vap *last_vap = NULL;
     int bcn_processed_apvap = 0;
-    struct ieee80211vap *vap = NULL, *last_vap = NULL;
     wbuf_t wbuf1;
 #endif
 
@@ -1051,6 +1055,16 @@
         return 0;
     }
 
+    vap = TAILQ_FIRST(&ic->ic_vaps);
+    if( vap == NULL )
+    {
+        printk("################# VAP is NULL \n");
+    }
+    if( vap == NULL || ( vap != NULL && ( !vap->kwn_softreset  || ic->enable_acs || ic->enable_sa_scan ) ) ) {
+        //printk(": KWN: Softreset is in progress...drop rx mgmt packet\n");
+        return 0;
+    }
+
     len = roundup(rx_event.buf_len, sizeof(u_int32_t));
     wbuf =  wbuf_alloc(ic->ic_osdev, WBUF_RX_INTERNAL,
                        len);
diff -urN qca-wifi-org/offload/wlan/umac_offload_if/ol_if_scan.c qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_scan.c
--- qca-wifi-org/offload/wlan/umac_offload_if/ol_if_scan.c	2018-06-08 11:00:45.000000000 +0530
+++ qca-wifi-mod/offload/wlan/umac_offload_if/ol_if_scan.c	2018-07-26 18:32:49.533035382 +0530
@@ -975,7 +975,7 @@
     return EINVAL;
 
 }
-
+#if 0
 static const u_int16_t default_scan_order[] = {
     /* 2.4Ghz ch: 1,6,11,7,13 */
     2412, 2437, 2462, 2442, 2472,
@@ -1007,7 +1007,36 @@
     /* Add MKK quarter-rates */
     4912, 4917, 4922, 4927, 4932, 4937, 5032, 5037, 5042, 5047, 5052, 5057,
 };
-
+#else
+static const u_int16_t default_scan_order[] = {
+    2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 
+    2462, 2467, 2472, 2477, 2482, 2487, 2492, 2497,
+    4920, 4925, 4930, 4935, 4940, 4945, 4950, 4955, 4960, 4965,
+    4970, 4975, 4980, 4985, 4990, 4995, 5000, 5005, 5010, 5015,
+    5020, 5025, 5030, 5035, 5040, 5045, 5050, 5055, 5060, 5065,
+    5070, 5075, 5080, 5085, 5090, 5095, 5100, 5105, 5110, 5115,
+    5120, 5125, 5130, 5135, 5140, 5145, 5150, 5155, 5160, 5165,
+    5170, 5175, 5180, 5185, 5190, 5195, 5200, 5205, 5210, 5215, 
+    5220, 5225, 5230, 5235, 5240, 5245, 5250, 5255, 5260, 5265, 
+    5270, 5275, 5280, 5285, 5290, 5295, 5300, 5305, 5310, 5315, 
+    5320, 5325, 5330, 5335, 5340, 5345, 5350, 5355, 5360, 5365, 
+    5370, 5375, 5380, 5385, 5390, 5395, 5400, 5405, 5410, 5415, 
+    5420, 5425, 5430, 5435, 5440, 5445, 5450, 5455, 5460, 5465, 
+    5470, 5475, 5480, 5485, 5490, 5495, 5500, 5505, 5510, 5515, 
+    5520, 5525, 5530, 5535, 5540, 5545, 5550, 5555, 5560, 5565, 
+    5570, 5575, 5580, 5585, 5590, 5595, 5600, 5605, 5610, 5615, 
+    5620, 5625, 5630, 5635, 5640, 5645, 5650, 5655, 5660, 5665, 
+    5670, 5675, 5680, 5685, 5690, 5695, 5700, 5705, 5710, 5715, 
+    5720, 5725, 5730, 5735, 5740, 5745, 5750, 5755, 5760, 5765, 
+    5770, 5775, 5780, 5785, 5790, 5795, 5800, 5805, 5810, 5815, 
+    5820, 5825, 5830, 5835, 5840, 5845, 5850, 5855, 5860, 5865, 
+    5870, 5875, 5880, 5885, 5890, 5895, 5900, 5905, 5910, 5915, 
+    5920, 5925, 5930, 5935, 5940, 5945, 5950, 5955, 5960, 5965, 
+    5970, 5975, 5980, 5985, 5990, 5995, 6000, 6005, 6010, 6015, 
+    6020, 6025, 6030, 6035, 6040, 6045, 6050, 6055, 6060, 6065, 
+    6070, 6075, 6080, 6085, 6090, 6095, 6100
+};
+#endif
 /*
  * get all the channels to scan .
  * can be called whenever the set of supported channels are changed.
@@ -1021,8 +1050,10 @@
     struct ol_ath_softc_net80211 *scn = OL_ATH_SOFTC_NET80211(ic);
     u_int16_t *scan_order = (u_int16_t *)default_scan_order;
     u_int32_t scan_order_size = IEEE80211_N(default_scan_order);
-    int i = 0;
+    int i = 0, j =0;
+    int fixed_chan;
     struct scan_chan_list_params *param;
+    struct ieee80211_acs *acs = ic->ic_acs;
 
     param = (struct scan_chan_list_params *)
         kmalloc((sizeof(struct scan_chan_list_params) +
@@ -1035,6 +1066,30 @@
 
     ss->ss_nallchans = 0;
     ss->ss_nchans = 0;
+    /* Fixed channel support in client mode */
+    if( ic->sta_freq > 0 ) {
+       scan_order_size = 1;
+       fixed_chan = ic->sta_freq;
+    }
+    else {
+        /* In case of ACS, Sending 40 channels for scanning to firmware in one iteration */
+        for( i=ic->kwn_curr_freq; i<=ic->kwn_end_freq; i+=5 ) {
+            if( j > 40 )
+                break;
+            scan_order[j] = i;
+            acs->acs_ieee_chan[j] = ieee80211_mhz2ieee(ic, i, 0);
+            j++;
+        }
+        acs->acs_nchans_scan = j;
+	    scan_order_size = j;
+            /* Moving current freq to next iteration first freq,
+	       if current freq > end freq, move current freq to start freq */
+	    ic->kwn_curr_freq = scan_order[j-1] + 5;
+	    if( ic->kwn_curr_freq > ic->kwn_end_freq )
+		ic->kwn_curr_freq = ic->kwn_start_freq;
+            /* If scan order size is 1, updating fixed channel as this parameter is used for scanning below */
+		fixed_chan = scan_order[0];
+    }
 
     if (ic->ic_custom_scan_order_size > 0) {
         QDF_PRINT_INFO(QDF_PRINT_IDX_SHARED, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Using custom scan order\n"),
@@ -1045,7 +1100,12 @@
     spin_lock(&ss->ss_lock);
 
     for (i = 0; i < scan_order_size; ++i) {
-        c = ol_ath_find_full_channel(ic,scan_order[i]);
+        if( scan_order_size == 1 ) {
+            c = ol_ath_find_full_channel(ic,fixed_chan);
+        }
+        else {
+            c = ol_ath_find_full_channel(ic,scan_order[i]);
+        }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1060,12 +1120,18 @@
     /* Iterate again adding half-rate and quarter-rate channels */
     for (i = 0; i < scan_order_size; ++i) {
 
-        if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD)
+        if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD && scan_order_size != 1)
             continue;
 
         c = NULL;
-        c = ieee80211_find_channel(ic, scan_order[i], 0,
-                                   (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        if( scan_order_size == 1 ) {
+            c = ieee80211_find_channel(ic, fixed_chan, 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        }
+        else {
+            c = ieee80211_find_channel(ic, scan_order[i], 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_HALF));
+        }
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
 #else
@@ -1075,8 +1141,14 @@
         }
 
         c = NULL;
-        c = ieee80211_find_channel(ic, scan_order[i], 0,
-                                   (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        if( scan_order_size == 1 ) {
+            c = ieee80211_find_channel(ic, fixed_chan, 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        }
+        else {
+            c = ieee80211_find_channel(ic, scan_order[i], 0,
+                    (IEEE80211_CHAN_A | IEEE80211_CHAN_QUARTER));
+        }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
         if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1087,16 +1159,21 @@
         }
     }
 
-    if (ss->ss_flags & IEEE80211_SCAN_80MHZ) {
+    if (ss->ss_flags & IEEE80211_SCAN_80MHZ) 
+    {
         /* Iterate again adding VHT40 & VHT80 channels */
         for (i = 0,c = NULL; i < scan_order_size; ++i) {
-
-            if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD)
+            if (scan_order[i] < IEEE80211_2GHZ_FREQUENCY_THRESHOLD && scan_order_size != 1)
                 continue;
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT40PLUS)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT40PLUS);
+                }
             }
 
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
@@ -1109,7 +1186,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT80)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT80);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80);
+                }
             }
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
             if (c != NULL && !IEEE80211_IS_CHAN_RADAR(c)) {
@@ -1121,7 +1203,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT160)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT160);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT160);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT160);
+                }
             }
             if (c != NULL) {
                 ss->ss_all_chans[ss->ss_nallchans++] = c;
@@ -1129,7 +1216,12 @@
 
             if (IEEE80211_SUPPORT_PHY_MODE(ic, IEEE80211_MODE_11AC_VHT80_80)) {
                 c = NULL;
-                c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80_80);
+                if( scan_order_size == 1 ) {
+                    c = ieee80211_find_channel(ic, fixed_chan, 0, IEEE80211_CHAN_11AC_VHT80_80);
+                }
+                else {
+                    c = ieee80211_find_channel(ic, scan_order[i], 0, IEEE80211_CHAN_11AC_VHT80_80);
+                }
             }
             if (c != NULL) {
                 ss->ss_all_chans[ss->ss_nallchans++] = c;
diff -urN qca-wifi-org/os/linux/BuildCaps.inc qca-wifi-mod/os/linux/BuildCaps.inc
--- qca-wifi-org/os/linux/BuildCaps.inc	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/BuildCaps.inc	2019-02-04 10:44:06.768309513 +0530
@@ -1076,8 +1076,20 @@
 export DEFAULT_BOARD_DATA=0
 endif
 
+ifndef ATH_DATA_TX_INFO_EN
+export ATH_DATA_TX_INFO_EN=1
+endif
+
+ifndef ATH_DATA_RX_INFO_EN
+export ATH_DATA_RX_INFO_EN=1
+endif
+
+ifndef PERF_FIND_WDS_NODE
+export PERF_FIND_WDS_NODE=1
+endif
+
 ifndef PEER_FLOW_CONTROL
-#export PEER_FLOW_CONTROL=0
+export PEER_FLOW_CONTROL=1
 endif
 
 ifndef PEER_FLOW_CONTROL_HOST_SCHED
@@ -2572,6 +2584,13 @@
 COPTS+= -DQCN_ESP_IE=0
 endif
 
+ifeq ($(strip ${PERF_FIND_WDS_NODE}),1)
+COPTS+= -DPERF_FIND_WDS_NODE=1
+else
+COPTS+= -DPERF_FIND_WDS_NODE=0
+endif
+
+
 ifeq ($(strip ${PEER_FLOW_CONTROL}),1)
 COPTS+= -DPEER_FLOW_CONTROL=1
 else
diff -urN qca-wifi-org/os/linux/include/ieee80211_ioctl.h qca-wifi-mod/os/linux/include/ieee80211_ioctl.h
--- qca-wifi-org/os/linux/include/ieee80211_ioctl.h	2018-06-08 11:00:42.000000000 +0530
+++ qca-wifi-mod/os/linux/include/ieee80211_ioctl.h	2019-05-01 20:34:53.726278109 +0530
@@ -1530,6 +1530,108 @@
     IEEE80211_PARAM_TIMEOUTIE                  = 550,   /* set/get assoc comeback timeout value */
     IEEE80211_PARAM_PMF_ASSOC                  = 551,   /* enable/disable pmf support */
     IEEE80211_PARAM_DFS_INFO_NOTIFY_APP        = 552,   /* Enable the feature to notify dfs info to app */
+    IEEE80211_PARAM_UPLINK_LIMIT               = 553,   /* Uplink Limit */
+    IEEE80211_PARAM_DOWNLINK_LIMIT             = 554,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST              = 555,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_DUR          = 556,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS   = 557,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE     = 558,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_TPUT_TEST_DIR          = 559,   /* Downlink Limit */
+    IEEE80211_PARAM_KWN_VLAN_MODE              = 560,   /* Vlan Mode */
+    IEEE80211_PARAM_KWN_VID_ADD                = 561,   /* Vlan Add */
+    IEEE80211_PARAM_KWN_VID_DEL                = 562,   /* Vlan Del */
+    IEEE80211_PARAM_KWN_ALLOW_UNTAGGED         = 563,   /* Allow UnTagged */
+    IEEE80211_PARAM_KWN_SET_ACCESS_VLANID      = 564,   /* Access VlanID */
+    IEEE80211_PARAM_KWN_SET_NATIVE_VLANID      = 565,   /* Native VlanID */
+    IEEE80211_PARAM_KWN_SET_MGMT_VLANID        = 566,   /* Mgmt VlanID */
+    IEEE80211_PARAM_KWN_ETH_TX_PKTS            = 567,   /* Eth Tx Pkts */
+    IEEE80211_PARAM_KWN_ETH_TX_BYTES           = 568,   /* Eth Tx Bytes */
+    IEEE80211_PARAM_KWN_ETH_TX_ERRORS          = 569,   /* Eth Tx Errors */
+    IEEE80211_PARAM_KWN_ETH_RX_PKTS            = 570,   /* Eth Rx Pkts */
+    IEEE80211_PARAM_KWN_ETH_RX_BYTES           = 571,   /* Eth Rx Bytes */
+    IEEE80211_PARAM_KWN_ETH_RX_ERRORS          = 572,   /* Eth Rx Errors */
+    IEEE80211_PARAM_KWN_SET_SVLAN_ID           = 573,   /* SVLAN ID */
+    IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE    = 574,   /* SVLAN EtherType */
+    IEEE80211_PARAM_KWN_SET_PBB_B_VLANID       = 575,   /* PBB B-VLANID */
+    IEEE80211_PARAM_KWN_SET_PBB_B_ISID 	       = 576,	/* PBB B-ISID */
+    IEEE80211_PARAM_KWN_SET_FLAG               = 577,	/* PBB B-MAC Flag */
+    IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET     = 578,	/* Noise Floor Offset */
+    IEEE80211_PARAM_KWN_TX_RATE                = 579,	/* KWN TxRate */
+    IEEE80211_PARAM_KWN_TX_PWR                 = 580,	/* KWN TxPwr */
+    IEEE80211_PARAM_KWN_RX_RATE                = 581,	/* KWN RxRate */
+    IEEE80211_PARAM_KWN_RX_PWR                 = 582,	/* KWN RxPwr */
+    IEEE80211_PARAM_KWN_SPATIAL_STREAM         = 583,	/* KWN Spatial Stream */
+    IEEE80211_PARAM_KWN_DDRS_MIN_RATE          = 584,	/* KWN Min Rate */
+    IEEE80211_PARAM_KWN_DDRS_MAX_RATE          = 585,	/* KWN Max Rate */
+    IEEE80211_PARAM_KWN_DDRS_INCR_TIMER        = 586,	/* KWN Incr Timer */
+    IEEE80211_PARAM_KWN_DDRS_DECR_TIMER        = 587,	/* KWN Decr Timer */
+    IEEE80211_PARAM_KWN_DDRS_RATE_INCR_THRLD   = 588,	/* KWN Rate Incr thrld */
+    IEEE80211_PARAM_KWN_ATPC_STATUS            = 589,	/* KWN ATPC */
+    IEEE80211_PARAM_KWN_ATPC_POWER             = 590,	/* KWN ATPC Power */
+    IEEE80211_PARAM_KWN_ANTENNA_GAIN           = 591,	/* KWN Antenna gain */
+    IEEE80211_PARAM_KWN_START_SCAN             = 592,	/* KWN Start Scan */
+    IEEE80211_PARAM_KWN_START_FREQ             = 593,	/* KWN Start freq */
+    IEEE80211_PARAM_KWN_END_FREQ               = 594,	/* KWN End freq */
+    IEEE80211_PARAM_KWN_SA_SCAN_TIME           = 595,	/* KWN Scan Time */
+    IEEE80211_PARAM_KWN_ACS_SCAN_TIME          = 596,	/* KWN Scan Time */
+    IEEE80211_PARAM_KWN_UTIL_TIME              = 597,	/* KWN Util Time */
+    IEEE80211_PARAM_KWN_ALLOW_TAG_MGMT         = 598,   /* Allow Tag Mgmt */
+    IEEE80211_PARAM_KWN_ASSEM_FRAG             = 599,   /* Assemble Fragment */
+    IEEE80211_PARAM_KWN_MAX_PKT_SIZE           = 600,   /* Max Pkt size */
+    IEEE80211_PARAM_KWN_FRAG_PKT_SIZE          = 601,   /* Frag Pkt size */
+    IEEE80211_PARAM_KWN_ETH_TX_THRPT           = 602,   /* Eth Tx Thrpt */
+    IEEE80211_PARAM_KWN_ETH_RX_THRPT           = 603,   /* Eth Rx Thrpt */
+    IEEE80211_PARAM_KWN_WIFI_TX_THRPT          = 604,   /* Wireless Tx Thrpt */
+    IEEE80211_PARAM_KWN_WIFI_RX_THRPT          = 605,   /* Wireless Rx Thrpt */
+    IEEE80211_PARAM_KWN_TRAFFIC_SHAPING        = 606,   /* Traffic Shaping */
+    IEEE80211_PARAM_KWN_DCS_STATUS             = 607,   /* DCS Status */
+    IEEE80211_PARAM_KWN_DCS_THRLD              = 608,   /* DCS Thrld */
+    IEEE80211_PARAM_KWN_DCS_TIME               = 609,   /* DCS Time */
+    IEEE80211_PARAM_KWN_DCS_BL_INTERVAL        = 610,   /* DCS BL Interval */
+    IEEE80211_PARAM_KWN_SU_SERVICE             = 611,   /* SU Service */
+    IEEE80211_PARAM_KWN_SU_KBPS                = 612,   /* SU DFlt in Kbps */
+    IEEE80211_PARAM_KWN_CLEAR_ETH_STATS        = 613,   /* clear Eth Stats */
+    IEEE80211_PARAM_KWN_DDRS_RTX_INC_THRLD     = 614,   /* RTX Inc */
+    IEEE80211_PARAM_KWN_DDRS_RTX_DEC_THRLD     = 615,   /* RTX Dec */
+    IEEE80211_PARAM_KWN_FILTERING_STATUS       = 616,   /* Filtering Status */
+    IEEE80211_PARAM_KWN_FILTERING_L2MCAST      = 617,   /* Filtering L2 Multicast */
+    IEEE80211_PARAM_KWN_FILTERING_L3MCAST      = 618,   /* Filtering L3 Multicast */
+    IEEE80211_PARAM_KWN_FILTERING_L2BCAST      = 619,   /* Filtering L2 Broadcast */
+    IEEE80211_PARAM_KWN_FILTERING_L3BCAST      = 620,   /* Filtering L3 Broadcast */
+    IEEE80211_PARAM_KWN_FIL_TX_L2MCAST_DRPCNT  = 621,   /* Tx L2 Multicast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_RX_L2MCAST_DRPCNT  = 622,   /* Rx L2 Multicast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_TX_L3MCAST_DRPCNT  = 623,   /* Tx L3 Multicast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_RX_L3MCAST_DRPCNT  = 624,   /* Rx L3 Multicast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_TX_L2BCAST_DRPCNT  = 625,   /* Tx L2 Broadcast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_RX_L2BCAST_DRPCNT  = 626,   /* Rx L2 Broadcast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_TX_L3BCAST_DRPCNT  = 627,   /* Tx L3 Broadcast drop count */ 
+    IEEE80211_PARAM_KWN_FIL_RX_L3BCAST_DRPCNT  = 628,   /* Rx L3 Broadcast drop count */ 
+    IEEE80211_PARAM_KWN_MAX_EIRP               = 629,	/* KWN Max EIRP */
+    IEEE80211_PARAM_KWN_ETH_TX_FAILURE         = 630,   /* Eth Tx Failure */ 
+    IEEE80211_PARAM_KWN_ETH_RX_FAILURE         = 631,   /* Eth Rx Failure */ 
+    IEEE80211_PARAM_KWN_ETH_RX_CRC_ERRORS      = 632,   /* Eth Rx CRC Errors */ 
+    IEEE80211_PARAM_KWN_ETH_RX_FRAME_OVERSIZE  = 633,   /* Eth Rx Frame Oversize Errors */ 
+    IEEE80211_PARAM_KWN_ETH_RX_FRAME_OVERRUN   = 634,   /* Eth Rx Frame OverRun Errors */ 
+    IEEE80211_PARAM_KWN_ETH_TX_MULTICAST_PKT   = 635,   /* Eth Tx Multicast Packets */ 
+    IEEE80211_PARAM_KWN_ETH_RX_MULTICAST_PKT   = 636,   /* Eth Rx Multicast Packets */ 
+    IEEE80211_PARAM_KWN_ETH_TX_UNICAST_PKT     = 637,   /* Eth Tx Unicast Packets */ 
+    IEEE80211_PARAM_KWN_ETH_RX_UNICAST_PKT     = 638,   /* Eth Rx Unicast Packets */ 
+    IEEE80211_PARAM_KWN_TPUT_ETH_TEST          = 639,   /* Ethernet Link Test */
+    IEEE80211_PARAM_KWN_TPUT_RXSEQ_FCNT        = 640,   /* Ethernet Link RxSeq Failed Count */
+    IEEE80211_PARAM_KWN_SOFTRESET              = 641,   /* Softreset */
+    IEEE80211_PARAM_KWN_DDRS_BACKOFF_INT       = 642,	/* KWN DDRS Backoff Interval */
+    IEEE80211_PARAM_KWN_DEBUG                  = 643,	/* KWN Debug print */
+    IEEE80211_PARAM_KWN_MACINMAC               = 644,	/* KWN MAC in MAC */
+    IEEE80211_PARAM_KWN_LINKTYPE               = 645,	/* KWN Link Type */
+    IEEE80211_PARAM_KWN_DISCONNECT_ALL         = 647,	/* KWN Disconnect All */
+    IEEE80211_PARAM_KWN_GET_SCAN_DIFF          = 648,	/* KWN Scan Diff */
+    IEEE80211_PARAM_KWN_TXBASETUP              = 649,	/* KWN TXBA SETUP */
+    IEEE80211_PARAM_KWN_REBOOT                 = 650,	/* KWN Emergency Reboot */
+    IEEE80211_PARAM_KWN_REBOOT_TIME            = 651,	/* KWN Emergency Reboot Time */
+    IEEE80211_PARAM_KWN_MPDU_ERROR             = 652,	/* KWN MPDU Error */
+    IEEE80211_PARAM_KWN_PHY_ERROR              = 653,	/* KWN PHY Error */
+    IEEE80211_PARAM_KWN_TX_MGMT                = 654,	/* KWN TX MGMT */
+    IEEE80211_PARAM_KWN_RX_MGMT                = 655,	/* KWN RX MGMT */
 };
 #define WOW_CUSTOM_PKT_LEN 102
 #define WOW_SYNC_PATTERN 0xFF
@@ -2178,6 +2280,18 @@
 
 #endif /* __linux__ */
 
+#define IEEE80211_EV_DYING_GASP_AP    45
+#define IEEE80211_EV_BASE_DYING_GASP  46
+#define IEEE80211_EV_SU_DYING_GASP    47
+#define IEEE80211_EV_DCS_TRIGGERED    48
+#define IEEE80211_EV_DCS_BEST_CHANNEL 49
+#define IEEE80211_EV_SA_START         50
+#define IEEE80211_EV_SA_STOP          51
+#define IEEE80211_EV_ACS_START        52
+#define IEEE80211_EV_ACS_BEST_CHANNEL 53
+#define IEEE80211_EV_SCAN_IN_PROGRESS 54
+#define IEEE80211_EV_DYING_GASP_SU    55
+
 #define IEEE80211_VAP_PROFILE_NUM_ACL 64
 /*
  * As it is not advisable to use the macros defined in
@@ -2328,4 +2442,29 @@
 };
 #endif
 
+struct kwn_link_txparam {
+    u_int8_t  spatial_stream;
+    u_int8_t  min_rate;
+    u_int8_t  max_rate;
+    u_int8_t  inc_timer;
+    u_int8_t  dec_timer;
+    u_int8_t  rate_incr_thrld;
+    u_int8_t  atpc_status;
+    u_int8_t  power;
+    u_int8_t  max_eirp;
+    u_int8_t  rtx_inc_thrld;
+    u_int8_t  rtx_dec_thrld;
+    u_int16_t curr_inc_timer;
+    u_int16_t backoff_int;
+};
+
+typedef struct kwn_link_profile {
+    struct kwn_link_txparam txparam;
+    int8_t    curr_rate;
+    u_int64_t ddrs_last_jiffies;
+    u_int8_t  ddrs_last_action;
+    int8_t    atpc_power;
+    u_int8_t  actual_power;
+}kwn_link_profile_t;
+
 #endif /* _NET80211_IEEE80211_IOCTL_H_ */
diff -urN qca-wifi-org/os/linux/src/ieee80211_wireless.c qca-wifi-mod/os/linux/src/ieee80211_wireless.c
--- qca-wifi-org/os/linux/src/ieee80211_wireless.c	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/src/ieee80211_wireless.c	2019-04-30 10:19:14.822805430 +0530
@@ -106,6 +106,11 @@
 int ieee80211_authorise_local_peer(wlan_if_t vap, char *params);
 #endif
 
+/* KWN: PBB: B_DA_MAC & B_SA_MAC */
+extern int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac );
+extern int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac );
+extern int edma_set_kwn_test_mac( struct net_device *dev, uint8_t *mac );
+
 #if 0
 /*
  * Common folder is coming from qca_main and
@@ -524,7 +529,9 @@
 {
     osif_dev *osnetdev = ath_netdev_priv(dev);
     wlan_if_t vap = osnetdev->os_if;
+    struct ieee80211com *ic = vap->iv_ic;
     int i;
+    u_int16_t start_freq = 0, end_freq = 0;
 
     debug_print_ioctl(dev->name, SIOCSIWFREQ, "siwfreq") ;
     QDF_PRINT_INFO(vap->iv_ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "siwfreq\n");
@@ -534,6 +541,48 @@
     /*
     * Necessary to cast, to properly interpret negative channel numbers
     */
+    /* To enable fixed channel on Client mode, writing -1 to station freq in case of acs enabled */
+    ic->sta_freq = 0;
+    if( freq->m == 0 )
+      ic->sta_freq = -1;
+
+    if( ic->ic_is_mode_offload(ic) && vap->iv_opmode == IEEE80211_M_HOSTAP && freq->m == 0 )
+    {
+        for (i = 0; i < ic->ic_nchans; i++) {
+            struct ieee80211_channel *c;
+            u_int16_t freq = ic->ic_channels[i].ic_freq;
+
+            c = kwn_find_channel( ic, vap, freq );
+            if( c != NULL ) {
+                if( start_freq == 0 )
+                    start_freq = c->ic_freq;
+                else
+                    end_freq = c->ic_freq;
+            }
+        }
+        printk(": ACS: start freq %d end freq %d \n",start_freq,end_freq);
+        if( start_freq > 4000 ) {
+            if( ic->enable_sa_scan == 1 || ic->kwn_dcs.dcs_triggered == 1 ) {
+               printk(": ACS: SA or DCS Scan is in progress\n");
+               return 0;
+            }
+            printk(": ACS: Scanning module enabled \n");
+            memset( &ic->kwn_scan.sa_result, 0, sizeof( struct kwn_sa_scan_result ) );
+            ic->kwn_scan.scan_vap = vap;
+            ic->kwn_scan.start_freq = start_freq;
+            ic->kwn_scan.end_freq = end_freq;
+            ic->kwn_scan.curr_freq = 0;
+            ic->kwn_scan.next_chan = 0;
+            ic->kwn_scan.scan_time = ic->kwn_scan.acs_scan_time;
+            ic->kwn_scan.util_time = 400;
+            ic->kwn_scan.start_scan = 1;
+            ic->enable_acs = 1;
+            OS_SET_TIMER(&ic->kwn_scan.scan_timer, 10000);
+            i = (u_int8_t)wlan_mhz2ieee(osnetdev->os_devhandle, start_freq, 0);
+            freq->m = i;
+        }
+    }
+
     if (freq->e == 1)
         i = (u_int8_t)wlan_mhz2ieee(osnetdev->os_devhandle, freq->m / 100000, 0);
     else
@@ -600,6 +649,52 @@
 }
 
 static int
+ieee80211_ioctl_siwnickname(struct net_device *dev,
+    struct iw_request_info *info,
+    struct iw_point *data, char *ssid)
+{
+#define CUSTOMER_NAME 1
+#define LONGITUDE     2
+#define LATITUDE      3
+#define IPADDRESS     4
+#define LINKID        5
+    osif_dev *osifp = ath_netdev_priv(dev);
+    wlan_if_t vap = osifp->os_if; 
+
+    if (data->length > IEEE80211_NWID_LEN)
+	    data->length = IEEE80211_NWID_LEN;
+    if ( vap->iv_ic->ic_str_type == CUSTOMER_NAME ) {
+	    OS_MEMZERO(vap->iv_ic->ic_customer_name, 32);
+		strncpy(vap->iv_ic->ic_customer_name, ssid, 32);
+	    //OS_MEMCPY(vap->iv_ic->ic_customer_name, ssid, sizeof(vap->iv_ic->ic_customer_name));
+	    printk("Cusname: %s \n",vap->iv_ic->ic_customer_name);
+    }
+    else if ( vap->iv_ic->ic_str_type == LONGITUDE ) {
+	    OS_MEMZERO(vap->iv_ic->ic_longitude, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_longitude, ssid, data->length);
+	    printk("langitude: %s \n",vap->iv_ic->ic_longitude);
+	    vap->appie_buf_updated = 1;
+    }
+    else if ( vap->iv_ic->ic_str_type == LATITUDE ) {
+	    OS_MEMZERO(vap->iv_ic->ic_latitude, 32);
+	    OS_MEMCPY(vap->iv_ic->ic_latitude, ssid, data->length);
+	    printk("latitude: %s \n",vap->iv_ic->ic_latitude);
+	    vap->appie_buf_updated = 1;
+    }
+    else if ( vap->iv_ic->ic_str_type == IPADDRESS ) {
+	    OS_MEMZERO(vap->iv_ic->ic_ipaddr, 20);
+	    OS_MEMCPY(vap->iv_ic->ic_ipaddr, ssid, data->length);
+    }
+    else if ( vap->iv_ic->ic_str_type == LINKID ) {
+	    OS_MEMZERO(vap->iv_ic->ic_link_id, 15);
+		strncpy(vap->iv_ic->ic_link_id, ssid, 15);
+	    printk("Link Id: %s \n",vap->iv_ic->ic_link_id);
+    }
+    vap->iv_ic->ic_str_type = 0;
+    return 0;
+}
+
+static int
 ieee80211_ioctl_giwessid(struct net_device *dev,
     struct iw_request_info *info,
     struct iw_point *data, char *essid)
@@ -1148,6 +1243,7 @@
     wlan_if_t vap;
     struct sockaddr addr[IW_MAX_AP];
     struct iw_quality qual[IW_MAX_AP];
+    struct iw_ssid ssid[IW_MAX_AP];
     int i;
 };
 
@@ -1161,6 +1257,11 @@
     u_int8_t *se_macaddr = wlan_scan_entry_macaddr(se);
     u_int8_t *se_bssid = wlan_scan_entry_bssid(se);
     u_int8_t se_rssi = wlan_scan_entry_rssi(se);
+    u_int8_t se_ssid_len;
+    u_int8_t *se_ssid = wlan_scan_entry_ssid(se, &se_ssid_len);
+    u_int8_t *se_rsn_ie = wlan_scan_entry_rsn(se);
+    u_int8_t se_linktype = wlan_scan_entry_linktype(se);
+    wlan_chan_t se_chan = wlan_scan_entry_channel(se);
 
     if (i >= IW_MAX_AP)
         return 0;
@@ -1171,7 +1272,15 @@
         IEEE80211_ADDR_COPY(req->addr[i].sa_data, se_bssid);
 
     set_quality(&req->qual[i], se_rssi);
+    memcpy( req->ssid[i].essid, se_ssid, se_ssid_len);
+    req->ssid[i].chan = se_chan->ic_ieee;
+    req->ssid[i].freq = se_chan->ic_freq;
 
+    if( se_rsn_ie != NULL )
+        req->ssid[i].enc = 1;
+    else
+        req->ssid[i].enc = 0;
+    req->ssid[i].linktype = se_linktype;
     req->i = i+1;
 
     return 0;
@@ -1199,12 +1308,39 @@
     data->flags = 1;        /* signal quality present (sort of) */
     OS_MEMCPY(extra + req->i*sizeof(req->addr[0]), &req->qual,
         req->i*sizeof(req->qual[0]));
+    OS_MEMCPY(extra + (req->i*sizeof(req->addr[0] )) + ( req->i * sizeof(req->qual[0] ) ), &req->ssid,
+        req->i*sizeof(req->ssid[0]));
     OS_FREE(req);
 
     return 0;
 
 }
 
+int
+ieee80211_get_scanentries( struct net_device *dev, struct ieee80211_action_vht_scan_entries *entries )
+{
+    osif_dev *osifp = ath_netdev_priv(dev);
+    wlan_if_t vap = osifp->os_if;
+    struct waplistreq *req;
+    int i;
+
+    req = (struct waplistreq *)OS_MALLOC(osifp->os_handle, sizeof(*req), GFP_KERNEL);
+    if (req == NULL)
+        return -ENOMEM;
+    req->vap = vap;
+    req->i = 0;
+    wlan_scan_table_iterate(vap, waplist_cb, req);
+    entries->at_scan_entry.count = req->i;
+    for( i=0; i<req->i; i++ ) {
+        entries->at_scan_entry.entry[i].channel = req->ssid[i].chan;
+        entries->at_scan_entry.entry[i].frequency = req->ssid[i].freq;
+        entries->at_scan_entry.entry[i].rssi = req->qual[i].level - req->qual[i].noise;
+    }
+    OS_FREE(req);
+
+    return 0;
+}
+
 #ifdef SIOCGIWSCAN
 static int
 ieee80211_ioctl_siwscan(struct net_device *dev,
@@ -4662,6 +4798,7 @@
         if (!scan_pause) {
             osifp->os_last_siwscan = OS_GET_TICKS();
             retv = wlan_scan_start(vap, &scan_params, osifp->scan_requestor, priority, &(osifp->scan_id));
+            vap->kwn_last_scan_time = jiffies;
         }
 
 scanreq_fail:
@@ -10106,7 +10243,7 @@
  */
 static int
 ieee80211_ioctl_addmac(struct net_device *dev, struct iw_request_info *info,
-    void *w, char *extra)
+        void *w, char *extra)
 {
     osif_dev *osifp = ath_netdev_priv(dev);
     wlan_if_t vap = osifp->os_if;
@@ -10115,8 +10252,61 @@
 
     debug_print_ioctl(dev->name, IEEE80211_IOCTL_ADDMAC, "addmac") ;
 
-    rc = wlan_set_acl_add(vap, sa->sa_data, IEEE80211_ACL_FLAG_ACL_LIST_1);
-    return rc;
+    switch( vap->kwn_flag ) {
+        case TPUT_TEST_MAC:
+            IEEE80211_ADDR_COPY(vap->kwn_tput_test_mac, sa->sa_data);
+            /* Configure the Ethernet Test MAC Also */
+            {
+                struct net_device *eth_dev;
+                eth_dev = dev_get_by_name(&init_net, "eth0");
+                if ( eth_dev ) {
+                    edma_set_kwn_test_mac( eth_dev, sa->sa_data );
+                    dev_put(eth_dev);
+                }
+            }
+            break;
+        case PBB_DA_MAC:
+            {
+                struct net_device *eth_dev;
+                eth_dev = dev_get_by_name(&init_net, "eth0");
+                if ( eth_dev ) {
+                    edma_set_pbb_da_mac( eth_dev, sa->sa_data );
+                    dev_put(eth_dev);
+                }
+            }
+            break;
+        case PBB_SA_MAC:
+            {
+                struct net_device *eth_dev;
+                eth_dev = dev_get_by_name(&init_net, "eth0");
+                if ( eth_dev ) {
+                    edma_set_pbb_sa_mac( eth_dev, sa->sa_data );
+                    dev_put(eth_dev);
+                }
+            }
+            break;
+        case RATE_NODE_MAC:
+            IEEE80211_ADDR_COPY(vap->kwn_rate_node_mac, sa->sa_data);
+            break;
+        case CLEAR_NODE_STATS:
+            {
+                struct ieee80211_node *ni;
+                char node_mac[6];
+                IEEE80211_ADDR_COPY( node_mac, sa->sa_data );
+                ni = ieee80211_vap_find_node( vap, node_mac );
+                if (ni == NULL) {
+                    return 0;
+                }
+                OS_MEMZERO(&(ni->ni_stats), sizeof(struct ieee80211_nodestats ));
+                ieee80211_send_clear_node_stats( vap, ni );
+                ieee80211_free_node(ni);
+            }
+            break;
+        default:
+            rc = wlan_set_acl_add(vap, sa->sa_data, IEEE80211_ACL_FLAG_ACL_LIST_1);
+            return rc;
+    }
+    return 0;
 }
 
 /**
@@ -11208,6 +11398,29 @@
 
     debug_print_ioctl(dev->name, 0xffff, "getscanresults");
 
+    if( vap->kwn_flag == SA_RESULTS )
+    {
+        uint32_t data_length = 0;
+        int status;
+
+        data_length = iwr->u.data.length;
+        data_length = sizeof( struct kwn_sa_scan_result );
+        if (data_length == 0)
+            return -EINVAL;
+
+        if ((data_length > iwr->u.data.length) && (iwr->u.data.flags == 0)) {
+            return -EINVAL;
+        }
+
+        if (data_length > 0) {
+            iwr->u.data.length = data_length;
+            error = _copy_to_user(iwr->u.data.pointer, &ic->kwn_scan.sa_result, data_length);
+            status = error ? -EFAULT : 0;
+        } else {
+            iwr->u.data.length = 0;
+        }
+        return 0;
+    }
     if (!(dev->flags & IFF_UP)) {
         return -EINVAL;
     }
@@ -14947,6 +15160,314 @@
     IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dfs_notify" },
     { IEEE80211_PARAM_DFS_INFO_NOTIFY_APP,
     0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_dfs_notify" },
+    { IEEE80211_PARAM_UPLINK_LIMIT,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "ul_limit" },
+    { IEEE80211_PARAM_UPLINK_LIMIT,
+    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_ul_limit" },
+    { IEEE80211_PARAM_DOWNLINK_LIMIT,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "dl_limit" },
+    { IEEE80211_PARAM_DOWNLINK_LIMIT,
+    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_dl_limit" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST,
+    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_test" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_test" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DUR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_dur" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DUR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_dur" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_cnt" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_cnt" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_size" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_size" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DIR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tput_dir" },
+    { IEEE80211_PARAM_KWN_TPUT_TEST_DIR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_tput_dir" },
+    { IEEE80211_PARAM_KWN_VLAN_MODE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vlan_mode" },
+    { IEEE80211_PARAM_KWN_VID_ADD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vid_add" },
+    { IEEE80211_PARAM_KWN_VID_DEL,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_vid_del" },
+    { IEEE80211_PARAM_KWN_ALLOW_UNTAGGED,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_allowuntag" },
+    { IEEE80211_PARAM_KWN_SET_ACCESS_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_acc_vid" },
+    { IEEE80211_PARAM_KWN_SET_NATIVE_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_nat_vid" },
+    { IEEE80211_PARAM_KWN_SET_MGMT_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_mgmt_vid" },
+    { IEEE80211_PARAM_KWN_SET_SVLAN_ID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_svlan_id" },
+    { IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_setherType" },
+    { IEEE80211_PARAM_KWN_ETH_TX_PKTS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxpkt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_BYTES,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxbyt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_ERRORS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxerr" },
+    { IEEE80211_PARAM_KWN_ETH_RX_PKTS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxpkt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_BYTES,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxbyt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_ERRORS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxerr" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_VLANID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_bvid" },
+    { IEEE80211_PARAM_KWN_SET_PBB_B_ISID,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_pbb_bisid" },
+    { IEEE80211_PARAM_KWN_SET_FLAG,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_flag" },
+    { IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnnoiseoff" },
+    { IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnnoiseoff" },
+    { IEEE80211_PARAM_KWN_TX_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwntxrate" },
+    { IEEE80211_PARAM_KWN_TX_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwntxrate" },
+    { IEEE80211_PARAM_KWN_TX_PWR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwntxpwr" },
+    { IEEE80211_PARAM_KWN_TX_PWR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwntxpwr" },
+    { IEEE80211_PARAM_KWN_RX_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnrxrate" },
+    { IEEE80211_PARAM_KWN_RX_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrxrate" },
+    { IEEE80211_PARAM_KWN_RX_PWR,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnrxpwr" },
+    { IEEE80211_PARAM_KWN_RX_PWR,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrxpwr" },
+    { IEEE80211_PARAM_KWN_SPATIAL_STREAM,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnstream" },
+    { IEEE80211_PARAM_KWN_SPATIAL_STREAM,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnstream" },
+    { IEEE80211_PARAM_KWN_DDRS_MIN_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsmin" },
+    { IEEE80211_PARAM_KWN_DDRS_MIN_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsmin" },
+    { IEEE80211_PARAM_KWN_DDRS_MAX_RATE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsmax" },
+    { IEEE80211_PARAM_KWN_DDRS_MAX_RATE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsmax" },
+    { IEEE80211_PARAM_KWN_DDRS_INCR_TIMER,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsinc" },
+    { IEEE80211_PARAM_KWN_DDRS_INCR_TIMER,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsinc" },
+    { IEEE80211_PARAM_KWN_DDRS_DECR_TIMER,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnddrsdec" },
+    { IEEE80211_PARAM_KWN_DDRS_DECR_TIMER,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnddrsdec" },
+    { IEEE80211_PARAM_KWN_DDRS_RATE_INCR_THRLD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnincthrld" },
+    { IEEE80211_PARAM_KWN_DDRS_RATE_INCR_THRLD,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnincthrld" },
+    { IEEE80211_PARAM_KWN_ATPC_STATUS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnatpc" },
+    { IEEE80211_PARAM_KWN_ATPC_STATUS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnatpc" },
+    { IEEE80211_PARAM_KWN_ATPC_POWER,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnatpcpow" },
+    { IEEE80211_PARAM_KWN_ATPC_POWER,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnatpcpow" },
+    { IEEE80211_PARAM_KWN_ANTENNA_GAIN,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnantgain" },
+    { IEEE80211_PARAM_KWN_ANTENNA_GAIN,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnantgain" },
+    { IEEE80211_PARAM_KWN_START_SCAN,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnstartscan" },
+    { IEEE80211_PARAM_KWN_START_SCAN,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnstartscan" },
+    { IEEE80211_PARAM_KWN_START_FREQ,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnstartfreq" },
+    { IEEE80211_PARAM_KWN_START_FREQ,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnstartfreq" },
+    { IEEE80211_PARAM_KWN_END_FREQ,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnendfreq" },
+    { IEEE80211_PARAM_KWN_END_FREQ,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnendfreq" },
+    { IEEE80211_PARAM_KWN_SA_SCAN_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnsatime" },
+    { IEEE80211_PARAM_KWN_SA_SCAN_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnsatime" },
+    { IEEE80211_PARAM_KWN_ACS_SCAN_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnacstime" },
+    { IEEE80211_PARAM_KWN_ACS_SCAN_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnacstime" },
+    { IEEE80211_PARAM_KWN_UTIL_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnutiltime" },
+    { IEEE80211_PARAM_KWN_UTIL_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnutiltime" },
+    { IEEE80211_PARAM_KWN_ALLOW_TAG_MGMT,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwn_tagmgmt" },
+    { IEEE80211_PARAM_KWN_ASSEM_FRAG,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnassemfrag" },
+    { IEEE80211_PARAM_KWN_ASSEM_FRAG,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnassemfrag" },
+    { IEEE80211_PARAM_KWN_MAX_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnpktsize" },
+    { IEEE80211_PARAM_KWN_MAX_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnpktsize" },
+    { IEEE80211_PARAM_KWN_FRAG_PKT_SIZE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnfragsize" },
+    { IEEE80211_PARAM_KWN_FRAG_PKT_SIZE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnfragsize" },
+    { IEEE80211_PARAM_KWN_ETH_TX_THRPT,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethtxthr" },
+    { IEEE80211_PARAM_KWN_ETH_RX_THRPT,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_ethrxthr" },
+    { IEEE80211_PARAM_KWN_WIFI_TX_THRPT,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_witxthr" },
+    { IEEE80211_PARAM_KWN_WIFI_RX_THRPT,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwn_wirxthr" },
+    { IEEE80211_PARAM_KWN_TRAFFIC_SHAPING,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnshaping" },
+    { IEEE80211_PARAM_KWN_TRAFFIC_SHAPING,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnshaping" },
+    { IEEE80211_PARAM_KWN_DCS_STATUS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwndcsstatus" },
+    { IEEE80211_PARAM_KWN_DCS_STATUS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwndcsstatus" },
+    { IEEE80211_PARAM_KWN_DCS_THRLD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwndcsthrld" },
+    { IEEE80211_PARAM_KWN_DCS_THRLD,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwndcsthrld" },
+    { IEEE80211_PARAM_KWN_DCS_TIME,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwndcstime" },
+    { IEEE80211_PARAM_KWN_DCS_TIME,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwndcstime" },
+    { IEEE80211_PARAM_KWN_DCS_BL_INTERVAL,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnblint" },
+    { IEEE80211_PARAM_KWN_DCS_BL_INTERVAL,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnblint" },
+    { IEEE80211_PARAM_KWN_SU_SERVICE,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnsuservice" },
+    { IEEE80211_PARAM_KWN_SU_SERVICE,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnsuservice" },
+    { IEEE80211_PARAM_KWN_SU_KBPS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnsukbps" },
+    { IEEE80211_PARAM_KWN_SU_KBPS,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnsukbps" },
+    { IEEE80211_PARAM_KWN_CLEAR_ETH_STATS,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnclrethstats" },
+    { IEEE80211_PARAM_KWN_DDRS_RTX_INC_THRLD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnrtxinc" },
+    { IEEE80211_PARAM_KWN_DDRS_RTX_INC_THRLD,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrtxinc" },
+    { IEEE80211_PARAM_KWN_DDRS_RTX_DEC_THRLD,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnrtxdec" },
+    { IEEE80211_PARAM_KWN_DDRS_RTX_DEC_THRLD,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrtxdec" },
+    { IEEE80211_PARAM_KWN_FILTERING_STATUS,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnfltrstat" },
+    { IEEE80211_PARAM_KWN_FILTERING_STATUS,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnfltrstat" },
+    { IEEE80211_PARAM_KWN_FILTERING_L2MCAST,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnl2mcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L2MCAST,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnl2mcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L3MCAST,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnl3mcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L3MCAST,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnl3mcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L2BCAST,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnl2bcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L2BCAST,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnl2bcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L3BCAST,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnl3bcast" },
+    { IEEE80211_PARAM_KWN_FILTERING_L3BCAST,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnl3bcast" },
+    { IEEE80211_PARAM_KWN_FIL_TX_L2MCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwtxl2mdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_RX_L2MCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwrxl2mdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_TX_L3MCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwtxl3mdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_RX_L3MCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwrxl3mdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_TX_L2BCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwtxl2bdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_RX_L2BCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwrxl2bdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_TX_L3BCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwtxl3bdrpcnt" },
+    { IEEE80211_PARAM_KWN_FIL_RX_L3BCAST_DRPCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwrxl3bdrpcnt" },
+    { IEEE80211_PARAM_KWN_MAX_EIRP,
+	    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnmaxeirp" },
+    { IEEE80211_PARAM_KWN_MAX_EIRP,
+	    0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnmaxeirp" },
+    { IEEE80211_PARAM_KWN_ETH_TX_FAILURE,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethtxfail" },
+    { IEEE80211_PARAM_KWN_ETH_RX_FAILURE,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethrxfail" },
+    { IEEE80211_PARAM_KWN_ETH_RX_CRC_ERRORS,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwethcrcerrs" },
+    { IEEE80211_PARAM_KWN_ETH_RX_FRAME_OVERSIZE,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwethoversize" },
+    { IEEE80211_PARAM_KWN_ETH_RX_FRAME_OVERRUN,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwethoverrun" },
+    { IEEE80211_PARAM_KWN_ETH_TX_MULTICAST_PKT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethtxmcpkt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_MULTICAST_PKT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethrxmcpkt" },
+    { IEEE80211_PARAM_KWN_ETH_TX_UNICAST_PKT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethtxucpkt" },
+    { IEEE80211_PARAM_KWN_ETH_RX_UNICAST_PKT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethrxucpkt" },
+    { IEEE80211_PARAM_KWN_TPUT_ETH_TEST,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnethtest" },
+    { IEEE80211_PARAM_KWN_TPUT_ETH_TEST,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnethtest" },
+    { IEEE80211_PARAM_KWN_TPUT_RXSEQ_FCNT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrxfailcnt" },
+    { IEEE80211_PARAM_KWN_SOFTRESET,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnsoftreset" },
+    { IEEE80211_PARAM_KWN_SOFTRESET,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnsoftreset" },
+    { IEEE80211_PARAM_KWN_DDRS_BACKOFF_INT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnbackoff" },
+    { IEEE80211_PARAM_KWN_DDRS_BACKOFF_INT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnbackoff" },
+    { IEEE80211_PARAM_KWN_DEBUG,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwndebug" },
+    { IEEE80211_PARAM_KWN_DEBUG,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwndebug" },
+    { IEEE80211_PARAM_KWN_MACINMAC,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnmacmac" },
+    { IEEE80211_PARAM_KWN_MACINMAC,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnmacmac" },
+    { IEEE80211_PARAM_KWN_LINKTYPE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnlinktype" },
+    { IEEE80211_PARAM_KWN_LINKTYPE,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnlinktype" },
+    { IEEE80211_PARAM_KWN_DISCONNECT_ALL,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwndiscall" },
+    { IEEE80211_PARAM_KWN_GET_SCAN_DIFF,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnscandiff" },
+    { IEEE80211_PARAM_KWN_TXBASETUP,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwntxbasetup" },
+    { IEEE80211_PARAM_KWN_REBOOT,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnreboot" },
+    { IEEE80211_PARAM_KWN_REBOOT_TIME,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "kwnreboottime" },
+    { IEEE80211_PARAM_KWN_REBOOT_TIME,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnreboottime" },
+    { IEEE80211_PARAM_KWN_MPDU_ERROR,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnmpduerr" },
+    { IEEE80211_PARAM_KWN_PHY_ERROR,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnphyerr" },
+    { IEEE80211_PARAM_KWN_TX_MGMT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwntxmgmt" },
+    { IEEE80211_PARAM_KWN_RX_MGMT,
+        0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "g_kwnrxmgmt" },
 };
 
 static const iw_handler ieee80211_handlers[] = {
@@ -14992,7 +15513,7 @@
 #endif /* SIOCGIWSCAN */
     (iw_handler) ieee80211_ioctl_siwessid,      /* SIOCSIWESSID */
     (iw_handler) ieee80211_ioctl_giwessid,      /* SIOCGIWESSID */
-    (iw_handler) NULL,      /* SIOCSIWNICKN */
+    (iw_handler) ieee80211_ioctl_siwnickname,      /* SIOCSIWNICKN */
     (iw_handler) NULL,      /* SIOCGIWNICKN */
     (iw_handler) NULL,              /* -- hole -- */
     (iw_handler) NULL,              /* -- hole -- */
@@ -15309,11 +15830,26 @@
     {
 
     case SIOCG80211STATS:
-        return _copy_to_user(ifr->ifr_data, &vap->iv_stats,
-            sizeof (vap->iv_stats) +
-            sizeof(vap->iv_unicast_stats) +
-            sizeof(vap->iv_multicast_stats)) ? -EFAULT : 0;
-
+        if (*((char*)ifr->ifr_data))
+        {
+            memset (&(vap->iv_stats), 0x00, sizeof(struct ieee80211_stats));
+            memset (&(vap->iv_unicast_stats), 0x00, sizeof(struct ieee80211_mac_stats));
+            memset (&(vap->iv_multicast_stats), 0x00, sizeof(struct ieee80211_mac_stats));
+            memset (&(vap->iv_mgmt_stats), 0x00, sizeof(struct ieee80211_mgmt_stats));
+            return 0;
+        }
+        else
+        {
+            vap->iv_mgmt_stats.iv_opmode = vap->iv_opmode;
+            return _copy_to_user(ifr->ifr_data, &vap->iv_stats,
+                    sizeof (vap->iv_stats) +
+                    sizeof(vap->iv_unicast_stats) +
+                    sizeof(vap->iv_multicast_stats)
+#ifdef SIFY_MGMT_STATS                               
+                    + sizeof (vap->iv_mgmt_stats)
+#endif
+                    ) ? -EFAULT : 0;
+        }
     case SIOC80211IFDESTROY:
         if (!capable(CAP_NET_ADMIN))
             return -EPERM;
diff -urN qca-wifi-org/os/linux/src/osif_umac.c qca-wifi-mod/os/linux/src/osif_umac.c
--- qca-wifi-org/os/linux/src/osif_umac.c	2018-06-08 11:00:41.000000000 +0530
+++ qca-wifi-mod/os/linux/src/osif_umac.c	2019-01-29 16:24:31.276271073 +0530
@@ -2425,7 +2425,7 @@
     struct ev_msg msg;
 
     if (osifp->os_opmode != IEEE80211_M_P2P_GO) {
-        if (!wlan_get_param(vap, IEEE80211_TRIGGER_MLME_RESP))
+        //if (!wlan_get_param(vap, IEEE80211_TRIGGER_MLME_RESP))
         {
         	OS_MEMSET(&wreq, 0, sizeof(wreq));
 	        IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
@@ -2508,6 +2508,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DEAUTH_IND_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
     ald_assoc_notify(((osif_dev *)osif)->os_if, macaddr, ALD_ACTION_DISASSOC);
 #if ATH_SUPPORT_WAPI
@@ -2641,6 +2642,7 @@
     memset(&wrqu, 0, sizeof(wrqu));
     IEEE80211_ADDR_COPY(wrqu.addr.sa_data, macaddr);
     wrqu.addr.sa_family = ARPHRD_ETHER;
+    wrqu.addr.sa_data[6] = IEEE80211_EV_DEAUTH_COMPLETE_STA;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wrqu, NULL);
 
 #if UMAC_SUPPORT_ACFG
@@ -3089,6 +3091,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DISASSOC_IND_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
     ald_assoc_notify(((osif_dev *)osif)->os_if, macaddr, ALD_ACTION_DISASSOC);
 #if ATH_SUPPORT_WAPI
@@ -3160,6 +3163,7 @@
     memset(&wreq, 0, sizeof(wreq));
     IEEE80211_ADDR_COPY(wreq.addr.sa_data, macaddr);
     wreq.addr.sa_family = ARPHRD_ETHER;
+    wreq.addr.sa_data[6] = IEEE80211_EV_DISASSOC_COMPLETE_AP;
     WIRELESS_SEND_EVENT(dev, IWEVEXPIRED, &wreq, NULL);
 
     IEEE80211_ADDR_COPY(msg.addr, macaddr);
@@ -6362,8 +6366,10 @@
 static int
 osif_change_mtu(struct net_device *dev, int mtu)
 {
+#if 0 /* KWN Changes for supporting JumboFrame */
     if (!(IEEE80211_MTU_MIN < mtu && mtu <= IEEE80211_MTU_MAX))
         return -EINVAL;
+#endif
     dev->mtu = mtu;
     /* XXX coordinate with parent device */
     return 0;
diff -urN qca-wifi-org/os/linux/src/umac_exports.c qca-wifi-mod/os/linux/src/umac_exports.c
--- qca-wifi-org/os/linux/src/umac_exports.c	2018-06-08 11:00:41.000000000 +0530
+++ qca-wifi-mod/os/linux/src/umac_exports.c	2019-03-14 16:47:52.594033311 +0530
@@ -77,6 +77,8 @@
 EXPORT_SYMBOL(ieee80211_chan2mode);
 EXPORT_SYMBOL(ieee80211_ieee2mhz);
 EXPORT_SYMBOL(ieee80211_find_channel);
+EXPORT_SYMBOL(kwn_find_channel);
+EXPORT_SYMBOL(disassoc_stations);
 EXPORT_SYMBOL(ieee80211_doth_findchan);
 EXPORT_SYMBOL(ieee80211_find_dot11_channel);
 EXPORT_SYMBOL(wlan_get_desired_phymode);
@@ -203,6 +205,9 @@
 #endif
 
 EXPORT_SYMBOL(ieee80211_send_rcsa);
+EXPORT_SYMBOL(ieee80211_send_dying_gasp);
+EXPORT_SYMBOL(ieee80211_send_txparams);
+EXPORT_SYMBOL(kwn_sa_set_channel);
 EXPORT_SYMBOL(ieee80211_dfs_cac_cancel);
 EXPORT_SYMBOL(ieee80211_update_dfs_next_channel);
 #if ATH_SUPPORT_DFS && ATH_SUPPORT_STA_DFS
@@ -560,3 +565,4 @@
 EXPORT_SYMBOL(osif_set_primary_radio_event);
 #endif
 EXPORT_SYMBOL(wlan_get_stats);
+EXPORT_SYMBOL(kwn_beacon_chanutil_update);
diff -urN qca-wifi-org/os/linux/tools/80211stats.c qca-wifi-mod/os/linux/tools/80211stats.c
--- qca-wifi-org/os/linux/tools/80211stats.c	2018-06-08 11:00:39.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/80211stats.c	2019-03-16 19:02:05.933042661 +0530
@@ -68,6 +68,70 @@
 #ifndef SIOCG80211STATS
 #define	SIOCG80211STATS	(SIOCDEVPRIVATE+2)
 #endif
+typedef struct 
+{
+	int code;
+	char *str;
+}ieee80211_reason_t;
+ieee80211_reason_t ieee80211_reason[] =
+{
+	{1,"unspecified"},
+	{2,"auth expire"},
+	{3,"auth leave"},
+	{4,"assoc expire"},
+	{5,"assoc toomany"},
+	{6,"not authed"},
+	{7,"not assoced"},
+	{8,"assoc leave"},
+	{9,"assoc not authed"},
+	{11,"rsn required"},
+	{12,"rsn inconsistent"},
+	{13,"ie invalid"},
+	{14,"mic failure"},
+	{32,"qos"},
+	{33,"qos bandwitdh"},
+	{34,"qos ch conditions"},
+	{35,"qos txop"},
+	{36,"qos leave"},
+	{37,"qos declined"},
+	{38,"qos setup required"},
+	{39,"qos timeout"},
+	{45,"qos cipher"},
+	{0,"success"},
+	{1,"unspecified"},
+	{10,"capinfo"},
+	{11,"not assoced"},
+	{12,"other"},
+	{13,"alg"},
+	{14,"sequence"},
+	{15,"challenge"},
+	{16,"timeout"},
+	{17,"toomany"},
+	{18,"basic rate"},
+	{19,"sp required"},
+	{20,"pbcc required"},
+	{21,"ca required"},
+	{22,"too many stations"},
+	{23,"rates"},
+	{25,"shortslot required"},
+	{26,"dsssofdm required"},
+	{27,"no ht"},
+	{37,"refused"},
+	{38,"invalid param"}
+};
+
+static char *ieee80211_reason_get (int code)
+{
+	int  i = 0;
+	for (i = 0; i< sizeof(ieee80211_reason);i++)
+	{
+		if (ieee80211_reason[i].code == code)
+		{
+			return ieee80211_reason[i].str;
+		}
+	}
+	return "none";
+}
 
 static void
 printstats(FILE *fd, const struct ieee80211_stats *stats)
@@ -295,15 +359,160 @@
 int
 main(int argc, char *argv[])
 {
-	int c, len;
+    const char *ifname = "ath0";
+	int c = 0 , len, index;
 	struct ieee80211req_sta_info *si;
 	u_int8_t buf[24*1024], *cp;
 	struct iwreq iwr;
-	int allnodes = 0;
+	int allnodes = 0,mgmtstats = 0;
+    int clear = 0;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 	if (s < 0)
 		err(1, "socket");
+#if 1
+    while ((c = getopt(argc, argv, "e:i:")) != -1)
+        switch (c)
+        { 
+            case 'i':
+                ifname = optarg; 
+                break; 
+            case 'e':
+                clear = atoi(optarg);
+                break;
+            case '?':
+                if (optopt == 'i')
+                    fprintf(stderr, "Option -%c requires an argument.\n", optopt);
+                close(s);
+                return -1;
+            default:
+                abort();
+        }
+	strlcpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
+	if (clear == 1)
+	{
+		char data[2] = {1};
+		ifr.ifr_data = data;
+
+		if (ioctl(s, SIOCG80211STATS, &ifr) < 0)
+		{
+			printf("error opening socket");
+			err(1, ifr.ifr_name);
+		}
+		return 0;
+	}
+	{
+		struct ieee80211_stats      *stats = NULL;
+		struct ieee80211_mac_stats  *unicast_stats = NULL;
+		struct ieee80211_mac_stats  *multicast_stats = NULL;
+		struct ieee80211_mgmt_stats *mgmt_stats = NULL;
+
+		/* no args, just show global stats */
+        /* fetch both ieee80211_stats, and mac_stats, including multicast and unicast stats */
+        stats = malloc(sizeof(struct ieee80211_stats)+ 2* sizeof(struct ieee80211_mac_stats) + sizeof (struct ieee80211_mgmt_stats));
+        if (!stats) {
+            fprintf (stderr, "Unable to allocate memory for stats\n");
+            return -1;
+        }
+		ifr.ifr_data = (caddr_t) stats;
+		if (ioctl(s, SIOCG80211STATS, &ifr) < 0)
+			err(1, ifr.ifr_name);
+		unicast_stats = (struct ieee80211_mac_stats*)(((unsigned char*)stats)+sizeof(struct ieee80211_stats));
+		multicast_stats = (struct ieee80211_mac_stats *)(((unsigned char*)stats)+sizeof(struct ieee80211_stats)+ sizeof(struct ieee80211_mac_stats));
+		mgmt_stats = (struct ieee80211_mgmt_stats*)(((unsigned char*)stats)+sizeof(struct ieee80211_stats)+2*sizeof(struct ieee80211_mac_stats));
+		
+		/* AP */
+		if (mgmt_stats->iv_opmode != 1)
+		{
+			printf(" Authentication requests received:   %llu\n",mgmt_stats->aut_recv);
+			printf(" Authentication confirms:            %llu\n",mgmt_stats->aut_confirm_xmit);
+			printf(" Authentication rejects:             %llu\n",mgmt_stats->aut_reject_xmit);
+			printf(" Deauthentication requests sent:     %llu\n",mgmt_stats->deaut_xmit);
+#if 0			
+			printf(" Deauthentication requests received: %llu\n",mgmt_stats->deaut_recv);
+#endif			
+			if (mgmt_stats->aut_recv > 0)
+			{
+				printf(" Authentication result last:         %s\n",ieee80211_reason_get(mgmt_stats->auth_reason));
+			}
+			else
+			{
+				printf(" Authentication result last:         %s\n","not available");
+			}
+#if 1	
+			printf(" Association requests received:      %llu\n",mgmt_stats->assoc_recv);
+			printf(" Association rejects:                %llu\n",mgmt_stats->assoc_reject_xmit);
+			printf(" Association confirms:               %llu\n",mgmt_stats->assoc_confirm_xmit);
+			printf(" Disassociation requests received:   %llu\n",mgmt_stats->disassoc_recv);
+			if (mgmt_stats->assoc_recv > 0)
+			{
+				printf(" Association result last:            %s\n",ieee80211_reason_get(mgmt_stats->assoc_reason));
+			}
+			else
+			{
+				printf(" Association result last:            %s\n","not available");
+			}
+#endif			
+
+		}
+		else
+		{
+
+			/* SU */
+			
+			printf(" Beacons received:                   %llu\n",mgmt_stats->bcn_recv);
+			printf(" Authentication requests sent:       %llu\n",mgmt_stats->aut_xmit);
+			printf(" Authentication confirms:            %llu\n",mgmt_stats->aut_confirm_recv);
+			printf(" Authentication rejects:             %llu\n",mgmt_stats->aut_reject_recv);
+			printf(" Deauthentication requests received: %llu\n",mgmt_stats->deaut_recv);
+			if (mgmt_stats->aut_confirm_recv || mgmt_stats->aut_reject_recv)
+			{
+				printf(" Authentication result last:         %s\n",ieee80211_reason_get(mgmt_stats->auth_reason));
+			}
+			else
+			{
+				printf(" Authentication result last:         %s\n","not available");
+			}
+#if 1
+			printf(" Association requests sent:          %llu\n",mgmt_stats->assoc_xmit);
+			printf(" Association rejects:                %llu\n",mgmt_stats->assoc_reject_recv);
+			printf(" Association confirms:               %llu\n",mgmt_stats->assoc_confirm_recv);
+			printf(" Disassociation requests sent:       %llu\n",mgmt_stats->disassoc_xmit);
+			if (mgmt_stats->assoc_reject_recv || mgmt_stats->assoc_confirm_recv)
+			{
+				printf(" Association result last:            %s\n",ieee80211_reason_get(mgmt_stats->assoc_reason));
+
+			}
+			else
+			{
+				printf(" Association result last:            %s\n","not available");
+			}
+#endif			
+
+		}
+		printf("----------------------------\r\n");
+		printf(" Multicast packets sent:             %llu\n",multicast_stats->ims_tx_packets);
+		printf(" Multicast packets received:         %llu\n",multicast_stats->ims_rx_packets);
+		printf(" Multicast data packets sent:        %llu\n",multicast_stats->ims_tx_data_packets);
+		printf(" Multicast data packets received:    %llu\n",multicast_stats->ims_rx_data_packets);
+		printf(" Multicast data bytes sent:          %llu\n",multicast_stats->ims_tx_data_bytes);
+		printf(" Multicast data bytes received:      %llu\n",multicast_stats->ims_rx_data_bytes);
+		printf(" Broadcast data packets sent:        %llu\n",multicast_stats->ims_tx_bcast_data_packets);
+		printf(" Broadcast data packets received:    %llu\n",multicast_stats->ims_rx_bcast_data_packets);
+		printf(" Unicast packets sent:               %llu\n",unicast_stats->ims_tx_packets);
+		printf(" Unicast packets received:           %llu\n",unicast_stats->ims_rx_packets);
+		printf(" Unicast data packets sent:          %llu\n",unicast_stats->ims_tx_data_packets);
+		printf(" Unicast data packets received:      %llu\n",unicast_stats->ims_rx_data_packets);
+		printf(" Unicast data bytes sent:            %llu\n",unicast_stats->ims_tx_data_bytes);
+		printf(" Unicast data bytes received:        %llu\n",unicast_stats->ims_rx_data_bytes);
+#if 0
+		printf(" Broadcast data packets sent:        %llu\n",unicast_stats->ims_tx_bcast_data_packets);
+		printf(" Broadcast data packets received:    %llu\n",unicast_stats->ims_rx_bcast_data_packets);
+#endif
+		free(stats);
+		return 0;
+	}
+#else
 	strlcpy(ifr.ifr_name, "ath0", sizeof (ifr.ifr_name));
 	while ((c = getopt(argc, argv, "ai:")) != -1)
 		switch (c) {
@@ -376,4 +585,5 @@
 		}
 	}
         return 0;       	
+#endif
 }
diff -urN qca-wifi-org/os/linux/tools/apstats.c qca-wifi-mod/os/linux/tools/apstats.c
--- qca-wifi-org/os/linux/tools/apstats.c	2018-06-08 11:00:39.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/apstats.c	2019-03-16 15:22:00.680460420 +0530
@@ -95,7 +95,7 @@
 #endif
 
 /* Options processing */
-static const char *optString = "arvsi:m:RMh?";
+static const char *optString = "arvsci:m:RMh?";
 int display_mesh_stats = 0;
 
 static const struct option longOpts[] = {
@@ -103,6 +103,7 @@
     { "radiolevel", no_argument, NULL, 'r' },
     { "vaplevel", no_argument, NULL, 'v' },
     { "stalevel", no_argument, NULL, 's' },
+    { "scanresult", no_argument, NULL, 'c' },
     { "ifname", required_argument, NULL, 'i' },
     { "stamacaddr", required_argument, NULL, 'm' },
     { "recursive", no_argument, NULL, 'R' },            /* Default */
@@ -2246,6 +2247,41 @@
 
 }
 
+static int display_sa_scan()
+{
+    int ret = -1;
+    int sockfd;
+    struct iwreq iwr;
+    u_int8_t *buf;
+    int buflen = 0;
+    struct kwn_sa_scan_result sa_result;
+    int i;
+
+    buflen = sizeof( struct kwn_sa_scan_result );
+    buf = (u_int8_t*)malloc(buflen);
+    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+
+    if (sockfd < 0) {
+        perror("socket");
+        return -1;
+    }
+    memset(&iwr, 0, sizeof(iwr));
+    strlcpy(iwr.ifr_name, "ath1", IFNAMSIZ);
+    iwr.u.data.pointer = (void *)buf;
+    iwr.u.data.length = buflen;
+    if ((ret = ioctl(sockfd, IEEE80211_IOCTL_SCAN_RESULTS, &iwr)) < 0) {
+        printf(" Error : ret %d \n",ret);
+        free(buf);
+        return ret;
+    }
+    memcpy( &sa_result, ( struct kwn_sa_scan_result *)buf, sizeof( struct kwn_sa_scan_result ) );
+    for( i = 0; i< sa_result.cnt; i++ )
+    {
+        printf("%d=%d=%d=%d=%d,",sa_result.sa_entry[i].channel,sa_result.sa_entry[i].frequency,
+                sa_result.sa_entry[i].utility,sa_result.sa_entry[i].pow_chain0,sa_result.sa_entry[i].pow_chain1);
+    }
+    return 0;
+}
 
 static int apstats_main(apstats_config_t *config)
 {
@@ -2567,6 +2603,9 @@
                 is_level_set  = 1;
                 is_option_selected = 1;
                 break;
+            case 'c':
+                display_sa_scan();
+                return 0;
 
             case 'i':
                 if (is_ifname_set) {
diff -urN qca-wifi-org/os/linux/tools/athstats.c qca-wifi-mod/os/linux/tools/athstats.c
--- qca-wifi-org/os/linux/tools/athstats.c	2018-06-08 11:00:40.000000000 +0530
+++ qca-wifi-mod/os/linux/tools/athstats.c	2019-04-25 13:48:22.871604760 +0530
@@ -633,9 +633,11 @@
 {
     fprintf(fd, "txrx stats:\n");
     if (stats_level == TXRX_STATS_LEVEL_BASIC) {
-        fprintf(fd,"  tx: %u msdus (%u B)\n",
+        fprintf(fd,"tx:%u\n",
+            stats->tx.delivered.pkts);
+        /* fprintf(fd,"  tx: %u msdus (%u B)\n",
             stats->tx.delivered.pkts,
-            stats->tx.delivered.bytes);
+            stats->tx.delivered.bytes); */
     } else { /* full */
         fprintf(fd,
             "  tx: sent %u msdus (%u B), "
@@ -661,10 +663,12 @@
             stats->tx.dropped.no_ack.pkts,
             stats->tx.dropped.no_ack.bytes);
     }
-    fprintf(fd,
+    fprintf(fd,"rx:%u\n",
+        stats->rx.delivered.pkts);
+    /*fprintf(fd,
         "  rx: %u msdus, %u bytes\n",
         stats->rx.delivered.pkts,
-        stats->rx.delivered.bytes);
+        stats->rx.delivered.bytes);*/
     if (stats_level == TXRX_STATS_LEVEL_FULL) {
         fprintf(fd,
             "    forwarded %u msdus, %u bytes\n",
@@ -727,11 +731,11 @@
     /* AMSDUs that have more MSDUs than the status ring size */
     fprintf(fd,"oversize_amsdu    :\t%d\n",rx->oversize_amsdu);
     /* Number of PHY errors */
-    fprintf(fd,"phy_errs          :\t%d\n",rx->phy_errs);
+    fprintf(fd,"phy_errors:%d\n",rx->phy_errs);
     /* Number of PHY errors dropped */
     fprintf(fd,"phy_errs dropped  :\t%d\n",rx->phy_err_drop);
     /* Number of mpdu errors - FCS, MIC, ENC etc. */
-    fprintf(fd,"mpdu_errs         :\t%d\n",rx->mpdu_errs);
+    fprintf(fd,"mpdu_errs:%d\n",rx->mpdu_errs);
 
 }
 
@@ -741,12 +745,13 @@
     const struct wlan_dbg_tx_stats *tx = &wlan_pdev_stats->tx;
     int   i;
 
-    fprintf(fd,"ast_be_xmit         :\t%llu\n",radio_stats->tx_beacon);
+    fprintf(fd,"ast_be_xmit:%llu\n",radio_stats->tx_beacon);
     fprintf(fd,"ast_be_nobuf        :\t%d\n",radio_stats->be_nobuf);
     fprintf(fd,"ast_tx_buf_count    :\t%u\n",radio_stats->tx_buf_count);
-    fprintf(fd,"ast_tx_packets      :\t%u\n",radio_stats->tx_mgmt + radio_stats->tx_num_data);
-    fprintf(fd,"ast_rx_packets      :\t%u\n",radio_stats->rx_packets);
+    fprintf(fd,"ast_tx_packets:%u\n",radio_stats->tx_mgmt + radio_stats->tx_num_data);
+    fprintf(fd,"ast_rx_packets:%u\n",radio_stats->rx_packets);
     fprintf(fd,"ast_tx_mgmt         :\t%d\n",radio_stats->tx_mgmt);
+    fprintf(fd,"ast_rx_mgmt         :\t%d\n",radio_stats->rx_mgmt);
     fprintf(fd,"ast_tx_nobuf        :\t%d\n",tx->wmm_drop);
     fprintf(fd,"ast_tx_xretries     :\t%u\n",tx->tx_xretry);
     fprintf(fd,"ast_rx_num_data     :\t%u\n",radio_stats->rx_num_data);
diff -urN qca-wifi-org/qca_ol/osif_ol.c qca-wifi-mod/qca_ol/osif_ol.c
--- qca-wifi-org/qca_ol/osif_ol.c	2018-06-08 11:00:50.000000000 +0530
+++ qca-wifi-mod/qca_ol/osif_ol.c	2019-05-14 19:01:06.025268836 +0530
@@ -73,6 +73,9 @@
 #include <osif_nss_wifiol_vdev_if.h>
 #endif
 
+#include "wds_addr.h"
+extern int
+wds_find(ol_scn_t scn, unsigned char *dest_mac, unsigned char *peer_mac, struct ieee80211vap **vap);
 
 #if (HOST_SW_LRO_ENABLE && ATH_PERF_PWR_OFFLOAD)
 extern void ath_lro_process_skb(struct sk_buff *skb, struct net_device *dev);
@@ -106,6 +109,17 @@
 extern bool osif_pltfrm_deliver_data(os_if_t osif, wbuf_t wbuf);
 #endif
 
+/* KWN Fragmentation structures */
+uint8_t kwn_tput_test_dsap[]    = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa };
+uint8_t kwn_tput_test_dsap_ul[] = { 0xbb, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa };
+uint8_t kwn_frag_dsap[]         = { 0xaa, 0xaa, 0xab, 0xab };
+struct kwn_frag_params {
+    uint16_t kwn_frag_flags;
+    uint16_t kwn_tot_len;
+    uint16_t kwn_pkt_pad;
+};
+#define KWN_LOG_PKT 0
+
 #if UMAC_VOW_DEBUG
 static inline void
 osif_ol_hadrstart_vap_vow_debug(osif_dev  *osdev, struct sk_buff *skb){
@@ -460,7 +474,17 @@
 }
 #endif /*end of ATH_DATA_RX_INFO_EN*/
 
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+	uint64_t kwn_tput_test_txseq;
+	uint64_t kwn_tput_test_rxseq;
+};
 
+struct sk_buff *last_skb = NULL;
+struct sk_buff *last_tx_skb = NULL;
 
 #if QCA_NSS_PLATFORM
 void
@@ -469,10 +493,11 @@
     struct net_device *dev = OSIF_TO_NETDEV(osif);
     osif_dev  *osdev = (osif_dev *)osif;
     int nwifi = ((osif_dev *)osif)->nss_nwifi;
+    struct ieee80211_stats *iv_stats;
 
-#if ATH_SUPPORT_WRAP
+//#if ATH_SUPPORT_WRAP
     wlan_if_t vap = osdev->os_if;
-#endif
+//#endif
 
 #if QCA_OL_VLAN_WAR
     struct net_device *comdev;
@@ -482,6 +507,8 @@
     scn = ath_netdev_priv(comdev);
 #endif /* QCA_OL_VLAN_WAR */
 
+    iv_stats = wlan_get_stats(vap);
+
     while (skb_list) {
         struct sk_buff *skb;
         skb = skb_list;
@@ -569,9 +596,243 @@
 	}
 #endif  /* HOST_SW_LRO_ENABLE */
 
-        osif_send_to_nss(osif, skb, nwifi);
+    if( !vap->kwn_softreset || vap->iv_ic->enable_acs || vap->iv_ic->enable_sa_scan ) {
+        //printk(": KWN: Softreset is in progress...drop rx data packet.\n");
+        dev_kfree_skb_any ( skb );
+        continue;
+    }
+
+    /* inc Tx packets/bytes offered by kernel to us */
+    iv_stats->rx_offer_pkt_cnt++;
+    iv_stats->rx_offer_pkt_bytes_cnt += skb->len;
+
+    if ( iv_stats->kwn_rx_tput_last_jiffies == 0 ) {
+        iv_stats->kwn_rx_tput_last_jiffies = jiffies;
+    } else {
+        if ( (jiffies - iv_stats->kwn_rx_tput_last_jiffies) >= 1000 )
+        {
+            iv_stats->kwn_rx_tput_mbps = iv_stats->rx_offer_pkt_cnt > 0 ? 
+                ( (iv_stats->rx_offer_pkt_bytes_cnt * 8)) : 0;
+            iv_stats->kwn_rx_tput_last_jiffies = jiffies;
+            iv_stats->rx_offer_pkt_cnt = 0;
+            iv_stats->rx_offer_pkt_bytes_cnt = 0;
+            //printk(": RX Tput: %llu\n",iv_stats->kwn_rx_tput_mbps);
+        }
+    }
+    /* In case of AP, update the inividual node statistics */
+    if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+        struct ieee80211_node *ni = NULL;
+        struct ether_header *eh;
+        uint8_t mac[6];
+        int ret = 0;
+
+        comdev = osdev->os_comdev;
+        scn = ath_netdev_priv(comdev);
+        eh = (struct ether_header *)(skb->data);
+        ni = ieee80211_find_txnode(vap, eh->ether_shost);
+        if ( ni == NULL ) {
+            ret = wds_find(scn, eh->ether_shost, &mac[0], NULL);  
+            if ( ret == 0 ) {
+                ni = ieee80211_find_txnode(vap, mac);
+            }
+        }
+        if ( ni ) {
+            /* inc Tx packets/bytes offered by kernel to us */
+            ni->rx_offer_pkt_cnt++;
+            ni->rx_offer_pkt_bytes_cnt += skb->len;
+
+            if ( ni->kwn_rx_tput_last_jiffies == 0 ) {
+                ni->kwn_rx_tput_last_jiffies = jiffies;
+            } else {
+                if ( (jiffies - ni->kwn_rx_tput_last_jiffies) >= 1000 )
+                {
+                    ni->rx_tput_mbps = ni->rx_offer_pkt_cnt > 0 ? 
+                        ( (ni->rx_offer_pkt_bytes_cnt * 8)) : 0;
+                    ni->kwn_rx_tput_last_jiffies = jiffies;
+                    ni->rx_offer_pkt_cnt = 0;
+                    ni->rx_offer_pkt_bytes_cnt = 0;
+                    //printk(": RX Tput: %llu\n",ni->rx_tput_mbps);
+                }
+            }
+            /* Re-assembly */
+            if ( skb->len > 20 &&
+                    (memcmp( &skb->data[sizeof(struct ether_header)], kwn_frag_dsap, sizeof(kwn_frag_dsap)) == 0 )) {
+                struct kwn_frag_params *kparams;
+                u_int8_t curflag = 0; 
+                kparams = (struct kwn_frag_params *)&skb->data[sizeof(struct ether_header) + sizeof(kwn_frag_dsap)];
+                curflag = ntohs(kparams->kwn_frag_flags);
+
+                //printk(": Before: CurFlag: %d LastFrag: %d\n",curflag, ni->kwn_lastfrag);
+                /* Prepare Jumbo Frame only if last fragment is received and 
+                   earlier fragments are already appended */
+                if ( (curflag == 0) && 
+                        ( ni->kwn_lastfrag == 1 || ni->kwn_lastfrag == 3)) {
+                    struct sk_buff *nskb;
+                    struct ether_header *eth;
+                    uint16_t ether_type = 0;
+                    /*int i = 0;*/
+
+                    /* Read the EtherType from SNAPHeader */
+                    ether_type = ntohs(kparams->kwn_tot_len);
+                    /*printk(": EtherType: %x\n",ether_type);*/
+
+                    /* Add packet to Q */
+                    vap->iv_pkt_q_add( &ni->kwn_txq, skb );
+                    nskb = vap->iv_pkt_q_assemble( &ni->kwn_txq );
+                    vap->iv_pkt_q_purge( &ni->kwn_txq );
+                    vap->iv_pkt_q_init( &ni->kwn_txq );
+
+                    /* Change the EtherType to the original packet EtherType */
+                    eth = (struct ether_header *) &nskb->data[ 0 ];
+                    eth->ether_type = ether_type;
+
+                    /* Log the first 20 bytes */
+                    /*for ( i = 0; i < 20; i++ ) {
+                      printk(": %x",nskb->data[i]);
+                      }
+                      printk("\n");*/
+
+                    osif_send_to_nss(osif, nskb, nwifi); 
+                    //printk(": JumboFrame : CurFlag: %d LastFrag: %d\n",curflag, ni->kwn_lastfrag);
+                    ni->kwn_lastfrag = curflag;
+                    ieee80211_free_node(ni);
+                    continue;
+                } else {
+                    /* Add packet to Q */
+                    if ( ( curflag == 1 && ni->kwn_lastfrag == 0 ) || 
+                            ( curflag == 3 && (ni->kwn_lastfrag == 1 || ni->kwn_lastfrag == 3 ))) {
+                        //printk(": Append : CurFlag: %d LastFrag: %d\n",curflag, ni->kwn_lastfrag);
+                        vap->iv_pkt_q_add( &ni->kwn_txq, skb );
+                        ni->kwn_lastfrag = curflag;
+                    } else {
+                        //printk(": DropPrev&AddNew: CurFlag: %d LastFrag: %d\n",curflag, ni->kwn_lastfrag);
+                        vap->iv_pkt_q_purge( &ni->kwn_txq );
+                        vap->iv_pkt_q_init( &ni->kwn_txq );
+                        vap->iv_pkt_q_add( &ni->kwn_txq, skb );
+                        ni->kwn_lastfrag = curflag;
+                    }
+                    ieee80211_free_node(ni);
+                    continue;
+                }
+            }
+            ieee80211_free_node(ni);
+        }
+    } else {
+        /* KWN: Extra Padding */
+        if ( vap->kwn_assem_frag == 2 ) {
+            if ( skb->len > 20 &&
+                    (memcmp( &skb->data[sizeof(struct ether_header)], kwn_frag_dsap, sizeof(kwn_frag_dsap)) == 0 )) {
+                struct kwn_frag_params *kparams;
+                int elen = sizeof(struct ether_header);
+                int flen = sizeof(struct kwn_frag_params) + sizeof(kwn_frag_dsap);
+                int pull_len = 0;
+
+                kparams = (struct kwn_frag_params *)&skb->data[sizeof(struct ether_header) + sizeof(kwn_frag_dsap)];
+                pull_len += (elen + flen + ntohs(kparams->kwn_pkt_pad));
+                skb_pull(skb, pull_len); 
+            }
+        } else {
+            /* Re-assembly */
+            if ( skb->len > 20 &&
+                    (memcmp( &skb->data[sizeof(struct ether_header)], kwn_frag_dsap, sizeof(kwn_frag_dsap)) == 0 )) {
+                struct kwn_frag_params *kparams;
+                u_int8_t curflag = 0;
+                kparams = (struct kwn_frag_params *)&skb->data[sizeof(struct ether_header) + sizeof(kwn_frag_dsap)];
+                curflag = ntohs(kparams->kwn_frag_flags);
+
+                //printk(": Before : CurFlag: %d LastFrag: %d\n",curflag, vap->kwn_lastfrag);
+                /* Prepare Jumbo Frame only if last fragment is received and 
+                   earlier fragments are already appended */
+                if ( (curflag == 0) && 
+                        ( vap->kwn_lastfrag == 1 || vap->kwn_lastfrag == 3)) {
+                    struct sk_buff *nskb;
+                    struct ether_header *eth;
+                    uint16_t ether_type = 0;
+                    /*int i = 0;*/
+
+                    /* Read the EtherType from SNAPHeader */
+                    ether_type = ntohs(kparams->kwn_tot_len);
+                    /*printk(": EtherType: %x\n",ether_type);*/
+
+                    /* Add packet to Q */
+                    vap->iv_pkt_q_add( &vap->kwn_txq, skb );
+                    nskb = vap->iv_pkt_q_assemble( &vap->kwn_txq );
+                    vap->iv_pkt_q_purge( &vap->kwn_txq );
+                    vap->iv_pkt_q_init( &vap->kwn_txq );
+
+                    /* Change the EtherType to the original packet EtherType */
+                    eth = (struct ether_header *) &nskb->data[ 0 ];
+                    eth->ether_type = ether_type;
+
+                    /* Log the first 20 bytes */
+                    /*for ( i = 0; i < 20; i++ ) {
+                      printk(": %x",nskb->data[i]);
+                      }
+                      printk("\n");*/
+
+                    osif_send_to_nss(osif, nskb, nwifi);
+                    vap->kwn_lastfrag = curflag;
+                    continue;
+                } else {
+                    /* Add packet to Q */
+                    if ( (curflag == 1 && vap->kwn_lastfrag == 0 ) || 
+                            ( curflag == 3 && (vap->kwn_lastfrag == 1 || vap->kwn_lastfrag == 3 ))) {
+                        //printk(": Append : CurFlag: %d LastFrag: %d\n",curflag, vap->kwn_lastfrag);
+                        vap->iv_pkt_q_add( &vap->kwn_txq, skb );
+                        vap->kwn_lastfrag = curflag;
+                    } else {
+                        //printk(": DropOld&AddNew : CurFlag: %d LastFrag: %d\n",curflag, vap->kwn_lastfrag);
+                        vap->iv_pkt_q_purge( &vap->kwn_txq );
+                        vap->iv_pkt_q_init( &vap->kwn_txq );
+                        vap->iv_pkt_q_add( &vap->kwn_txq, skb );
+                        vap->kwn_lastfrag = curflag;
+                    }
+                    continue;
+                }
+            }
+        }
+    }
+	/* In case of KWN Tput Packets, then drop them immediately */
+    if ( skb->len > 20 && 
+            (memcmp(&skb->data[sizeof(struct ether_header)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap)) == 0)) {
+        struct kwn_tput_test_params *kparams;
+        int offset = 0;
+
+        offset += sizeof(struct ether_header) + sizeof(kwn_tput_test_dsap);
+        kparams = (struct kwn_tput_test_params *)&skb->data[ offset ];
+
+        if( ntohl(kparams->kwn_tput_test_txseq) == 0 ) {
+            vap->kwn_tput_test_rx_failed_cnt = 0;
+            vap->kwn_tput_test_rxseq = ntohl(kparams->kwn_tput_test_txseq);
+        }
+        else if( ntohl(kparams->kwn_tput_test_txseq) > vap->kwn_tput_test_rxseq ) {
+            if ( ntohl(kparams->kwn_tput_test_txseq) - vap->kwn_tput_test_rxseq > 1 ) {
+                vap->kwn_tput_test_rx_failed_cnt += ( ntohl(kparams->kwn_tput_test_txseq) - vap->kwn_tput_test_rxseq - 1 );
+            }
+            vap->kwn_tput_test_rxseq = ntohl(kparams->kwn_tput_test_txseq);
+        }
+        else if( ntohl(kparams->kwn_tput_test_txseq) == vap->kwn_tput_test_rxseq ) {
+        }
+        else {
+            vap->kwn_tput_test_rx_failed_cnt = ( vap->kwn_tput_test_rx_failed_cnt > 0 ? vap->kwn_tput_test_rx_failed_cnt : 0 );
+            printk(": FailedCount: TxSeq: %llu RxSeq: %llu \n", vap->kwn_tput_test_txseq, vap->kwn_tput_test_rxseq);
+            vap->kwn_tput_test_rxseq = ntohl(kparams->kwn_tput_test_txseq);
+        }
+        dev_kfree_skb_any ( skb );
+        continue;
     }
 
+    /* Initial test packets sent to make sure that data transmission is properly set or not */
+    if ( skb->len > 20 && 
+            (memcmp(&skb->data[sizeof(struct ether_header)], kwn_tput_test_dsap_ul, sizeof(kwn_tput_test_dsap_ul)) == 0)) {
+        struct ether_header *eth;
+        eth = (struct ether_header *)(skb->data);
+        printk(": TXBA RX: skb->len: %d Shost %s\n",skb->len,ether_sprintf(eth->ether_shost));
+        dev_kfree_skb_any ( skb );
+        continue;
+    }
+    osif_send_to_nss(osif, skb, nwifi);
+    }
 #if HOST_SW_LRO_ENABLE
     if ((dev->features & NETIF_F_LRO) || osdev->os_if->lro_to_flush) {
         ath_lro_flush_all(dev);         /* flush all LRO pkts */
@@ -830,14 +1091,118 @@
     struct ol_ath_softc_net80211 *pscn = NULL;
 #endif
     struct ieee80211_stats *iv_stats;
+    u_int32_t bw_limit = 0;
 
     osdev = ath_netdev_priv(dev);
     vap = osdev->os_if;
     iv_stats = wlan_get_stats(vap);
+
+
+    if( !vap->kwn_softreset || vap->iv_ic->enable_acs || vap->iv_ic->enable_sa_scan ) {
+        //printk(": KWN: Softreset is in progress...drop tx data packet.\n");
+        goto bad1;
+    }
+
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+        if( vap->kwn_traffic_shaping ) {
+            bw_limit = vap->kwn_final_dl_limit;
+        }
+    }
+    else {
+        if( !vap->kwn_suservice ) {
+            bw_limit = vap->kwn_su_kbps;
+        }
+        else {
+            if( vap->kwn_traffic_shaping ) {
+                bw_limit = vap->kwn_final_ul_limit;
+            }
+        }
+    }
     /* inc Tx packets/bytes offered by kernel to us */
     iv_stats->tx_offer_pkt_cnt++;
     iv_stats->tx_offer_pkt_bytes_cnt += skb->len;
 
+    if ( iv_stats->kwn_tx_tput_last_jiffies == 0 ) {
+	    iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+    } else {
+	    if ( (jiffies - iv_stats->kwn_tx_tput_last_jiffies) >= 1000 )
+	    {
+		    iv_stats->kwn_tx_tput_mbps = iv_stats->tx_offer_pkt_cnt > 0 ? 
+						( ( (iv_stats->tx_offer_pkt_bytes_cnt - iv_stats->tx_byte_drop_cnt ) * 8)) : 0;
+		    iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+		    iv_stats->tx_offer_pkt_cnt = 0;
+		    iv_stats->tx_offer_pkt_bytes_cnt = 0;
+			iv_stats->tx_byte_drop_cnt = 0;
+		    //printk(": Tx Tput: %llu\n",iv_stats->kwn_tx_tput_mbps);
+	    }
+        else {
+            /* If Traffic Shaping enabled or SU Service disabled, drop if total byte cnt > bw_limit in 1 sec */
+            if( bw_limit &&  (vap->iv_opmode != IEEE80211_M_HOSTAP) ) {
+                if( iv_stats->tx_offer_pkt_bytes_cnt > ( ( bw_limit * 1000 ) / 8 ) ) {
+                    iv_stats->tx_byte_drop_cnt += skb->len;
+                    goto bad1;
+                }
+            }
+        }
+    }
+
+    /* In case of AP, update the inividual node statistics */
+    if ( vap->iv_opmode == IEEE80211_M_HOSTAP )
+    {
+        struct ieee80211_node *ni = NULL;
+        struct ether_header *eh;
+        uint8_t mac[6];
+        int ret = 0;
+        
+        comdev = osdev->os_comdev;
+        scn = ath_netdev_priv(comdev);
+        eh = (struct ether_header *)(skb->data);
+        ni = ieee80211_find_txnode(vap, eh->ether_dhost);
+        if ( ni == NULL ) {
+            ret = wds_find(scn, eh->ether_dhost, &mac[0], NULL);  
+            if ( ret == 0 ) {
+                ni = ieee80211_find_txnode(vap, mac);
+            }
+        }
+        if ( ni ) {
+            bw_limit = 0;
+            /* Update the bw_limit per-node basis */
+            if( ni->kwn_traffic_shaping ) {
+                bw_limit = ni->kwn_dl_limit;
+            }
+
+            /* inc Tx packets/bytes offered by kernel to us */
+            ni->tx_offer_pkt_cnt++;
+            ni->tx_offer_pkt_bytes_cnt += skb->len;
+
+            if ( ni->kwn_tx_tput_last_jiffies == 0 ) {
+                ni->kwn_tx_tput_last_jiffies = jiffies;
+            } else {
+                if ( (jiffies - ni->kwn_tx_tput_last_jiffies) >= 1000 )
+                {
+                    ni->tx_tput_mbps = ni->tx_offer_pkt_cnt > 0 ? 
+                        ( ( ( ni->tx_offer_pkt_bytes_cnt - ni->tx_byte_drop_cnt ) * 8)) : 0;
+                    ni->kwn_tx_tput_last_jiffies = jiffies;
+                    ni->tx_offer_pkt_cnt = 0;
+                    ni->tx_offer_pkt_bytes_cnt = 0;
+			        ni->tx_byte_drop_cnt = 0;
+                    //printk(": TX Tput: %llu\n",ni->tx_tput_mbps);
+                }
+                else {
+                    /* If Traffic Shaping enabled or SU Service disabled, drop if total byte cnt > bw_limit in 1 sec */
+                    if( bw_limit ) {
+                        if( ni->tx_offer_pkt_bytes_cnt > ( ( bw_limit * 1000 ) / 8 ) ) {
+                            ni->tx_byte_drop_cnt += skb->len;
+                            ieee80211_free_node(ni);
+                            goto bad1;
+                        }
+                    }
+                }
+            }
+            ieee80211_free_node(ni);
+        }
+    }
+
     qdf_nbuf_count_inc(skb);
     if (qdf_unlikely((dev->flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP))) {
 	    goto bad1;
@@ -968,9 +1333,196 @@
     }
 #endif
 
+    /* If Packet started in Local, then Tag the packet with MgmtVLANID*/
+    if ( vap->kwn_mgmt_vlan_id > 0 && vap->kwn_allow_tagged_mgmt ) {
+	    eh = (struct ether_header *)(skb->data);
+	    if ( memcmp ( vap->kwn_eth_mac_addr, eh->ether_shost, 6 ) == 0 ) {
+		    skb = __vlan_put_tag( skb, htons(ETH_P_8021Q), vap->kwn_mgmt_vlan_id );
+		    if ( unlikely ( !skb ) ) {
+			    goto bad1;
+		    }
+	    }
+    }
 
-    osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
+#if 0
+    /* BGP Prioritization */
+    {
+      uint8_t *p;
+      eh = (struct ether_header *)(skb->data);
+      p = (uint8_t*)(eh+1);
+      if( eh->ether_type == __constant_htons(ETHERTYPE_IP) ) {
+        struct iphdr *p_ip = (struct iphdr *)(p);
+        if (p_ip->protocol == IPPROTO_TCP) {
+          skb->priority = 9;
+        }
+      } else if( eh->ether_type == __constant_htons(ETHERTYPE_IPV6) ) {
+        struct ipv6hdr *p_ip6 = (struct ipv6hdr *)(p);
+        if (p_ip6->nexthdr == IPPROTO_TCP) {
+          skb->priority = 9;
+        }
+      } 
+    }
+#endif
+    /* KWN: AMSDU at Host */
+    if ( vap->kwn_assem_frag == 1 ) {
+        if ( skb->len < vap->kwn_max_pkt_size ) {
+            osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
+            goto out;
+        } else {
+            struct sk_buff *nskb;
+            struct ether_header *neth;
+            struct ether_header *oeth;
+            int frag_len = vap->kwn_frag_pkt_size;
+            struct kwn_frag_params *kparams;
+            int eth_reserve = 64;
+            int pkt_size = 0;
+            int offset = 0;
+            int ooffset = 0;
+            int flen = sizeof(kwn_frag_dsap) + sizeof(struct kwn_frag_params);
+            int elen = sizeof(struct ether_header);
+            int nlen = elen + flen;
+            int oskb_max_len = 0;
+            //int i = 0;
+            int fragflag = 1;
+
+            /* Log the EtherType on TX in original packet */
+            /*oeth = ( struct ether_header * )  &skb->data[ 0 ];
+              printk(": PktSize: %d EtherType: %x\n",skb->len, oeth->ether_type );*/
+
+            /* Log the first 20 bytes */
+            /*for ( i = 0; i < 20; i++ ) {
+              printk(": %x",skb->data[i]);
+              }
+              printk("\n");*/
+
+            oskb_max_len = skb->len - elen;
+            ooffset += elen;
+            for ( ; frag_len > 0 ; ) {
+
+                /* Create a packet */
+                pkt_size = nlen + frag_len;
+                nskb = dev_alloc_skb ( pkt_size + eth_reserve );
+                if ( nskb == NULL ) {
+                    break;
+                }
+                /* Fill the skb content */
+                offset = 0;
+                skb_reserve( nskb, eth_reserve );
+                skb_put( nskb, pkt_size );
+                /* Reset to ZERO */
+                memset( &nskb->data[ offset ], 0, pkt_size );
+                nskb->dev = skb->dev;
+
+                /* Ethernet Header */
+                offset = 0;
+                neth = ( struct ether_header * ) &nskb->data[ offset ];
+                oeth = ( struct ether_header * )  &skb->data[ offset ];
+                IEEE80211_ADDR_COPY( neth->ether_dhost, oeth->ether_dhost );
+                IEEE80211_ADDR_COPY( neth->ether_shost, oeth->ether_shost );
+                neth->ether_type = htons( frag_len + flen );
+                offset += elen;
+
+                /* DSAP + Flags */
+                memcpy(&nskb->data[ offset ], kwn_frag_dsap, sizeof(kwn_frag_dsap));
+                kparams = (struct kwn_frag_params *)&nskb->data[ offset + sizeof(kwn_frag_dsap) ];
+                /* Update the fragflags: First(1), Middle(3) or last(0) */
+                kparams->kwn_frag_flags = htons(fragflag);
+                kparams->kwn_tot_len = htons(oeth->ether_type);
+                offset += flen;
+
+                //printk(": TX: fragflag: %d PktSize: %d \n",fragflag, frag_len);
+
+                /* Payload : New Offset will be ahead by 6 bytes compared with old Offset */
+                memcpy(&nskb->data[ offset ], &skb->data[ ooffset ], frag_len);
+                skb_reset_mac_header( nskb );
+                /* TX Pkt */
+                nskb->priority = skb->priority;
+                osdev->iv_vap_send(osdev->iv_txrx_handle, nskb);
+
+                //printk(": Before: ooffset: %d FragLen: %d Nksb: %d\n",ooffset, frag_len, nskb->len);
+                /* Update New Pkt Len */
+                ooffset += frag_len;
+                oskb_max_len = oskb_max_len - frag_len;
+                if ( oskb_max_len >= vap->kwn_max_pkt_size ) {
+                    frag_len = vap->kwn_frag_pkt_size;
+                    if ( oskb_max_len > frag_len ) {
+                        fragflag = 3;
+                    }
+                    else {
+                        fragflag = 0;
+                    }
+                } else {
+                    frag_len = oskb_max_len;
+                    fragflag = 0;
+                }
+                //printk(": After: ooffset: %d FragLen: %d Nksb: %d\n",ooffset, frag_len, nskb->len);
+            }
+            /* Drop the original packet */
+            if (skb != NULL)
+                qdf_nbuf_free(skb);
+        }     
+    } else if ( vap->kwn_assem_frag == 2 ) {
+        /* */
+        struct sk_buff *nskb;
+        struct ether_header *neth;
+        struct ether_header *oeth;
+        struct kwn_frag_params *kparams;
+        int flen = sizeof(kwn_frag_dsap) + sizeof(struct kwn_frag_params);
+        int elen = sizeof(struct ether_header);
+        int pad = vap->kwn_max_pkt_size - skb->len;
+        int offset = 0;
+        int eth_reserve = 64;
+        int pkt_size = 0;
+
+        if ( pad < 0 ) {
+            pad = 0;
+        }
 
+        /* Create a packet */
+        pkt_size = elen + flen + skb->len + pad;
+        nskb = dev_alloc_skb ( pkt_size + eth_reserve );
+        if ( nskb == NULL ) {
+            goto bad;
+        }
+
+        /* Fill the skb content */
+        offset = 0;
+        skb_reserve( nskb, eth_reserve );
+        skb_put( nskb, pkt_size );
+        /* Reset to ZERO */
+        memset( &nskb->data[ offset ], 0, pkt_size );
+        nskb->dev = skb->dev;
+
+        /* Ethernet Header */
+        neth = ( struct ether_header * ) &nskb->data[ offset ];
+        oeth = ( struct ether_header * )  &skb->data[ offset ];
+        IEEE80211_ADDR_COPY( neth->ether_dhost, oeth->ether_dhost );
+        IEEE80211_ADDR_COPY( neth->ether_shost, oeth->ether_shost );
+        neth->ether_type = oeth->ether_type;
+        offset += elen;
+
+        /* DSAP + Flags */
+        memcpy(&nskb->data[ offset ], kwn_frag_dsap, sizeof(kwn_frag_dsap));
+        kparams = (struct kwn_frag_params *)&nskb->data[ offset + sizeof(kwn_frag_dsap) ];
+        kparams->kwn_frag_flags = htons(0);
+        kparams->kwn_tot_len = htons(skb->len);
+        kparams->kwn_pkt_pad = htons(pad);
+
+        offset += flen + pad;
+
+        /* Copy the Original packet into New Packet */
+        memcpy(&nskb->data[ offset ], &skb->data[ 0 ], skb->len);
+
+        skb_reset_mac_header( nskb );
+        /* TX Pkt */
+        nskb->priority = skb->priority;
+        osdev->iv_vap_send(osdev->iv_txrx_handle, nskb);
+        /* Drop the original packet */
+        if (skb != NULL)
+            qdf_nbuf_free(skb);
+    } else {
+        osdev->iv_vap_send(osdev->iv_txrx_handle, skb);
+    }
 out:
     OSIF_VAP_TX_UNLOCK(osdev);
     return 0;
diff -urN qca-wifi-org/umac/base/ieee80211_channel.c qca-wifi-mod/umac/base/ieee80211_channel.c
--- qca-wifi-org/umac/base/ieee80211_channel.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_channel.c	2018-11-15 11:29:43.018412290 +0530
@@ -21,6 +21,7 @@
 #include <if_smart_ant.h>
 #include <qdf_lock.h>
 #include <osif_private.h>
+#include <ieee80211_acs_internal.h>
 
 int ieee80211_ucfg_set_chanswitch(wlan_if_t vaphandle, u_int8_t chan, u_int8_t tbtt, u_int16_t ch_width);
 
@@ -353,6 +354,74 @@
     osif_update_info_to_app(ic, buf);
 }
 
+struct ieee80211_channel * kwn_find_channel(struct ieee80211com *ic, struct ieee80211vap *vap, u_int16_t freq )
+{
+    struct ieee80211_channel *c;
+    u_int32_t flags;
+
+    switch( vap->iv_des_mode )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                flags = IEEE80211_CHAN_A;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                flags = IEEE80211_CHAN_11NA_HT20;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                flags = IEEE80211_CHAN_11NA_HT40PLUS;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40MINUS:
+            {
+                flags = IEEE80211_CHAN_11NA_HT40MINUS;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT20;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT40PLUS;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT40;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT40MINUS;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                flags = IEEE80211_CHAN_11AC_VHT80;
+                break;
+            }
+        default:
+            return NULL;
+    }
+
+    c = ieee80211_find_channel( ic, freq, 0, flags );
+    return c;
+}
+
+void kwn_sa_set_channel( struct ieee80211com *ic )
+{
+    ic->ic_set_channel( ic );
+}
 
 /*
  * Locate a channel given a frequency+flags.  We cache
@@ -1930,6 +1999,7 @@
 {
     struct ieee80211vap *vap = vaphandle;
     struct ieee80211com *ic = vap->iv_ic;
+    struct ieee80211_acs *acs = ic->ic_acs;
 
     if (!channel) {
         IEEE80211_DPRINTF(vap, IEEE80211_MSG_ACS,
@@ -1989,6 +2059,19 @@
      * TBD: If curchan = channel, still need to set channel again to pass
      * SendRecv_ext in ndistest.
      */
+    /* Fixed channel in client mode: updating configured frequency if acs is disabled */
+    if( ic->sta_freq == 0 )
+       ic->sta_freq = channel->ic_freq;
+
+    /* TODO: Fixed channel in client mode is not working on 80MHz, so enabling ACS on 80MHz*/
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP || vap->iv_des_mode == IEEE80211_MODE_11AC_VHT80 )
+    {
+        /* For Fixed channel in AP, updating the acs chans to 0 */
+        if( ic->sta_freq > 0 ) {
+            acs->acs_nchans_scan = 0;
+        }
+        ic->sta_freq = -1;
+    }
     if (ieee80211_vap_ready_is_set(vap) || ieee80211_vap_dfswait_is_set(vap) ||
         (ic->cw_inter_found)) {// && ic->ic_curchan != channel) {
         ieee80211_set_channel(ic, channel);
diff -urN qca-wifi-org/umac/base/ieee80211_config.c qca-wifi-mod/umac/base/ieee80211_config.c
--- qca-wifi-org/umac/base/ieee80211_config.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_config.c	2019-03-08 19:32:04.575106524 +0530
@@ -478,12 +478,13 @@
              vap->iv_fixed_rate.series = IEEE80211_FIXED_RATE_NONE;
         } else {
              if (val & 0x80) {
-
+#if 0
                 if (!IEEE80211_IS_CHAN_VHT(ic->ic_curchan) && !IEEE80211_IS_CHAN_11N(ic->ic_curchan))
                 {
                     QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "Rate is not allowed in current mode\n");
                     return -EINVAL;
                 }
+#endif
                 vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_MCS;
              } else {
                  vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_LEGACY;
@@ -1115,9 +1116,10 @@
          }
          vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_NONE;
 
-         if (val > 9) {
+         if (val == 21) {
             /* Treat this as disabling fixed rate */
-            return EOK;
+             break;
+            //return EOK;
          }
 
 	 if (is2GHz && (val > 7) && (!ieee80211_vap_256qam_is_set(vap))) {
@@ -1125,10 +1127,14 @@
 		 return EOK;
 	 }
 
+         vap->iv_nss = 1;
+         if( val > 9 ) {
+             vap->iv_nss = 2;
+             val = val - 10;
+         }
          vap->iv_fixed_rate.mode   = IEEE80211_FIXED_RATE_VHT;
          vap->iv_vht_fixed_mcs = val;
     break;
-
     case IEEE80211_FIXED_NSS:
          if (val > ieee80211_getstreams(ic, ic->ic_tx_chainmask))
          return -EINVAL;
@@ -1242,6 +1248,8 @@
     break;
 
     case IEEE80211_ENABLE_RTSCTS:
+    /* KWN */
+#if 0
          if (((val & (~0xff)) != 0) ||
              (((val & 0x0f) == 0) && (((val & 0xf0) >> 4) != 0)) ||
              (((val & 0x0f) != 0) && (((val & 0xf0) >> 4) == 0)) ) {
@@ -1254,8 +1262,15 @@
                      __func__, val);
              return -EINVAL;
          }
-
-         vap->iv_rtscts_enabled = val;
+#endif
+         if (val == 1 || val == 0) {
+             vap->iv_rtscts_enabled = val;
+         }
+         else {
+             QDF_PRINT_INFO(ic->ic_print_idx, QDF_MODULE_ID_ANY, QDF_TRACE_LEVEL_INFO, "%s: Not yet supported value for RTS-CTS: %x\n",
+                     __func__, val);
+             return -EINVAL;
+         }
     break;
 
     case IEEE80211_RC_NUM_RETRIES:
@@ -2667,7 +2682,6 @@
              val = vap->iv_vht_fixed_mcs;
          }
     break;
-
     case IEEE80211_FIXED_NSS:
          val = vap->iv_nss;
     break;
diff -urN qca-wifi-org/umac/base/ieee80211_node.c qca-wifi-mod/umac/base/ieee80211_node.c
--- qca-wifi-org/umac/base/ieee80211_node.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_node.c	2019-05-14 19:01:26.565138481 +0530
@@ -132,6 +132,8 @@
 #define	ieee80211_node_dectestref(_ni) \
     atomic_dec_and_test(&(_ni)->ni_refcnt)
 
+uint8_t kwn_tput_test_dsap_ul[] = { 0xbb, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa };
+
 static void
 ieee80211_node_table_reset(struct ieee80211_node_table *nt, struct ieee80211vap *match);
 
@@ -142,6 +144,106 @@
     struct ieee80211_node *nodes[IEEE80211_512_AID];
 };
 
+struct kwn_power {
+    uint8_t ac_power[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t na_power[ KWN_11NA_RATE_MAX + 1 ];
+    uint8_t a_power[ KWN_11A_RATE_MAX + 1 ];
+};
+
+struct kwn_snr {
+    uint8_t ac_snr[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t na_snr[ KWN_11NA_RATE_MAX + 1 ];
+    uint8_t a_snr[ KWN_11A_RATE_MAX + 1 ];
+};
+
+struct kwn_auto_indx {
+    uint8_t ac_inc_indx[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t ac_dec_indx[ KWN_11AC_RATE_MAX + 1 ];
+    uint8_t na_inc_indx[ KWN_11NA_RATE_MAX + 1 ];
+    uint8_t na_dec_indx[ KWN_11NA_RATE_MAX + 1 ];
+};
+
+struct kwn_power power_20mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 26, 25, 25, 24, 24, 23, 23, 22, 21, 20, 26, 25, 25, 24, 24, 23, 23, 22, 21, 20 },
+    { 26, 25, 24, 23, 23, 22, 21, 20, 26, 25, 24, 23, 23, 22, 21, 20 },
+    { 26, 25, 24, 23, 23, 22, 21, 20 }
+};
+
+struct kwn_power power_40mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 26, 25, 25, 24, 24, 23, 23, 22, 21, 20, 26, 25, 25, 24, 24, 23, 23, 22, 21, 20 },
+    { 26, 25, 24, 23, 23, 22, 21, 20, 26, 25, 24, 23, 23, 22, 21, 20 },
+    { 26, 25, 24, 23, 23, 22, 21, 20 }
+};
+
+struct kwn_power power_80mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 26, 25, 25, 24, 24, 23, 23, 22, 21, 20, 26, 25, 25, 24, 24, 23, 23, 22, 21, 20 },
+    { 26, 25, 24, 23, 23, 22, 21, 20, 26, 25, 24, 23, 23, 22, 21, 20 },
+    { 26, 25, 24, 23, 23, 22, 21, 20 }
+};
+
+struct kwn_snr minsnr_20mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    {  7,  8,  9, 10, 11, 14, 16, 18, 23, 24,  7,  8, 10, 12, 14, 18, 20, 22, 25, 27 },
+    {  7,  8,  9, 10, 11, 14, 16, 18, 7,   8, 10, 12, 14, 18, 20, 22 },
+    {  7,  8,  9, 10, 11, 14, 16, 18 }
+};
+
+struct kwn_snr minsnr_40mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    {  7,  8,  9, 11, 12, 16, 18, 19, 23, 26,  7,  8, 10, 12, 15, 20, 22, 24, 27, 30 },
+    {  7,  8,  9, 11, 12, 16, 18, 19,  7,  8, 10, 12, 15, 20, 22, 24 },
+    {  7,  8,  9, 11, 12, 16, 18, 19 }
+};
+
+struct kwn_snr minsnr_80mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    {  7,  8,  9, 10, 13, 17, 18, 20, 23, 26, 10, 12, 13, 15, 16, 20, 22, 24, 29, 30 },
+    {  7,  8,  9, 10, 13, 17, 18, 20, 10, 12, 13, 15, 16, 20, 22, 24 },
+    {  7,  8,  9, 10, 13, 17, 18, 20 }
+};
+
+struct kwn_snr maxsnr_20mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 80, 80, 80, 80, 80, 65, 65, 65, 62, 62, 80, 80, 80, 80, 80, 64, 64, 64, 62, 62 },
+    { 80, 80, 80, 80, 80, 65, 65, 65, 80, 80, 80, 80, 80, 64, 64, 64 },
+    { 80, 80, 80, 80, 80, 65, 65, 65 }
+};
+
+struct kwn_snr maxsnr_40mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 80, 80, 80, 80, 80, 65, 65, 65, 63, 63, 80, 80, 80, 80, 80, 63, 63, 63, 62, 62 },
+    { 80, 80, 80, 80, 80, 65, 65, 65, 80, 80, 80, 80, 80, 63, 63, 63 },
+    { 0,  0,  0,  0,  0,  0,  0,  0 }
+};
+
+struct kwn_snr maxsnr_80mhz = 
+{
+    /* 0   1   2  3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19 */
+    { 80, 80, 80, 80, 80, 65, 65, 65, 62, 62, 80, 80, 80, 80, 80, 65, 65, 65, 63, 63 },
+    { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
+    { 0,  0,  0,  0,  0,  0,  0,  0 }
+};
+
+struct kwn_auto_indx auto_indx = 
+{
+  /* 0   1   2   3   4    5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 */
+  { 10,  2,  11, 12, 13,  6,  7, 14,  9, 15,  1,  3,  4,  5,  8, 16, 17, 18, 19, -1 },
+  { -1, 10,  1,  11, 12, 13,  5,  6, 14,  8,  0,  2,  3,  4,  7, 9,  15, 16, 17, 18 },
+  {  8,  2,  9,  10, 11,  6,  7, 12,  1,  3,  4,  5, 13, 14, 15, -1 },
+  { -1,  8,  1,   9, 10, 11,  5,  6,  0,  2,  3,  4,  7, 12, 13, 14 }
+};
+
 #define IEEE80211_NODE_ITER_F_ASSOC_STA     0x1
 #define IEEE80211_NODE_ITER_F_UNASSOC_STA   0x2
 static void
@@ -151,10 +253,905 @@
 ieee80211_node_remove_ipv6_by_node(struct ieee80211_node_table *nt, struct ieee80211_node *ni);
 #endif
 
-
 extern void
 ol_if_mgmt_drain(struct ieee80211_node *ni, int force);
 
+extern void ieee80211_apply_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni, int16_t channel, int8_t pwr, int8_t rate );
+
+uint8_t kwn_get_radio_power( struct ieee80211vap *vap, uint8_t mcs )
+{
+    uint8_t power = 26;
+
+    switch( wlan_get_current_phymode(vap) )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                power = power_20mhz.a_power[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                power = power_20mhz.na_power[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                power = power_40mhz.na_power[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                power = power_20mhz.ac_power[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                power = power_40mhz.ac_power[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                power = power_80mhz.ac_power[ mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return power;
+}
+
+uint8_t kwn_get_min_snr( struct ieee80211vap *vap, uint8_t mcs )
+{
+    uint8_t min_snr = 128;
+
+    switch( wlan_get_current_phymode(vap) )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                min_snr = minsnr_20mhz.a_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                min_snr = minsnr_20mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                min_snr = minsnr_40mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                min_snr = minsnr_20mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                min_snr = minsnr_40mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                min_snr = minsnr_80mhz.ac_snr[ mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return min_snr;
+}
+
+uint8_t kwn_get_max_snr( struct ieee80211vap *vap, uint8_t mcs )
+{
+    uint8_t max_snr = 0;
+
+    switch( wlan_get_current_phymode(vap) )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                max_snr = maxsnr_20mhz.a_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+            {
+                max_snr = maxsnr_20mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                max_snr = maxsnr_40mhz.na_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+            {
+                max_snr = maxsnr_20mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+            {
+                max_snr = maxsnr_40mhz.ac_snr[ mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                max_snr = maxsnr_80mhz.ac_snr[ mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return max_snr;
+}
+
+void kwn_get_maxrate( struct ieee80211vap *vap, uint8_t *max_srate, uint8_t *max_rate )
+{
+    switch( wlan_get_current_phymode(vap) )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                *max_srate = KWN_11A_SRATE_MAX;
+                *max_rate  = KWN_11A_RATE_MAX;
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                *max_srate = KWN_11NA_SRATE_MAX;
+                *max_rate  = KWN_11NA_RATE_MAX;
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                *max_srate = KWN_11AC_SRATE_MAX;
+                *max_rate  = KWN_11AC_RATE_MAX;
+                break;
+            }
+        default:
+            return;
+    }
+    return;
+}
+
+uint8_t kwn_get_remote_snr( struct ieee80211com *ic, struct ieee80211_node *ni, u_int8_t mcs )
+{
+    struct ieee80211vap *vap;
+    uint8_t r_min_snr, r_max_snr, l_min_snr, l_max_snr, stream;
+    uint8_t max_srate, max_rate;
+
+    vap = ni->ni_vap;
+    if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+        printk(": DDRS: Local and Remote Chainmask %d %d \n", ieee80211com_get_tx_chainmask(ic), ni->kwn_remote_tx_chainmask );
+    }
+    switch( ni->kwn_remote_tx_chainmask ) {
+        case KWN_CHAINMASK_A1:
+            {
+                r_min_snr = ni->kwn_snr_avg.remote_snr_avg[0];
+                r_max_snr = ni->kwn_snr_avg.remote_snr_avg[0];
+                break;
+            }
+        case KWN_CHAINMASK_A2:
+            {
+                r_min_snr = ni->kwn_snr_avg.remote_snr_avg[1];
+                r_max_snr = ni->kwn_snr_avg.remote_snr_avg[1];
+                break;
+            }
+        case KWN_CHAINMASK_A1A2:
+            {
+                r_min_snr = min( ni->kwn_snr_avg.remote_snr_avg[0], ni->kwn_snr_avg.remote_snr_avg[1] );
+                r_max_snr = max( ni->kwn_snr_avg.remote_snr_avg[0], ni->kwn_snr_avg.remote_snr_avg[1] );
+                break;
+            }
+    }
+    switch( ieee80211com_get_tx_chainmask(ic) ) {
+        case KWN_CHAINMASK_A1:
+            {
+                l_min_snr = ni->kwn_snr_avg.local_snr_avg[0];
+                l_max_snr = ni->kwn_snr_avg.local_snr_avg[0];
+                break;
+            }
+        case KWN_CHAINMASK_A2:
+            {
+                l_min_snr = ni->kwn_snr_avg.local_snr_avg[1];
+                l_max_snr = ni->kwn_snr_avg.local_snr_avg[1];
+                break;
+            }
+        case KWN_CHAINMASK_A1A2:
+            {
+                l_min_snr = min( ni->kwn_snr_avg.local_snr_avg[0], ni->kwn_snr_avg.local_snr_avg[1] );
+                l_max_snr = max( ni->kwn_snr_avg.local_snr_avg[0], ni->kwn_snr_avg.local_snr_avg[1] );
+                break;
+            }
+    }
+
+    kwn_get_maxrate( vap, &max_srate, &max_rate );
+    if( mcs <= max_srate )
+        stream = KWN_STREAM_SINGLE;
+    else
+        stream = KWN_STREAM_DUAL;
+    /* Dual Stream: Consider minimum of SNR at two ports */
+    if( stream == KWN_STREAM_DUAL ) {
+        return min(r_min_snr, l_min_snr);
+    }
+    /* Single Stream: Consider maximum of SNR at two ports */
+    return r_max_snr;
+}
+
+int8_t kwn_get_next_auto_mcs_indx( struct ieee80211vap *vap, uint8_t curr_mcs, uint8_t inc )
+{
+    int8_t next_mcs = -1;
+
+    switch( wlan_get_current_phymode(vap) )
+    {
+        case IEEE80211_MODE_11A:
+        case IEEE80211_MODE_TURBO_A:
+            {
+                break;
+            }
+        case IEEE80211_MODE_11NA_HT20:
+        case IEEE80211_MODE_11NA_HT40PLUS:
+        case IEEE80211_MODE_11NA_HT40MINUS:
+        case IEEE80211_MODE_11NA_HT40:
+            {
+                if( inc )
+                    next_mcs = auto_indx.na_inc_indx[ curr_mcs ];
+                else
+                    next_mcs = auto_indx.na_dec_indx[ curr_mcs ];
+                break;
+            }
+        case IEEE80211_MODE_11AC_VHT20:
+        case IEEE80211_MODE_11AC_VHT40PLUS:
+        case IEEE80211_MODE_11AC_VHT40MINUS:
+        case IEEE80211_MODE_11AC_VHT40:
+        case IEEE80211_MODE_11AC_VHT80:
+        case IEEE80211_MODE_11AC_VHT160:
+        case IEEE80211_MODE_11AC_VHT80_80:
+            {
+                if( inc )
+                    next_mcs = auto_indx.ac_inc_indx[ curr_mcs ];
+                else
+                    next_mcs = auto_indx.ac_dec_indx[ curr_mcs ];
+                break;
+            }
+        default:
+            break;
+    }
+    return next_mcs;
+}
+
+int kwn_check_snr_to_inc_mcs( struct ieee80211_node *ni, uint8_t curr_mcs )
+{
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    uint8_t remote_snr, tpc_delta, req_min_snr;
+    int8_t next_mcs = curr_mcs + 1;
+
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+
+    if( ni->kwn_profile_cfg.txparam.spatial_stream == KWN_STREAM_AUTO ) {
+        next_mcs = kwn_get_next_auto_mcs_indx( vap, curr_mcs, 1 );
+    }
+    if( next_mcs == -1 || next_mcs > ni->kwn_profile_cfg.txparam.max_rate ) {
+        return -1;
+    }
+    remote_snr = kwn_get_remote_snr( ic, ni, next_mcs );
+    if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+        printk(": DDRS: Remote SNR %d at next MCS\n",remote_snr);
+    }
+    tpc_delta = kwn_get_radio_power( vap, curr_mcs ) - kwn_get_radio_power( vap, next_mcs );
+    req_min_snr = kwn_get_min_snr( vap, next_mcs ) + tpc_delta + ni->kwn_profile_cfg.txparam.rate_incr_thrld;
+    /* Remote SNR should be greater than the min SNR expected to be at respective data rate for good performance */
+    if( remote_snr > req_min_snr ) {
+        return 0;
+    }
+    return -1;
+}
+
+int kwn_check_snr_at_mcs( struct ieee80211_node *ni, uint8_t mcs )
+{
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    uint8_t remote_snr;
+
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+
+    remote_snr = kwn_get_remote_snr( ic, ni, mcs );
+    if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+        printk(": DDRS: Remote SNR %d at current MCS\n",remote_snr);
+    }
+
+    /* Remote SNR should be greater than the min SNR expected to be at respective data rate for good performance */
+    if( remote_snr > kwn_get_min_snr( vap, mcs ) ) {
+        return 0;
+    }
+    return -1;
+}
+
+void kwn_ddrs_check_timer( struct ieee80211_node *ni, u_int8_t *inc, u_int8_t *dec )
+{
+    struct ieee80211vap *vap;
+    u_int8_t curr_action = ( *inc == 1 ? KWN_DDRS_RATE_INC : KWN_DDRS_RATE_DEC );
+    u_int64_t curr_jiffies = jiffies;
+    u_int8_t inc_timer = ni->kwn_profile_cfg.txparam.inc_timer;
+    u_int8_t dec_timer = ni->kwn_profile_cfg.txparam.dec_timer;
+    u_int64_t last_jiffies =  ni->kwn_profile_cfg.ddrs_last_jiffies;
+    u_int8_t last_action = ni->kwn_profile_cfg.ddrs_last_action;
+    unsigned long diff = curr_jiffies - last_jiffies;
+
+    if( last_jiffies == 0 ) {
+        ni->kwn_profile_cfg.txparam.curr_inc_timer = ni->kwn_profile_cfg.txparam.inc_timer;
+        return;
+    }
+
+    vap = ni->ni_vap;
+    inc_timer = ni->kwn_profile_cfg.txparam.curr_inc_timer;
+    *inc = 0;
+    *dec = 0;
+
+    switch( last_action ) {
+        case KWN_DDRS_RATE_INC:
+            {
+                switch( curr_action ) {
+                    case KWN_DDRS_RATE_INC:
+                        {
+                            /* Incr-Incr: Check Rate Inc Timer expired */
+                            if( ( diff / 1000 ) > inc_timer )
+                            {
+                                if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+                                    printk(": DDRS: Incr Timer %d expired. Diff %lu\n",inc_timer, diff);
+                                }
+                                *inc = 1;
+                            }
+                            break;
+                        }
+                    case KWN_DDRS_RATE_DEC:
+                        {
+                            /* Incr-Decr: Decrement Immediately */
+                            *dec = 1;
+                        }
+                        break;
+                    default:
+                        break;
+                }
+            }
+            break;
+        case KWN_DDRS_RATE_DEC:
+            {
+                switch( curr_action ) {
+                    case KWN_DDRS_RATE_INC:
+                        {
+                            /* Decr-Incr: Check Rate Inc Timer expired */
+                            if( ( diff / 1000 ) > inc_timer )
+                            {
+                                if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+                                    printk(": DDRS: Incr Timer %d expired. Diff %lu\n",inc_timer,diff);
+                                }
+                                *inc = 1;
+                            }
+                            break;
+                        }
+                    case KWN_DDRS_RATE_DEC:
+                        {
+                            /* Decr-Decr: Check Rate dec Timer expired */
+                            if( ( diff / 1000 ) > dec_timer )
+                            {
+                                if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+                                    printk(": DDRS: Decr Timer %d expired. Diff %lu\n",dec_timer,diff);
+                                }
+                                *dec = 1;
+                            }
+                            break;
+                        }
+                    default:
+                        break;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    return;
+}
+
+void kwn_ddrs_rate_increment( struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap;
+    uint8_t max_srate, max_rate;
+    int8_t next_mcs = ni->kwn_profile_cfg.curr_rate + 1;
+
+    vap = ni->ni_vap;
+    if( ni->kwn_profile_cfg.txparam.spatial_stream == KWN_STREAM_AUTO ) {
+        next_mcs = kwn_get_next_auto_mcs_indx( vap, ni->kwn_profile_cfg.curr_rate, 1 );
+    }
+    kwn_get_maxrate( vap, &max_srate, &max_rate );
+    if( next_mcs == -1 || next_mcs > max_rate || next_mcs > ni->kwn_profile_cfg.txparam.max_rate ) {
+        return;
+    }
+    switch( ni->kwn_profile_cfg.ddrs_last_action ) {
+        case KWN_DDRS_RATE_DEC:
+            {
+                ni->kwn_profile_cfg.txparam.curr_inc_timer = ni->kwn_profile_cfg.txparam.curr_inc_timer * 2;
+                if( ni->kwn_profile_cfg.txparam.curr_inc_timer > ni->kwn_profile_cfg.txparam.backoff_int )
+                {
+                    ni->kwn_profile_cfg.txparam.curr_inc_timer = ni->kwn_profile_cfg.txparam.backoff_int;
+                }
+            }
+            break;
+        case KWN_DDRS_RATE_INC:
+        default:
+            ni->kwn_profile_cfg.txparam.curr_inc_timer = ni->kwn_profile_cfg.txparam.inc_timer;
+            break;
+    }
+    ni->kwn_profile_cfg.curr_rate = next_mcs;
+    ni->kwn_profile_cfg.ddrs_last_action = KWN_DDRS_RATE_INC;
+    ni->kwn_profile_cfg.ddrs_last_jiffies = jiffies;
+}
+
+void kwn_ddrs_rate_decrement( struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap;
+    int8_t next_mcs = ni->kwn_profile_cfg.curr_rate - 1;
+
+    vap = ni->ni_vap;
+    if( ni->kwn_profile_cfg.txparam.spatial_stream == KWN_STREAM_AUTO ) {
+        next_mcs = kwn_get_next_auto_mcs_indx( vap, ni->kwn_profile_cfg.curr_rate, 0 );
+    }
+    if( next_mcs == -1 || next_mcs < KWN_RATE_MIN || next_mcs < ni->kwn_profile_cfg.txparam.min_rate ) {
+        return;
+    }
+    ni->kwn_profile_cfg.curr_rate = next_mcs;
+    ni->kwn_profile_cfg.ddrs_last_action = KWN_DDRS_RATE_DEC;
+    ni->kwn_profile_cfg.ddrs_last_jiffies = jiffies;
+}
+
+u_int8_t kwn_check_rtx( struct ieee80211_node *ni )
+{
+    struct ieee80211vap *vap;
+    uint8_t rtx_val = KWN_RTX_SAME;
+
+    vap = ni->ni_vap;
+    if( ni->kwn_profile_cfg.txparam.rtx_inc_thrld >= ni->kwn_profile_cfg.txparam.rtx_dec_thrld )
+    {
+        printk(": DDRS: RTX Incr Threshold should be less than RTX Decr Threshold\n");
+        return rtx_val;
+    }
+    if( ni->kwn_send_retry == 1 ) {
+        if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+            printk(": DDRS: New RTX is increased\n");
+        }
+        ni->kwn_send_retry = 0;
+        rtx_val = KWN_RTX_DECREMENT;
+    }
+    else {
+        if( ni->kwn_local_rtx > ni->kwn_profile_cfg.txparam.rtx_dec_thrld ) {
+            rtx_val = KWN_RTX_DECREMENT;
+        }
+        else if( ni->kwn_local_rtx < ni->kwn_profile_cfg.txparam.rtx_inc_thrld ) {
+            rtx_val = KWN_RTX_INCREMENT;
+        }
+    }
+    return rtx_val;
+}
+
+OS_TIMER_FUNC( kwn_node_ddrs_timer_func )
+{
+    struct ieee80211_node *ni;
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    u_int8_t inc = 0, dec = 0, apply_rate, rtx_val = 0, rtx_inc = 0, rtx_dec = 0, snr_inc = 0, snr_dec = 0;
+    u_int8_t max_rate = 0, max_srate = 0;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    if( ni == NULL )
+    {
+        printk(": DDRS: ni pointer is NULL\n");
+        return;
+    }
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+    if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+        printk(": DDRS: Min %d Max %d Cur %d ",ni->kwn_profile_cfg.txparam.min_rate, ni->kwn_profile_cfg.txparam.max_rate, ni->kwn_profile_cfg.curr_rate);
+        printk(": DDRS: Local SNR A1:%d A2:%d Remote SNR A1:%d A2:%d Rate %d\n",ni->kwn_snr_avg.local_snr_avg[0],ni->kwn_snr_avg.local_snr_avg[1],
+                ni->kwn_snr_avg.remote_snr_avg[0],ni->kwn_snr_avg.remote_snr_avg[1],ni->kwn_txrate);
+    }
+    /* Spatial stream should be changed to Single if 1*1 chain at any end */
+    if( ni->kwn_remote_tx_chainmask != 0 ) {
+        if( ( ieee80211com_get_tx_chainmask( ic ) != KWN_CHAINMASK_A1A2 || 
+                    ni->kwn_remote_tx_chainmask != KWN_CHAINMASK_A1A2 ) && 
+                ( ni->kwn_profile_cfg.txparam.spatial_stream != KWN_STREAM_SINGLE ) ) {
+            printk(": DDRS: Changed Spatial stream to Single Stream. Local Chainmask %d Remote Chainmask %d \n",
+                    ieee80211com_get_tx_chainmask( ic ), ni->kwn_remote_tx_chainmask);
+            ni->kwn_profile_cfg.txparam.spatial_stream = KWN_STREAM_SINGLE;
+            kwn_get_maxrate( vap, &max_srate, &max_rate );
+            ni->kwn_profile_cfg.txparam.min_rate = 0;
+            ni->kwn_profile_cfg.txparam.max_rate = max_srate;
+        }
+    }
+    /* Spatial stream should be changed to Single if remote stream is not Single stream */
+    if( ni->kwn_remote_stream == KWN_STREAM_SINGLE && 
+            ni->kwn_profile_cfg.txparam.spatial_stream != KWN_STREAM_SINGLE ) {
+            printk(": DDRS: Changed Spatial stream to Single Stream. Local Stream %d Remote Stream %d \n",
+                    ni->kwn_profile_cfg.txparam.spatial_stream, ni->kwn_remote_stream);
+            ni->kwn_profile_cfg.txparam.spatial_stream = KWN_STREAM_SINGLE;
+            kwn_get_maxrate( vap, &max_srate, &max_rate );
+            ni->kwn_profile_cfg.txparam.min_rate = 0;
+            ni->kwn_profile_cfg.txparam.max_rate = max_srate;
+    }
+    if( ni->kwn_profile_cfg.txparam.min_rate > ni->kwn_profile_cfg.txparam.max_rate ) {
+        if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+            printk(": DDRS: Min Rate is greater than Max Rate\n");
+        }
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+    /* Fixed Rate or First rate */
+    if( ni->kwn_profile_cfg.txparam.min_rate == ni->kwn_profile_cfg.txparam.max_rate || 
+            ni->kwn_profile_cfg.curr_rate == -1 ) {
+        /* If Rate is already Set then don't trigger the DDRS Timer again */      
+        if ( ni->kwn_profile_cfg.curr_rate == ni->kwn_profile_cfg.txparam.min_rate ) {
+          return;
+        }
+        ni->kwn_profile_cfg.curr_rate = ni->kwn_profile_cfg.txparam.min_rate;
+        //if( ni->kwn_txrate != ni->kwn_profile_cfg.txparam.min_rate ) 
+        {
+            if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+                printk(": DDRS: Fixed Rate or First Rate applied %d \n", ni->kwn_txrate);
+            }
+            ieee80211_apply_txparams( vap, ni, -1, ni->kwn_profile_cfg.txparam.min_rate, -1 );
+        }
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+
+    if( ni->kwn_profile_cfg.curr_rate < ni->kwn_profile_cfg.txparam.min_rate || 
+            ni->kwn_profile_cfg.curr_rate > ni->kwn_profile_cfg.txparam.max_rate ) {
+        ni->kwn_profile_cfg.curr_rate = -1;
+        if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+            printk(": DDRS: Resetting algorithm....Start from min rate \n");
+        }
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+
+    rtx_val = kwn_check_rtx( ni );
+
+    switch( rtx_val ) {
+        case KWN_RTX_INCREMENT:
+            rtx_inc = 1;
+            break;
+        case KWN_RTX_DECREMENT:
+            rtx_dec = 1;
+            break;
+        case KWN_RTX_SAME:
+            break;
+    }
+
+    if( kwn_check_snr_at_mcs( ni, ni->kwn_profile_cfg.curr_rate ) == 0 ) {
+        if( kwn_check_snr_to_inc_mcs( ni, ni->kwn_profile_cfg.curr_rate ) == 0 ) {
+            snr_inc = 1;
+        }
+    }
+    else {
+        snr_dec = 1;
+    }
+    if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+        printk(": DDRS: RTX Inc %d dec %d,  SNR Inc %d Dec %d\n",rtx_inc,rtx_dec,snr_inc,snr_dec);
+    }
+    if( rtx_inc == 1 && snr_inc == 1 ) {
+        inc = 1;
+    }
+    else if( rtx_dec == 1 || snr_dec == 1 ) {
+        dec = 1;
+    }
+    else {
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+        return;
+    }
+
+    if( inc == 1 || dec == 1 ) {
+        kwn_ddrs_check_timer( ni, &inc, &dec );
+        if( inc == 1 ) {
+            kwn_ddrs_rate_increment( ni );
+        }
+        if( dec == 1 ) {
+            kwn_ddrs_rate_decrement( ni );
+        }
+    }
+
+    apply_rate = ni->kwn_profile_cfg.curr_rate;
+    if( ni->kwn_txrate != apply_rate ) 
+    {
+       ni->kwn_profile_cfg.atpc_power = -1;
+    }
+    {
+        if( vap->kwn_debug == KWN_DEBUG_DDRS ) {
+            printk(": DDRS: Rate applied from %d to %d \n",ni->kwn_txrate, apply_rate);
+        }
+        ieee80211_apply_txparams( vap, ni, -1, apply_rate, -1 );
+    }
+    OS_SET_TIMER( &ni->kwn_ddrs_timer, KWN_DDRS_TIMER_INT );
+}
+
+OS_TIMER_FUNC( kwn_node_snr_timer_func )
+{
+    struct ieee80211_node *ni;
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    u_int8_t i, j, cnt;
+    u_int32_t total;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    if( ni == NULL )
+    {
+        printk(": SNR: ni pointer is NULL\n");
+        return;
+    }
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+
+    ic->ic_kwn_get_ol_stats( vap, ic );
+    if( ni->kwn_snr_avg.snr_indx >= KWN_SNR_SAMPLES_MAX )
+        ni->kwn_snr_avg.snr_indx = 0;
+    if( ni->kwn_snr_avg.sample_count < KWN_SNR_SAMPLES_MAX )
+        ni->kwn_snr_avg.sample_count++;
+    if (vap->iv_opmode == IEEE80211_M_HOSTAP) {
+        ni->kwn_snr_avg.local_snr[0][ni->kwn_snr_avg.snr_indx] = ni->ni_stats.ns_rssi_chain[0];
+        ni->kwn_snr_avg.local_snr[1][ni->kwn_snr_avg.snr_indx] = ni->ni_stats.ns_rssi_chain[1];
+    }
+    else {
+        ni->kwn_snr_avg.local_snr[0][ni->kwn_snr_avg.snr_indx] = vap->kwn_local_snr_a1;
+        ni->kwn_snr_avg.local_snr[1][ni->kwn_snr_avg.snr_indx] = vap->kwn_local_snr_a2;
+    }
+    ni->kwn_snr_avg.snr_indx++;
+    if( vap->kwn_debug == KWN_DEBUG_SNR ) {
+        printk(": SNR Avg: Sample Count %d SNR index %d \n", ni->kwn_snr_avg.sample_count, ni->kwn_snr_avg.snr_indx);
+    }
+    if( ni->kwn_snr_avg.sample_count > 0 ) {
+        for( i = 0; i < IEEE80211_MAX_ANTENNA; i++ ) {
+            total = 0;
+            cnt = 0;
+            for( j = 0; j < ni->kwn_snr_avg.sample_count; j++ ) {
+                if( vap->kwn_debug == KWN_DEBUG_SNR ) {
+                    printk("%d ",ni->kwn_snr_avg.local_snr[i][j]);
+                }
+                if( ni->kwn_snr_avg.local_snr[i][j] > 0 && ni->kwn_snr_avg.local_snr[i][j] < 127 ) {
+                    total += ni->kwn_snr_avg.local_snr[i][j];
+                    cnt++;
+                }
+            }
+            ni->kwn_snr_avg.local_snr_avg[i] = ( total > 0 ? ( total / cnt ) : 0 );
+            if( vap->kwn_debug == KWN_DEBUG_SNR ) {
+                printk("\n: SNR Avg: Avg SNR %d at chain %d \n",ni->kwn_snr_avg.local_snr_avg[i],i);
+            }
+        }
+    }
+    if( vap->kwn_debug == KWN_DEBUG_SNR ) {
+        printk(": SNR Avg: Local %d %d Remote %d %d \n",ni->kwn_snr_avg.local_snr_avg[0],ni->kwn_snr_avg.local_snr_avg[1],
+                ni->kwn_snr_avg.remote_snr_avg[0],ni->kwn_snr_avg.remote_snr_avg[1]);
+    }
+
+    OS_SET_TIMER( &ni->kwn_snr_timer, KWN_SNR_TIMER_INT );
+}
+
+OS_TIMER_FUNC( kwn_node_atpc_timer_func )
+{
+    struct ieee80211_node *ni;
+    struct ieee80211vap *vap;
+    struct ieee80211com *ic;
+    uint8_t max_srate, max_rate, min_snr, remote_snr;
+    uint8_t apply_power, radio_power, max_power;
+    int8_t actual_snr;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    if( ni == NULL )
+    {
+        printk(": ATPC: ni pointer is NULL");
+        return;
+    }
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+    if( ni->kwn_profile_cfg.txparam.atpc_status != 1 ) {
+        if( vap->kwn_debug == KWN_DEBUG_ATPC ) {
+            printk(": ATPC: Fixed power applied %d \n",ni->kwn_profile_cfg.txparam.power);
+        }
+        ieee80211_apply_txparams( vap, ni, -1, -1, ni->kwn_profile_cfg.txparam.power );
+        /* In Fixed Power Scenario, is it required to triggerd ATPC Timer again ??? */
+        //OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+        return;
+    }
+    /* Set initial power */
+    if( ni->kwn_profile_cfg.atpc_power == -1 ) {
+        if( ni->kwn_profile_cfg.txparam.max_eirp == 0 ) {
+            ni->kwn_profile_cfg.txparam.max_eirp = 100;
+        }
+        radio_power = kwn_get_radio_power( vap, ni->kwn_txrate );
+        max_power = ni->kwn_profile_cfg.txparam.max_eirp - vap->kwn_antenna_gain;
+        ni->kwn_profile_cfg.actual_power = max_power;
+        if( max_power > radio_power ) {
+            ni->kwn_profile_cfg.actual_power = radio_power;
+        }
+        apply_power = ni->kwn_profile_cfg.actual_power;
+        if( vap->kwn_debug == KWN_DEBUG_ATPC ) {
+            printk(": ATPC: Initial Power applied %d \n",apply_power);
+        }
+    }
+    else {
+        kwn_get_maxrate( vap, &max_srate, &max_rate );
+        remote_snr = kwn_get_remote_snr( ic, ni, ni->kwn_profile_cfg.curr_rate );
+        actual_snr = kwn_get_max_snr( vap, ni->kwn_txrate ) - KWN_ATPC_LOWER_MARGIN;
+        if( vap->kwn_debug == KWN_DEBUG_ATPC ) {
+            printk(": ATPC: Remote SNR %d Actual SNR %d \n",remote_snr, actual_snr);
+        }
+        if( remote_snr < actual_snr ) {
+            apply_power = ni->kwn_profile_cfg.atpc_power + 1;
+            apply_power = min( apply_power, ni->kwn_profile_cfg.actual_power );
+        }
+        else if( remote_snr > actual_snr ) {
+            min_snr = kwn_get_min_snr( vap, ni->kwn_txrate );
+            if( ni->remote_snr_a1 > ( min_snr + 1 ) && 
+                    ni->remote_snr_a2 > ( min_snr + 1 ) ) {
+                apply_power = max( ni->kwn_profile_cfg.atpc_power - 1, 0 );
+            }
+            else {
+                OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+                return;
+            }
+        }
+        else {
+            OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+            return;
+        }
+    }
+
+    if( vap->kwn_debug == KWN_DEBUG_ATPC ) {
+        printk(": ATPC: Power applied from %d to %d \n",ni->kwn_profile_cfg.atpc_power,apply_power);
+    }
+    ni->kwn_profile_cfg.atpc_power = apply_power;
+    ieee80211_apply_txparams( vap, ni, -1, -1, apply_power );
+    OS_SET_TIMER( &ni->kwn_atpc_timer, KWN_ATPC_TIMER_INT );
+}
+
+static OS_TIMER_FUNC( kwn_node_stats_timer_func )
+{
+    struct ieee80211_node *ni;
+    wlan_dev_t ic;
+    wlan_if_t vap;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    if( ni == NULL )
+    {
+        printk(": STATS: ni pointer is NULL");
+        return;
+    }
+    vap = ni->ni_vap;
+    ic = vap->iv_ic;
+
+    ieee80211_send_node_stats( vap, ni );
+
+    /* Calculation of RTX Percentage */
+    if( ni->kwn_last_tx_pkts == 0 ) {
+        ni->kwn_last_tx_pkts = ni->ni_stats.ns_tx_data;
+        ni->kwn_last_retries = ni->kwn_local_retries;
+    }
+    else {
+        uint32_t tx, rtx;
+        uint8_t rtx_per = 0;
+        tx = ni->ni_stats.ns_tx_data - ni->kwn_last_tx_pkts;
+        rtx = ni->kwn_local_retries - ni->kwn_last_retries;
+        if( tx > 8 && tx > rtx ) {
+            rtx_per = ( u_int8_t ) ( ( rtx * 100 ) / tx );
+        }
+        //printk("Tx %u rtx %u Local rtx_per %d \n",tx,rtx,rtx_per);
+        ni->kwn_last_tx_pkts = ni->ni_stats.ns_tx_data;
+        ni->kwn_last_retries = ni->kwn_local_retries;
+        ni->kwn_local_rtx = rtx_per;
+    }
+
+    OS_SET_TIMER( &ni->kwn_stats_timer, KWN_STATS_TIMER_INT );
+}
+
+static OS_TIMER_FUNC( kwn_node_link_timer_func )
+{
+    struct ieee80211_node *ni;
+    wlan_if_t vap;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    if( ni == NULL )
+    {
+        printk(": STATS: ni pointer is NULL\n");
+        return;
+    }
+    vap = ni->ni_vap;
+    /* Send the link param values to Base */
+    ieee80211_send_link_params( vap, vap->iv_bss );
+  
+    OS_SET_TIMER( &ni->kwn_link_timer, KWN_LINKPARAM_TIMER_INT );
+}
+
+static OS_TIMER_FUNC( kwn_node_tput_tx_uplink )
+{
+    struct ieee80211_node *ni;
+    wlan_if_t vap;
+	int pkt_per_ms, pkt_size;
+	struct ether_header *eth;
+	struct net_device *dev;
+
+    OS_GET_TIMER_ARG( ni, struct ieee80211_node * );
+    if( ni == NULL )
+    {
+        printk(": STATS: ni pointer is NULL\n");
+        return;
+    }
+    vap = ni->ni_vap;
+	pkt_per_ms = vap->kwn_tput_test_pkt_per_ms;
+  	pkt_size = vap->kwn_tput_test_pkt_size;
+
+	if ( (dev = dev_get_by_name( &init_net, vap->iv_netdev_name )) == NULL )
+		return;
+   
+    /* Calculate packet count per ms */
+	for ( ; pkt_per_ms > 0; --pkt_per_ms )
+	{
+        struct sk_buff *skb = NULL;
+		/* Create a packet */
+		skb = dev_alloc_skb ( pkt_size + 64 );
+        if ( skb == NULL ) {
+            dev_put( dev );	
+            return;
+        }
+		/* Fill the skb content */
+		skb_reserve( skb, 64 );
+		skb_put( skb, pkt_size );
+		skb->dev = dev;
+		eth = (struct ether_header *)skb->data;
+        IEEE80211_ADDR_COPY( eth->ether_shost, vap->iv_myaddr );
+        if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            IEEE80211_ADDR_COPY( eth->ether_dhost, ni->ni_macaddr );
+        }
+        else {
+            IEEE80211_ADDR_COPY( eth->ether_dhost, vap->iv_bss->ni_macaddr );
+        }
+		eth->ether_type = htons( skb->len - sizeof(*eth) );
+		memcpy(&skb->data[sizeof(*eth)], kwn_tput_test_dsap_ul, sizeof(kwn_tput_test_dsap_ul));
+        skb_reset_mac_header( skb );
+		dev_queue_xmit( skb );
+	}
+	dev_put( dev );	
+	return;
+}
+
 static struct ieee80211_node *
 node_alloc(struct ieee80211vap *vap, const u_int8_t *macaddr, bool tmpnode)
 {
@@ -168,7 +1165,7 @@
         return NULL;
     }
     OS_MEMZERO(ni, sizeof(struct ieee80211_node));
-
+ 
 #if IEEE80211_DEBUG_REFCNT
     ni->trace = (struct node_trace_all *)OS_MALLOC(ic->ic_osdev, sizeof(struct node_trace_all), GFP_KERNEL);
     if (ni->trace == NULL) {
@@ -266,6 +1263,33 @@
     ni->ni_disassoc_tx_xretry = 0;
     ni->ni_deauth_tx_xretry = 0;
 
+    ni->kwn_txrate = 0;
+    ni->kwn_rxrate = 0;
+    ni->kwn_profile_cfg.txparam.spatial_stream = KWN_STREAM_AUTO;
+    ni->kwn_profile_cfg.txparam.min_rate = 0;
+    ni->kwn_profile_cfg.txparam.max_rate = 0;
+    ni->kwn_profile_cfg.txparam.curr_inc_timer = 2;
+    ni->kwn_profile_cfg.txparam.inc_timer = 2;
+    ni->kwn_profile_cfg.txparam.dec_timer = 1;
+    ni->kwn_profile_cfg.txparam.backoff_int = KWN_DDRS_BACKOFF_INT;
+    ni->kwn_profile_cfg.txparam.rate_incr_thrld = 3;
+    ni->kwn_profile_cfg.txparam.rtx_inc_thrld = 10;
+    ni->kwn_profile_cfg.txparam.rtx_dec_thrld = 15;
+    ni->kwn_profile_cfg.txparam.atpc_status = 0;
+    ni->kwn_profile_cfg.txparam.power = 26;
+    ni->kwn_profile_cfg.txparam.max_eirp = 0;
+    ni->kwn_profile_cfg.curr_rate = -1;
+    ni->kwn_profile_cfg.atpc_power = -1;
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_stats_timer, kwn_node_stats_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_snr_timer, kwn_node_snr_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_ddrs_timer, kwn_node_ddrs_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_atpc_timer, kwn_node_atpc_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_link_timer, kwn_node_link_timer_func, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    OS_INIT_TIMER( ic->ic_osdev, &ni->kwn_txba_timer, kwn_node_tput_tx_uplink, ni, QDF_TIMER_TYPE_WAKE_APPS );
+    
+    /* KWN: TxQ Init */
+    printk(": Node INIT..............\n");
+    vap->iv_pkt_q_init( &ni->kwn_txq );
 
     ieee80211_ref_node(ni);     /* mark referenced */
 
@@ -442,6 +1466,11 @@
         }
     }
 #endif
+    /* KWN */
+    ni->kwn_txrate = 0;
+    ni->kwn_rxrate = 0;
+    ni->kwn_txpwr = 26;
+    ni->kwn_rxpwr = 26;
     ni->is_extender_client = 0;
 
     ieee80211node_clear_whc_rept_info(ni);
@@ -1970,11 +2999,22 @@
 #endif
 {
     struct ieee80211com *ic = ni->ni_ic;
+    struct ieee80211vap *vap = ni->ni_vap;
     struct ieee80211_node_table *nt = &ic->ic_sta;
     rwlock_state_t lock_state;
     bool node_reclaimed=false;
     OS_BEACON_DECLARE_AND_RESET_VAR(flags);
 
+    OS_FREE_TIMER( &ni->kwn_stats_timer );
+    OS_FREE_TIMER( &ni->kwn_snr_timer );
+    OS_FREE_TIMER( &ni->kwn_ddrs_timer );
+    OS_FREE_TIMER( &ni->kwn_atpc_timer );
+    OS_FREE_TIMER( &ni->kwn_link_timer );
+    OS_FREE_TIMER( &ni->kwn_txba_timer );
+    if( ni->kwn_tput_running ) {
+        OS_FREE_TIMER( &vap->kwn_tput_timer );
+        OS_FREE_TIMER( &vap->kwn_tput_timer_fr );
+    }
     IEEE80211_NOTE(ni->ni_vap, IEEE80211_MSG_ASSOC, ni,
                    "%s: 0x%x \n", __func__,ni);
     OS_BEACON_WRITE_LOCK(&nt->nt_nodelock, &lock_state, flags);
diff -urN qca-wifi-org/umac/base/ieee80211_ucfg.c qca-wifi-mod/umac/base/ieee80211_ucfg.c
--- qca-wifi-org/umac/base/ieee80211_ucfg.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_ucfg.c	2019-05-06 20:18:49.850834103 +0530
@@ -50,6 +50,64 @@
 #define HIGHEST_BASIC_RATE 24000
 #define THREE_HUNDRED_FIFTY_MBPS 350000
 
+/* KWN: Ethernet EDMA Routines */
+extern int edma_set_vid_bitmap(struct net_device *dev, int16_t vid, int16_t flags);
+extern int edma_clear_vid_bitmap(struct net_device *dev, int16_t vid);
+extern int edma_set_vlan_mode(struct net_device *dev, int8_t vlan_mode);
+extern int edma_set_allow_tagged_mgmt(struct net_device *dev, int8_t allow_tagged_mgmt);
+extern int edma_set_allow_untagged(struct net_device *dev, int8_t allow_untagged);
+extern int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all );
+extern int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType );
+extern uint64_t edma_get_tx_pkts( struct net_device *dev );
+extern uint64_t edma_get_tx_errors( struct net_device *dev );
+extern uint64_t edma_get_tx_bytes( struct net_device *dev );
+extern uint64_t edma_get_tx_thrpt( struct net_device *dev );
+extern uint64_t edma_get_rx_pkts( struct net_device *dev );
+extern uint64_t edma_get_rx_errors( struct net_device *dev );
+extern uint64_t edma_get_rx_bytes( struct net_device *dev );
+extern uint64_t edma_get_rx_thrpt( struct net_device *dev );
+extern int edma_get_mgmt_vlan_id( struct net_device *dev );
+extern int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id );
+extern int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id );
+extern int edma_set_suservice(struct net_device *dev, uint8_t suservice);
+extern int edma_set_sukbps(struct net_device *dev, uint32_t kbps);
+extern int edma_clear_eth_stats( struct net_device *dev );
+extern int edma_filtering_status(struct net_device *dev, uint8_t status);
+extern int edma_filtering_l2mcast(struct net_device *dev, uint8_t l2mcast);
+extern int edma_filtering_l3mcast(struct net_device *dev, uint8_t l3mcast);
+extern int edma_filtering_l2bcast(struct net_device *dev, uint8_t l2bcast);
+extern int edma_filtering_l3bcast(struct net_device *dev, uint8_t l3bcast);
+extern uint64_t edma_get_fil_tx_l2mcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_rx_l2mcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_tx_l3mcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_rx_l3mcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_tx_l2bcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_rx_l2bcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_tx_l3bcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_fil_rx_l3bcast_drpcnt( struct net_device *dev );
+extern uint64_t edma_get_tx_failure( struct net_device *dev );
+extern uint64_t edma_get_rx_failure( struct net_device *dev );
+extern uint64_t edma_get_rx_crc_errors( struct net_device *dev );
+extern uint64_t edma_get_rx_frame_oversize_errors( struct net_device *dev );
+extern uint64_t edma_get_rx_frame_overrun_errors( struct net_device *dev );
+extern uint64_t edma_get_tx_multicastpkt( struct net_device *dev );
+extern uint64_t edma_get_rx_multicastpkt( struct net_device *dev );
+extern uint64_t edma_get_tx_unicastpkt( struct net_device *dev );
+extern uint64_t edma_get_rx_unicastpkt( struct net_device *dev );
+extern uint16_t edma_get_kwn_reboot_time( struct net_device *dev );
+extern int edma_set_kwn_tput_pkt_per_ms( struct net_device *dev, uint32_t pkt_per_ms );
+extern int edma_set_kwn_tput_pkt_size( struct net_device *dev, uint32_t pkt_size );
+extern int edma_set_kwn_tput_duration( struct net_device *dev, uint32_t duration );
+extern int edma_set_kwn_tput_direction( struct net_device *dev, uint32_t direction );
+extern int edma_set_kwn_test_mac( struct net_device *dev, uint8_t *mac );
+extern int edma_set_kwn_tput_start( struct net_device *dev, uint32_t start );
+extern int edma_set_kwn_reboot( struct net_device *dev );
+extern int edma_set_kwn_reboot_time( struct net_device *dev, uint16_t time );
+extern uint64_t edma_get_kwn_tput_rxseq_failed_cnt( struct net_device *dev );
 extern int ol_ath_ucfg_get_user_postion(wlan_if_t vaphandle, u_int32_t aid);
 extern int ol_ath_ucfg_get_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
 extern int ol_ath_ucfg_reset_peer_mumimo_tx_count(wlan_if_t vaphandle, u_int32_t aid);
@@ -57,6 +115,7 @@
 static struct ieee80211_channel* checkchan(wlan_if_t vaphandle,
                                           int channel, int secChanOffset);
 extern int ieee80211_rate_is_valid_basic(struct ieee80211vap *, u_int32_t);
+extern void ieee80211_apply_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni, int16_t channel, int8_t rate, int8_t pwr );
 #if MESH_MODE_SUPPORT
 int ieee80211_add_localpeer(wlan_if_t vap, char *params);
 int ieee80211_authorise_local_peer(wlan_if_t vap, char *params);
@@ -951,6 +1010,11 @@
 #undef MAX_2G_OFF_CHANNEL
 }
 
+void disassoc_stations(void* arg, wlan_if_t vap)
+{                   
+    wlan_iterate_all_sta_list(vap, sta_disassoc, NULL);
+}
+
 #define IEEE80211_BINTVAL_IWMAX       3500   /* max beacon interval */
 #define IEEE80211_BINTVAL_IWMIN       40     /* min beacon interval */
 #define IEEE80211_BINTVAL_LP_IOT_IWMIN 25    /* min beacon interval for LP IOT */
@@ -985,6 +1049,7 @@
     int i;
 #endif
     uint32_t fils_en_period = 0;
+    struct ieee80211_node *ni;
 
     if (osifp->is_delete_in_progress)
         return -EINVAL;
@@ -2642,7 +2707,10 @@
     case IEEE80211_IOC_SCAN_FLUSH:
         IEEE80211_DPRINTF(vap, IEEE80211_MSG_IOCTL, "set %s\n",
                         "IEEE80211_IOC_SCAN_FLUSH");
-        wlan_scan_table_flush(vap);
+        /* Flush the entries only when user set */
+        if ( vap->kwn_flag == SCAN_ENTRY_FLUSH ) {
+            wlan_scan_table_flush(vap);
+        }
         retv = 0; /* success */
         break;
 
@@ -3974,7 +4042,736 @@
     case IEEE80211_PARAM_DFS_INFO_NOTIFY_APP:
         ic->ic_dfs_info_notify_channel_available = !!value;
         break;
+    case IEEE80211_PARAM_UPLINK_LIMIT:
+        vap->kwn_ul_limit = value;
+        break;
+    case IEEE80211_PARAM_DOWNLINK_LIMIT:
+        vap->kwn_dl_limit = value;
+        break;
+    case IEEE80211_PARAM_KWN_VLAN_MODE: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_vlan_mode(eth_dev, value);
+		printk(": Ethernet VLANMode: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_VID_ADD:
+	{
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_vid_bitmap(eth_dev, value, 0);
+		printk(": Set Vid: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_VID_DEL: 
+	{
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_clear_vid_bitmap(eth_dev, value);
+		printk(": Clear Vid: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_ALLOW_UNTAGGED: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		if ( value == 0 || value == 1 ) {
+			edma_set_allow_untagged(eth_dev, value);
+			edma_set_allow_all_tagged_trunk(eth_dev, 0);
+		}
+		else if ( value == 2 ) {
+			edma_set_allow_untagged(eth_dev, 0);
+			edma_set_allow_all_tagged_trunk(eth_dev, 1);
+		} else {
+			edma_set_allow_untagged(eth_dev, 0);
+			edma_set_allow_all_tagged_trunk(eth_dev, 0);
+		}
+		printk(": Allow Untagged: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_ACCESS_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_access_vlan_id(eth_dev, value);
+		printk(": Access VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_NATIVE_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_native_vlan_id(eth_dev, value);
+		printk(": Native VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_MGMT_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_mgmt_vlan_id(eth_dev, value);
+		vap->kwn_mgmt_vlan_id = value;
+		memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+		printk(": Mgmt VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_SVLAN_ID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_svlan_id(eth_dev, value);
+		printk(": SVlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_SVLAN_ETHERTYPE: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_svlan_etherType(eth_dev, value);
+		printk(": SVlan EtherType: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST: 
+    {
+        struct ieee80211_node *ni;
+        u_int32_t rate;
+
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_tput_test_mac);
+            if( ni == NULL ) {
+                printk("ni is NULL\n");
+                return -EINVAL;
+            }
+        }
+        else {
+            ni = vap->iv_bss;
+        }
+        if ( value ) {
+            ni->kwn_tput_running = 1;
+            vap->kwn_tput_test_start_time = jiffies;
+            rate = ni->ni_ic->ic_node_getrate(ni, IEEE80211_RATE_TX);
+
+            /* Calculate the Ms Timer */
+            vap->kwn_tput_test_ms_timer = 1;
+            if ( rate < 10000 ) {
+              vap->kwn_tput_test_ms_timer = 2;
+            }
+
+            /* Calculate the MaxPktSize & PktPerS */
+            rate = ( rate * 8 ) / 10;
+            /* Maximum PktsPerS */
+            vap->kwn_tput_test_max_pkt_per_s = (( rate * 1000 )/ ( 8 * vap->kwn_tput_test_pkt_size ));
+
+            /* Starting Max PktsPerS */
+            vap->kwn_tput_test_pkt_per_s = vap->kwn_tput_test_max_pkt_per_s / 8;
+            vap->kwn_tput_test_pkt_per_ms = (vap->kwn_tput_test_max_pkt_per_s / 1000);
+            vap->kwn_tput_test_pkt_per_ms = vap->kwn_tput_test_pkt_per_ms <= 0 ? 1 : vap->kwn_tput_test_pkt_per_ms;
+
+            if ( vap->kwn_tput_test_direction == 3 ) {
+                vap->kwn_tput_test_max_pkt_per_s /= 2;
+            }
+
+            /* Update LinkTest Flags */
+            vap->kwn_tput_test_user_started = 1;
+            vap->kwn_tput_test_in_progress = 1;
+            vap->kwn_tput_test_from_app = 1;
+            vap->kwn_tput_test_low_pktpers = 0;
+            vap->kwn_tput_test_up_pktpers = 0;
+            vap->kwn_tput_test_max_iter_cnt = (int32_t)( vap->kwn_tput_test_duration / ( 10 * 1000 ) );
+            vap->kwn_tput_test_curr_iter = -1;
+            vap->kwn_tput_test_duration = 10 * 1000;
+            /* Start the test from FrTimer */
+            OS_CANCEL_TIMER(&vap->kwn_tput_timer_fr);
+            OS_SET_TIMER(&vap->kwn_tput_timer_fr, 100);
+
+            printk(": TPUT: Link Test: Start ...\n");
+            printk(": TPUT: Max: Pkts: S: %d TotalIter: %d \n", vap->kwn_tput_test_max_pkt_per_s,vap->kwn_tput_test_max_iter_cnt);
+        } else {
+            printk(": TPUT: Stop Test...\n");
+            ni->kwn_tput_running = 0;
+            vap->kwn_tput_test_user_started = 0;
+            vap->kwn_tput_test_start_time = 0;
+            vap->kwn_tput_test_in_progress = 0;
+            if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 2 )
+                ieee80211_send_tput_test(vap, ni);
+            vap->kwn_tput_test_from_app = 0;
+            vap->kwn_tput_test_txseq = 0;
+            vap->kwn_tput_test_rxseq = 0;
+            vap->kwn_tput_test_rx_failed_cnt = 0;
+            vap->kwn_tput_test_max_iter_cnt = 0;
+            vap->kwn_tput_test_curr_iter = 0;
+        }
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            ieee80211_free_node( ni );
+        }
+    }
+	break;
 
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DUR:
+    {
+        if( value > KWN_TPUT_TEST_MAX_DURATION ) {
+            value = KWN_TPUT_TEST_MAX_DURATION;
+        }
+        vap->kwn_tput_test_duration = value * 1000;
+        //printk(": Test Duration: %d\n",vap->kwn_tput_test_duration);
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                edma_set_kwn_tput_duration(eth_dev, value * 1000);
+            }
+            dev_put(eth_dev);
+        }
+    }
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_PKT_PER_MS:
+	vap->kwn_tput_test_pkt_per_ms = value;
+	//printk(": Test PacketPerMs: %d\n",vap->kwn_tput_test_pkt_per_ms);
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            /* Compute PacketPerMs based on Input rate configured by user */
+            value = ( value * 1000 / ( 8 * vap->kwn_tput_test_pkt_size ) );
+            edma_set_kwn_tput_pkt_per_ms(eth_dev, value);
+        }
+        dev_put(eth_dev);
+    }
+	break;
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_PKT_SIZE:
+	vap->kwn_tput_test_pkt_size = value;
+	//printk(": Test PktSize: %d\n",vap->kwn_tput_test_pkt_size);
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_set_kwn_tput_pkt_size(eth_dev, value);
+        }
+        dev_put(eth_dev);
+    }
+	break;
+    
+    /* KWN Ethernet Test */
+    case IEEE80211_PARAM_KWN_TPUT_ETH_TEST:
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_set_kwn_tput_start(eth_dev, value);
+        }
+        dev_put(eth_dev);
+    }
+    break;
+
+
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DIR:
+	vap->kwn_tput_test_direction = value;
+	//printk(": Test Direction: %d\n",vap->kwn_tput_test_direction);
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_set_kwn_tput_direction(eth_dev, value);
+        }
+        dev_put(eth_dev);
+    }
+	break;
+
+    case IEEE80211_PARAM_KWN_SET_PBB_B_VLANID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_pbb_bvid(eth_dev, value);
+		printk(": PBB B VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_SET_PBB_B_ISID: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+		edma_set_pbb_isid(eth_dev, value);
+		printk(": PBB B VlanID: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+
+    case IEEE80211_PARAM_KWN_SET_FLAG: 
+	{
+		vap->kwn_flag = value;
+		break;
+	}
+    case IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET: 
+	{
+		vap->kwn_noise_floor_offset = value;
+		break;
+	}
+    case IEEE80211_PARAM_KWN_TX_RATE: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ieee80211_apply_txparams( vap, ni, -1, value, -1 );
+            ieee80211_free_node(ni);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_TX_PWR: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ieee80211_apply_txparams( vap, ni, -1, -1, value );
+            ieee80211_free_node(ni);
+        }
+		break;
+	}
+    case IEEE80211_PARAM_KWN_RX_RATE: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_rxrate = value;
+            ni->kwn_rxpwr = -1;
+            ni->kwn_rxchan = -1;
+            ieee80211_send_txparams( vap, ni );
+            ieee80211_free_node(ni);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_RX_PWR: 
+    {
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_rxrate = -1;
+            ni->kwn_rxpwr = value;
+            ni->kwn_rxchan = -1;
+            ieee80211_send_txparams( vap, ni );
+            ieee80211_free_node(ni);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SPATIAL_STREAM:
+    {
+        vap->kwn_txparam.spatial_stream = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_MIN_RATE:
+    {
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_profile_cfg.txparam.min_rate = value;
+            ieee80211_free_node(ni);
+        }
+#endif
+        vap->kwn_txparam.min_rate = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_MAX_RATE:
+    {
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            ni->kwn_profile_cfg.txparam.max_rate = value;
+            ieee80211_free_node(ni);
+        }
+#endif
+        vap->kwn_txparam.max_rate = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_INCR_TIMER:
+    {
+        vap->kwn_txparam.inc_timer = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_DECR_TIMER:
+    {
+        vap->kwn_txparam.dec_timer = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_RATE_INCR_THRLD:
+    {
+        vap->kwn_txparam.rate_incr_thrld = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ATPC_STATUS:
+    {
+        vap->kwn_txparam.atpc_status = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ATPC_POWER:
+    {
+        vap->kwn_txparam.power = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ANTENNA_GAIN:
+    {
+        vap->kwn_antenna_gain = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_START_SCAN:
+    {
+        struct ieee80211_channel *c;
+        u_int16_t start_freq = 0, end_freq = 0;
+        union iwreq_data wreq = {{0}};
+        struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+        if( value == 1 ) {
+            if( ic->enable_acs || ic->enable_sa_scan || ic->kwn_dcs.dcs_triggered ) {
+                printk(": SASCAN: ACS or SA or DCS is already in progress\n");
+                /* Send an event to apl as scanning in progress */
+                memset(&wreq, 0, sizeof(wreq));
+                wreq.addr.sa_family = ARPHRD_ETHER;
+                memcpy(wreq.addr.sa_data, vap->iv_bss, 6);
+                wreq.addr.sa_data[6] = IEEE80211_EV_SCAN_IN_PROGRESS;
+                wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+                dev_put(dev);
+                break;
+            }
+            if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                wlan_iterate_vap_list(ic, disassoc_stations, NULL);
+            }
+            ic->enable_sa_scan = 1;
+            memset( &ic->kwn_scan.sa_result, 0, sizeof( struct kwn_sa_scan_result ) );
+            ic->kwn_scan.scan_vap = vap;
+            for (i = 0; i < ic->ic_nchans; i++) {
+                struct ieee80211_channel *c;
+                u_int16_t freq = ic->ic_channels[i].ic_freq;
+
+                c = kwn_find_channel( ic, vap, freq );
+                if( c != NULL ) {
+                    if( start_freq == 0 )
+                        start_freq = c->ic_freq;
+                    else
+                        end_freq = c->ic_freq;
+                }
+            }
+            if( ic->kwn_scan.start_freq < start_freq || ic->kwn_scan.start_freq > end_freq )
+                ic->kwn_scan.start_freq = start_freq;
+            if( ic->kwn_scan.end_freq > end_freq || ic->kwn_scan.end_freq < start_freq )
+                ic->kwn_scan.end_freq = end_freq;
+            ic->kwn_scan.oper_freq = ic->ic_curchan->ic_freq;
+            ic->kwn_scan.scan_time = ic->kwn_scan.sa_scan_time;
+            ic->kwn_scan.start_scan = 1;
+            ic->kwn_scan.curr_freq = 0;
+            ic->kwn_scan.next_chan = 0;
+            OS_SET_TIMER(&ic->kwn_scan.scan_timer, 0);
+        }
+        else {
+            if( !ic->enable_sa_scan ) {
+                printk(": SASCAN: SA is already stopped\n");
+                dev_put(dev);
+                break;
+            }
+            printk(": SASCAN: SA is stopped manually\n");
+
+            /* Send an event to apl as SA Stopped */
+            memset(&wreq, 0, sizeof(wreq));
+            wreq.addr.sa_family = ARPHRD_ETHER;
+            memcpy(wreq.addr.sa_data, vap->iv_bss, 6);
+            wreq.addr.sa_data[6] = IEEE80211_EV_SA_STOP;
+            wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+
+            ic->enable_sa_scan = 0;
+            ic->kwn_scan.scan_vap = NULL;
+            ic->kwn_scan.start_scan = 0;
+            OS_CANCEL_TIMER(&ic->kwn_scan.util_timer);
+            OS_CANCEL_TIMER(&ic->kwn_scan.scan_timer);
+            printk(": SPECTRAL: Revert back to operating frequnecy %d \n",ic->kwn_scan.oper_freq);
+            c = kwn_find_channel(ic, vap, ic->kwn_scan.oper_freq );
+            ic->ic_prevchan = ic->ic_curchan;
+            ic->ic_curchan = c;
+            kwn_sa_set_channel( ic );
+        }
+        dev_put(dev);
+        break;
+    }
+    case IEEE80211_PARAM_KWN_START_FREQ:
+    {
+        ic->kwn_scan.start_freq = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_END_FREQ:
+    {
+        ic->kwn_scan.end_freq = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SA_SCAN_TIME:
+    {
+        ic->kwn_scan.sa_scan_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ACS_SCAN_TIME:
+    {
+        ic->kwn_scan.acs_scan_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_UTIL_TIME:
+    {
+        ic->kwn_scan.util_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_ALLOW_TAG_MGMT: {
+	struct net_device *eth_dev;
+	eth_dev = dev_get_by_name(&init_net, "eth0");
+	if(eth_dev) {
+        vap->kwn_allow_tagged_mgmt = value;
+		edma_set_allow_tagged_mgmt(eth_dev, value);
+		printk(": Allow Tagged Mgmt: %d\n",value); 
+	}
+	dev_put(eth_dev);
+	}
+	break;
+    case IEEE80211_PARAM_KWN_ASSEM_FRAG:
+    {
+        vap->kwn_assem_frag = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_MAX_PKT_SIZE:
+    {
+        vap->kwn_max_pkt_size = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FRAG_PKT_SIZE:
+    {
+        vap->kwn_frag_pkt_size = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_TRAFFIC_SHAPING:
+    {
+        vap->kwn_traffic_shaping = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DCS_STATUS:
+    {
+        ic->kwn_dcs.dcs_status = value;
+        ic->kwn_dcs.dcs_vap = NULL;
+        OS_FREE_TIMER( &ic->kwn_dcs.dcs_timer);
+        OS_FREE_TIMER( &ic->kwn_dcs.bl_timer);
+        if( value == 1 ) {
+            ic->kwn_dcs.dcs_vap = vap;
+            OS_SET_TIMER( &ic->kwn_rtx_timer, 0 );
+            OS_SET_TIMER( &ic->kwn_dcs.dcs_timer, ic->kwn_dcs.dcs_time * 1000 );
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DCS_THRLD:
+    {
+        ic->kwn_dcs.dcs_thrld = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DCS_TIME:
+    {
+        ic->kwn_dcs.dcs_time = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DCS_BL_INTERVAL:
+    {
+        ic->kwn_dcs.bl_int = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SU_SERVICE:
+    {
+        struct net_device *eth_dev;
+
+        eth_dev = dev_get_by_name( &init_net, "eth0" );
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            value = 1;
+        }
+        if( eth_dev ) {
+            vap->kwn_suservice = value;
+            edma_set_suservice( eth_dev, value );
+        }
+        dev_put( eth_dev );
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SU_KBPS:
+    {
+        struct net_device *eth_dev;
+
+        eth_dev = dev_get_by_name( &init_net, "eth0" );
+        if( eth_dev ) {
+            vap->kwn_su_kbps = value;
+            edma_set_sukbps( eth_dev, value );
+        }
+        dev_put( eth_dev );
+        break;
+    }
+    case IEEE80211_PARAM_KWN_CLEAR_ETH_STATS:
+    {
+        struct net_device *eth_dev;
+        if ( value == 1) {
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                edma_clear_eth_stats(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_RTX_INC_THRLD:
+    {
+        vap->kwn_txparam.rtx_inc_thrld = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_RTX_DEC_THRLD:
+    {
+        vap->kwn_txparam.rtx_dec_thrld = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FILTERING_STATUS:
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_filtering_status(eth_dev,value);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FILTERING_L2MCAST:
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_filtering_l2mcast(eth_dev,value);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FILTERING_L3MCAST:
+    {        
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_filtering_l3mcast(eth_dev,value);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FILTERING_L2BCAST:
+    {        
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_filtering_l2bcast(eth_dev,value);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_FILTERING_L3BCAST:
+    {        
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_filtering_l3bcast(eth_dev,value);
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_MAX_EIRP:
+    {
+        vap->kwn_txparam.max_eirp = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_SOFTRESET:
+    {
+        vap->kwn_softreset = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DDRS_BACKOFF_INT:
+    {
+        vap->kwn_txparam.backoff_int = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DEBUG:
+    {
+        vap->kwn_debug = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_MACINMAC:
+    {
+        ic->kwn_macinmac = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_LINKTYPE:
+    {
+        ic->kwn_linktype = value;
+        break;
+    }
+    case IEEE80211_PARAM_KWN_DISCONNECT_ALL:
+    {
+        if( value == 1 ) {
+            if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                printk("################ Disconnect all stations\n");
+                wlan_iterate_vap_list(ic, disassoc_stations, NULL);
+            }
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_TXBASETUP:
+    {
+        if( vap->iv_opmode == IEEE80211_M_STA ) {
+            struct ieee80211_node *ni;
+            ni = vap->iv_bss;
+            if( ni == NULL )
+                break;
+            if( value == 1 ) {
+                printk(": Started SU Test for TX BA Setup...\n");
+                ieee80211_send_txbasetup( vap, ni );
+                ieee80211_send_txbasetup( vap, ni );
+                ieee80211_send_txbasetup( vap, ni );
+                OS_SET_TIMER( &ni->kwn_txba_timer, 1000 );
+            }
+            else {
+                printk(": Stop UL/DL Tests if in progress...");
+                OS_CANCEL_TIMER( &ni->kwn_txba_timer );
+            }
+        }
+        break;
+    }
+    case IEEE80211_PARAM_KWN_REBOOT: 
+    {
+        if( value == 1 )
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                edma_set_kwn_reboot( eth_dev );
+            }
+            dev_put(eth_dev);
+        }
+    }
+	break;
+    case IEEE80211_PARAM_KWN_REBOOT_TIME: 
+    {
+        struct net_device *eth_dev;
+        eth_dev = dev_get_by_name(&init_net, "eth0");
+        if(eth_dev) {
+            edma_set_kwn_reboot_time( eth_dev, value );
+            printk(": Reboot Time: %d\n",value); 
+        }
+        dev_put(eth_dev);
+    }
+	break;
     }
 
     if (retv == ENETRESET)
@@ -4018,6 +4815,7 @@
     int *txpow_frm_subtype = value;
     u_int8_t frame_subtype;
     u_int8_t frame_type;
+    struct ieee80211_node *ni;
 #if ATH_SUPPORT_DFS
     int tmp;
 #endif
@@ -5586,6 +6384,487 @@
     case IEEE80211_PARAM_DFS_INFO_NOTIFY_APP:
         *value = ic->ic_dfs_info_notify_channel_available;
         break;
+    case IEEE80211_PARAM_UPLINK_LIMIT:
+        *value = vap->kwn_ul_limit;
+        break;
+    case IEEE80211_PARAM_DOWNLINK_LIMIT:
+        *value = vap->kwn_dl_limit;
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_PKTS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_pkts(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_BYTES:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_bytes(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_PKTS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_pkts(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_BYTES:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_bytes(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST: 
+        *value = vap->kwn_tput_test_in_progress;
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DUR: 
+        *value = vap->kwn_tput_test_duration / 1000;
+        break;
+    case IEEE80211_PARAM_KWN_TPUT_TEST_DIR: 
+        *value = vap->kwn_tput_test_direction;
+        break;
+    case IEEE80211_PARAM_KWN_NOISE_FLOOR_OFFSET: 
+        *value = vap->kwn_noise_floor_offset;
+        break;
+    case IEEE80211_PARAM_KWN_TX_RATE: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_txrate;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TX_PWR: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_txpwr;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_RX_RATE: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_rxrate;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_RX_PWR: 
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_rxpwr;
+            ieee80211_free_node(ni);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_SPATIAL_STREAM:
+        *value = vap->kwn_txparam.spatial_stream;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_MIN_RATE:
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_profile_cfg.txparam.min_rate;
+            ieee80211_free_node(ni);
+        }
+#endif
+        *value = vap->kwn_txparam.min_rate;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_MAX_RATE:
+#if 0
+        ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_rate_node_mac);
+        if( ni != NULL ) {
+            *value = ni->kwn_profile_cfg.txparam.max_rate;
+            ieee80211_free_node(ni);
+        }
+#endif
+        *value = vap->kwn_txparam.max_rate;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_INCR_TIMER:
+        *value = vap->kwn_txparam.inc_timer;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_DECR_TIMER:
+        *value = vap->kwn_txparam.dec_timer;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_RATE_INCR_THRLD:
+        *value = vap->kwn_txparam.rate_incr_thrld;
+        break;
+    case IEEE80211_PARAM_KWN_ATPC_STATUS:
+        *value = vap->kwn_txparam.atpc_status;
+        break;
+    case IEEE80211_PARAM_KWN_ATPC_POWER:
+        *value = vap->kwn_txparam.power;
+        break;
+    case IEEE80211_PARAM_KWN_ANTENNA_GAIN:
+        *value = vap->kwn_antenna_gain;
+        break;
+    case IEEE80211_PARAM_KWN_START_SCAN:
+        *value = ic->kwn_scan.start_scan;
+        break;
+    case IEEE80211_PARAM_KWN_START_FREQ:
+        *value = ic->kwn_scan.start_freq;
+        break;
+    case IEEE80211_PARAM_KWN_END_FREQ:
+        *value = ic->kwn_scan.end_freq;
+        break;
+    case IEEE80211_PARAM_KWN_SA_SCAN_TIME:
+        *value = ic->kwn_scan.sa_scan_time;
+        break;
+    case IEEE80211_PARAM_KWN_ACS_SCAN_TIME:
+        *value = ic->kwn_scan.acs_scan_time;
+        break;
+    case IEEE80211_PARAM_KWN_UTIL_TIME:
+        *value = ic->kwn_scan.util_time;
+        break;
+    case IEEE80211_PARAM_KWN_ASSEM_FRAG:
+        *value = vap->kwn_assem_frag;
+        break;
+    case IEEE80211_PARAM_KWN_MAX_PKT_SIZE:
+        *value = vap->kwn_max_pkt_size;
+        break;
+    case IEEE80211_PARAM_KWN_FRAG_PKT_SIZE:
+        *value = vap->kwn_frag_pkt_size;
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_THRPT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_thrpt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_THRPT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_thrpt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_WIFI_TX_THRPT:
+        {
+            struct ieee80211_stats *iv_stats;
+            iv_stats = wlan_get_stats(vap);
+            *value = iv_stats->kwn_tx_tput_mbps;
+        }
+        break;
+    case IEEE80211_PARAM_KWN_WIFI_RX_THRPT:
+        {
+            struct ieee80211_stats *iv_stats;
+            iv_stats = wlan_get_stats(vap);
+            *value = iv_stats->kwn_rx_tput_mbps;
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TRAFFIC_SHAPING:
+        *value = vap->kwn_traffic_shaping;
+        break;
+    case IEEE80211_PARAM_KWN_DCS_STATUS:
+        *value = ic->kwn_dcs.dcs_status;
+        break;
+    case IEEE80211_PARAM_KWN_DCS_THRLD:
+        *value = ic->kwn_dcs.dcs_thrld;
+        break;
+    case IEEE80211_PARAM_KWN_DCS_TIME:
+        *value = ic->kwn_dcs.dcs_time;
+        break;
+    case IEEE80211_PARAM_KWN_DCS_BL_INTERVAL:
+        *value = ic->kwn_dcs.bl_int;
+        break;
+    case IEEE80211_PARAM_KWN_SU_SERVICE:
+        *value = vap->kwn_suservice;
+        break;
+    case IEEE80211_PARAM_KWN_SU_KBPS:
+        *value = vap->kwn_su_kbps;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_RTX_INC_THRLD:
+        *value = vap->kwn_txparam.rtx_inc_thrld;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_RTX_DEC_THRLD:
+        *value = vap->kwn_txparam.rtx_dec_thrld;
+        break;
+    case IEEE80211_PARAM_KWN_FIL_TX_L2MCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_tx_l2mcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_RX_L2MCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_rx_l2mcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_TX_L3MCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_tx_l3mcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_RX_L3MCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_rx_l3mcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_TX_L2BCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_tx_l2bcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_RX_L2BCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_rx_l2bcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_TX_L3BCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_tx_l3bcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_FIL_RX_L3BCAST_DRPCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_fil_rx_l3bcast_drpcnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_MAX_EIRP:
+        *value = vap->kwn_txparam.max_eirp;
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_FAILURE:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_failure(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_FAILURE:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_failure(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_CRC_ERRORS:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_crc_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_FRAME_OVERSIZE:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_frame_oversize_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break; 
+    case IEEE80211_PARAM_KWN_ETH_RX_FRAME_OVERRUN:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_frame_overrun_errors(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_MULTICAST_PKT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_multicastpkt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_MULTICAST_PKT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_multicastpkt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_TX_UNICAST_PKT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_tx_unicastpkt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_ETH_RX_UNICAST_PKT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_rx_unicastpkt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+
+        /* KWN Ethernet Failed count */
+    case IEEE80211_PARAM_KWN_TPUT_RXSEQ_FCNT:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_kwn_tput_rxseq_failed_cnt(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_SOFTRESET:
+        *value = vap->kwn_softreset;
+        break;
+    case IEEE80211_PARAM_KWN_DDRS_BACKOFF_INT:
+        *value = vap->kwn_txparam.backoff_int;
+        break;
+    case IEEE80211_PARAM_KWN_DEBUG:
+        *value = vap->kwn_debug;
+        break;
+    case IEEE80211_PARAM_KWN_MACINMAC:
+        *value = ic->kwn_macinmac;
+        break;
+    case IEEE80211_PARAM_KWN_LINKTYPE:
+        *value = ic->kwn_linktype;
+        break;
+    case IEEE80211_PARAM_KWN_GET_SCAN_DIFF:
+        {
+            if( vap->iv_opmode == IEEE80211_M_STA ) {
+                u_int64_t curr_jiffies = jiffies;
+                unsigned long diff = curr_jiffies - vap->kwn_last_scan_time;
+                *value = ( u_int32_t ) ( diff / 1000 );
+            }
+            else {
+                *value = 0;
+            }
+        }
+        break;
+    case IEEE80211_PARAM_KWN_REBOOT_TIME:
+        {
+            struct net_device *eth_dev;
+            eth_dev = dev_get_by_name(&init_net, "eth0");
+            if(eth_dev) {
+                *value = edma_get_kwn_reboot_time(eth_dev);
+            }
+            dev_put(eth_dev);
+        }
+        break;
+    case IEEE80211_PARAM_KWN_MPDU_ERROR:
+        {
+            ic->ic_kwn_get_ol_stats( vap, ic );
+            *value = vap->kwn_local_mpdu_err;
+        }
+        break;
+    case IEEE80211_PARAM_KWN_PHY_ERROR:
+        {
+            ic->ic_kwn_get_ol_stats( vap, ic );
+            *value = vap->kwn_local_phy_err;
+        }
+        break;
+    case IEEE80211_PARAM_KWN_TX_MGMT:
+        {
+            ic->ic_kwn_get_ol_stats( vap, ic );
+            *value = vap->kwn_local_tx_mgmt;
+        }
+        break;
+    case IEEE80211_PARAM_KWN_RX_MGMT:
+        {
+            ic->ic_kwn_get_ol_stats( vap, ic );
+            *value = vap->kwn_local_rx_mgmt;
+        }
+        break;
     }
 
     if (retv) {
@@ -6582,12 +7861,15 @@
     wlan_chan_t chan = wlan_node_get_chan(node);
     ieee80211_rate_info rinfo;
     u_int32_t jiffies_now=0, jiffies_delta=0, jiffies_assoc=0;
+    struct ieee80211_stats *iv_stats;
+    struct ieee80211com *ic = vap->iv_ic;
     /* already ignore invalid nodes in UMAC */
 
     if (chan == IEEE80211_CHAN_ANYC) { /* XXX bogus entry */
         return;
     }
 
+    iv_stats = wlan_get_stats(vap);
     len = sta_space(node, &ielen, vap);
     if (len > req->space) {
         return;
@@ -6641,7 +7923,7 @@
         si->isi_tx_rate_mcs = rinfo.mcs;
         si->isi_tx_rate_flags = rinfo.flags;
 #endif
-
+        si->isi_kwn_tx_rate_mcs = node->kwn_txrate;
     }
 
     memset(&rinfo, 0, sizeof(rinfo));
@@ -6685,7 +7967,57 @@
     si->isi_is_256qam = wlan_node_get_256qam_support(node);
     si->isi_rx_nss = wlan_node_get_rx_spatial(node);
     si->isi_tx_nss = wlan_node_get_tx_spatial(node);
-
+#if 0
+    printk("sizeof : %d,r_latitude = %s,r_longitude = %s,l_latitude = %s,l_longitude = %s\n",si->isi_len,node->ni_latitude,
+		node->ni_longitude,vap->iv_ic->ic_latitude,vap->iv_ic->ic_longitude);
+#endif
+    if ( ( strlen(node->ni_latitude) != 0 ) && ( strlen(node->ni_longitude) != 0 ) &&
+		    ( strlen(vap->iv_ic->ic_latitude) != 0 ) && ( strlen(vap->iv_ic->ic_longitude) != 0) ) {
+	    strncpy( si->isi_r_latitude, node->ni_latitude, 15 );
+	    strncpy( si->isi_r_longitude, node->ni_longitude, 15 );
+	    strncpy( si->isi_l_latitude, vap->iv_ic->ic_latitude, 15 );
+	    strncpy( si->isi_l_longitude, vap->iv_ic->ic_longitude, 15 );
+    }
+#if 0
+    printk("r_latitude = %s,r_longitude = %s,l_latitude = %s,l_longitude = %s\n",si->isi_r_latitude,si->isi_r_longitude,
+			si->isi_l_latitude,si->isi_l_longitude);
+#endif
+    if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+        si->isi_tx_tput = node->tx_tput_mbps;
+        si->isi_rx_tput = node->rx_tput_mbps;
+    } else {
+        si->isi_tx_tput = iv_stats->kwn_tx_tput_mbps;
+        si->isi_rx_tput = iv_stats->kwn_rx_tput_mbps;
+    }
+    si->isi_local_snr_a1 = node->kwn_snr_avg.local_snr_avg[0];
+    si->isi_local_snr_a2 = node->kwn_snr_avg.local_snr_avg[1];
+    si->isi_remote_snr_a1 = node->kwn_snr_avg.remote_snr_avg[0];
+    si->isi_remote_snr_a2 = node->kwn_snr_avg.remote_snr_avg[1];
+    strncpy( si->isi_ip_addr, node->ip_addr, sizeof( node->ip_addr ) );
+    si->isi_local_phy_err = vap->kwn_local_phy_err;
+    si->isi_remote_phy_err = node->remote_phy_err;
+    si->isi_local_mpdu_err = vap->kwn_local_mpdu_err;
+    si->isi_remote_mpdu_err = node->remote_mpdu_err;
+    si->isi_local_retries = node->kwn_local_retries;
+    si->isi_remote_retries = node->kwn_remote_retries;
+    memcpy( si->isi_l_customer_name, ic->ic_customer_name, sizeof(ic->ic_customer_name) );
+    memcpy( si->isi_r_customer_name, node->customer_name, sizeof(node->customer_name) );
+	strncpy( si->isi_l_link_id, vap->iv_ic->ic_link_id, 15 );
+	strncpy( si->isi_r_link_id, node->link_id, 15 );
+    si->isi_l_noise_floor = vap->kwn_local_noise_floor + vap->kwn_noise_floor_offset;
+    si->isi_r_noise_floor = node->remote_noise_floor + vap->kwn_noise_floor_offset;
+    si->isi_l_ant_gain = vap->kwn_antenna_gain;
+    si->isi_r_ant_gain = node->kwn_antenna_gain;
+    si->isi_l_bw_limit = ( vap->iv_opmode == IEEE80211_M_HOSTAP ? node->kwn_dl_limit : node->kwn_ul_limit );
+    si->isi_r_bw_limit = ( vap->iv_opmode == IEEE80211_M_HOSTAP ? node->kwn_ul_limit : node->kwn_dl_limit );
+    si->isi_l_rtx = node->kwn_local_rtx;
+    si->isi_r_rtx = node->kwn_remote_rtx;
+    si->isi_l_tx_power = ( node->kwn_profile_cfg.txparam.atpc_status == 1 ? node->kwn_profile_cfg.atpc_power : node->kwn_profile_cfg.txparam.power);
+    si->isi_r_tx_power = node->kwn_remote_tx_pwr;
+    si->isi_l_tx_data = node->ni_stats.ns_tx_data;
+    si->isi_l_rx_data = node->ni_stats.ns_rx_data;
+    si->isi_r_tx_data = node->kwn_remote_tx_data;
+    si->isi_r_rx_data = node->kwn_remote_rx_data;
     cp = (u_int8_t *)(si+1);
 
     if(!wlan_node_getwpaie(vap, macaddr, ni_ie, &ni_ie_len)) {
diff -urN qca-wifi-org/umac/base/ieee80211_ucfg.h qca-wifi-mod/umac/base/ieee80211_ucfg.h
--- qca-wifi-org/umac/base/ieee80211_ucfg.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_ucfg.h	2019-04-25 13:50:43.703519535 +0530
@@ -56,4 +56,7 @@
 int ieee80211_ucfg_set_otherband_bssid(wlan_if_t vap, int *val);
 int ieee80211_ucfg_send_probereq(wlan_if_t vap, int val);
 int ieee80211_ucfg_get_cap_snr(wlan_if_t vap, int *cap_snr);
+int ieee80211_send_tput_test(wlan_if_t vap,struct ieee80211_node *ni);
+int ieee80211_send_txbasetup(wlan_if_t vap,struct ieee80211_node *ni);
+int ieee80211_send_clear_node_stats(wlan_if_t vap,struct ieee80211_node *ni);
 #endif //IEEE80211_UCFG_H_
diff -urN qca-wifi-org/umac/base/ieee80211_vap.c qca-wifi-mod/umac/base/ieee80211_vap.c
--- qca-wifi-org/umac/base/ieee80211_vap.c	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/base/ieee80211_vap.c	2019-05-06 18:43:55.795146163 +0530
@@ -37,6 +37,545 @@
 void acfg_clean(struct ieee80211com *ic);
 #endif
 
+extern int ieee80211_tput_test_stats(struct ieee80211vap *vap, struct ieee80211_node *ni );
+extern int ieee80211_send_tput_test(struct ieee80211vap *vap, struct ieee80211_node *ni);
+/* Phani: Tx Tasklet for KWN TPUT Test */
+uint8_t kwn_tput_test_dsap[]      = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+	uint64_t kwn_tput_test_txseq;
+	uint64_t kwn_tput_test_rxseq;
+};
+
+/* KWN - Change1 */
+/* Routine prototypes. */
+void pkt_q_init( struct pkt_q *q )
+{
+	q->head = NULL;
+	q->tail = NULL;
+	q->count = 0;
+    q->len = 0;
+	return;
+}
+
+void *pkt_q_first( struct pkt_q *q )
+{
+	return q->head;
+}
+
+void *pkt_q_last( struct pkt_q *q )
+{
+	return q->tail;
+}
+
+int pkt_q_count( struct pkt_q *q )
+{
+	return q->count;
+}
+
+int pkt_q_skb_len( struct pkt_q *q )
+{
+	return q->len;
+}
+
+void *pkt_q_next( void *pkt )
+{
+	struct sk_buff *skb;
+
+	skb = pkt;
+	return skb->next;
+}
+
+void *pkt_q_prev( void *pkt )
+{
+	struct sk_buff *skb;
+
+	skb = pkt;
+	return skb->prev;
+}
+
+void pkt_q_insert( struct pkt_q *q, void *prev, void *pkt )
+{
+	struct sk_buff *prev_skb;
+	struct sk_buff *node_skb;
+
+	prev_skb = prev;
+	node_skb = pkt;
+	node_skb->prev = prev_skb;
+	if ( node_skb->prev == NULL ) {
+		node_skb->next = q->head;
+		q->head = node_skb;
+	} else {
+		node_skb->next = prev_skb->next;
+		prev_skb->next = node_skb;
+	}
+	if ( node_skb->next == NULL ) {
+		q->tail = node_skb;
+	} else {
+		node_skb->next->prev = node_skb;
+	}
+	q->count++;
+    q->len += node_skb->len;
+    //printk(": Len: %d SLen: %d: QCount: %d\n",q->len, node_skb->len, q->count);
+	return;
+
+}
+
+void pkt_q_add( struct pkt_q *q, void *pkt )
+{
+	pkt_q_insert( q, pkt_q_last( q ), pkt );
+	return;
+}
+
+void pkt_q_delete( struct pkt_q *q, void *pkt )
+{
+	struct sk_buff *node_skb;
+
+	node_skb = pkt;
+	if ( node_skb->prev == NULL ) {
+		q->head = node_skb->next;
+	} else {
+		node_skb->prev->next = node_skb->next;
+	}
+	if ( node_skb->next == NULL ) {
+		q->tail = node_skb->prev;
+	} else {
+		node_skb->next->prev = node_skb->prev;
+	}
+	node_skb->prev = NULL;
+	node_skb->next = NULL;
+	q->count--;
+    q->len -= node_skb->len;
+	return;
+}
+
+void pkt_free( void *pkt )
+{
+	struct sk_buff *skb;
+
+	skb = pkt;
+	dev_kfree_skb( skb );
+	return;
+}
+
+void pkt_q_purge( struct pkt_q *q )
+{
+	void *pkt;
+
+	while ( pkt_q_count( q ) > 0 ) {
+		pkt = pkt_q_first( q );
+		pkt_q_delete( q, pkt );
+		pkt_free( pkt );
+	}
+	return;
+}
+
+void pkt_q_move( struct pkt_q *dst_q, struct pkt_q *src_q )
+{
+	dst_q[ 0 ] = src_q[ 0 ];
+	pkt_q_init( src_q );
+	return;
+}
+
+void
+kwn_spin_lock ( spinlock_t *slock, unsigned long lock )
+{
+    spin_lock_irqsave( slock, lock );
+    return;
+}
+
+void
+kwn_spin_unlock ( spinlock_t *slock, unsigned long lock )
+{
+    spin_unlock_irqrestore( slock, lock );
+    return;
+}
+
+uint8_t kwn_frag_dsap[]      = { 0xaa, 0xaa, 0xab, 0xab };
+struct kwn_frag_params {
+    uint16_t kwn_frag_flags;
+    uint16_t kwn_tot_len;
+    uint16_t kwn_pkt_pad;
+};
+struct sk_buff* pkt_q_assemble( struct pkt_q *q )
+{
+    void *pkt;
+    struct sk_buff *nskb;
+    struct sk_buff *skb;
+    int nskb_len = pkt_q_skb_len ( q );
+    int nskb_reserve = 64;
+    struct ether_header *neth;
+    struct ether_header *oeth;
+    int offset = 0;
+    int elen = sizeof(struct ether_header);
+    int flen = sizeof(struct kwn_frag_params) + sizeof(kwn_frag_dsap);
+    int plen = elen + flen;
+    int nlen = 0;
+
+    /* Subtract the Extra Headers before allocating the Jumbo Frame memory */
+    nskb_len = nskb_len - ((q->count * flen) + (( q->count - 1 ) * elen));
+    /* Create a Jumbo Ethernet packet */
+    nskb = dev_alloc_skb ( nskb_len + nskb_reserve );
+    if ( nskb == NULL ) {
+        return NULL;
+    }
+    /* Fill the skb content */
+    offset = 0;
+    skb_reserve( nskb, nskb_reserve );
+    skb_put( nskb, nskb_len );
+    memset( &nskb->data[ offset ], 0, nskb_len );
+
+    /* Assemble the fragmented packets into the new Jumbo Ethernet Packet */
+    while ( pkt_q_count( q ) > 0 ) {
+        pkt = pkt_q_first( q );
+        skb = (struct sk_buff *)pkt;
+        if ( skb == NULL ) {
+            printk(": skb is NULL: Qcount: %d\n",pkt_q_count(q));
+            pkt_free( pkt );
+            continue;
+        }
+        if ( offset == 0 ) {
+            nskb->dev = skb->dev;
+            neth = ( struct ether_header * ) &nskb->data[ offset ];
+            oeth = ( struct ether_header * )  &skb->data[ offset ];
+            IEEE80211_ADDR_COPY( neth->ether_dhost, oeth->ether_dhost );
+            IEEE80211_ADDR_COPY( neth->ether_shost, oeth->ether_shost );
+            offset += elen;
+        } 
+        nlen = skb->len - plen;
+        //printk(": %s(%d): offset: %d nlen: %d Total: %d Q: %d \n",__func__,__LINE__, offset, nlen, nskb_len, q->count);
+        memcpy(&nskb->data[ offset  ], &skb->data[ plen ], nlen);
+        offset += nlen;
+	    pkt_q_delete( q, pkt );
+        pkt_free( pkt );
+    }
+
+    /* Update the EtherType on concatenation of the fragments */
+    if ( nskb != NULL ) {
+	    neth = ( struct ether_header * ) &nskb->data[ 0 ];
+	    neth->ether_type = ntohs(offset - elen);
+	    /*printk(" NewSkb Len: %d %d EtherType: %x \n",offset, nskb->len, neth->ether_type);*/
+    }
+    return nskb;
+}
+
+void
+ieee80211_assemble_kwn_txq( void *data )
+{
+#if 0
+	struct ieee80211vap *vap = (struct ieee80211vap *)data;
+    unsigned long lock;
+    void *pkt;
+    struct sk_buff *skb = NULL;
+    struct ieee80211_stats *iv_stats;
+    u_int32_t bw_limit = 0;
+    int tx_count = 0;
+    struct ieee80211com *ic = vap->iv_ic;
+
+    iv_stats = wlan_get_stats(vap);
+    /* Obtain Lock */
+    spin_lock_irqsave( &vap->kwn_tx_lock, lock );
+    while ( pkt_q_count( &vap->kwn_txq ) > 0 ) {
+        /* If not enough TX Buffers, then don't send any pkts */
+        tx_count = ic->ic_kwn_get_tx_bufs(ic);
+        if ( tx_count < 0 ) {
+            printk("tx_count: %d\n",tx_count);
+            break;
+        }
+        pkt = pkt_q_first( &vap->kwn_txq );
+        skb = (struct sk_buff *)pkt;
+        /* Traffic Shaping - Check */
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            if( vap->kwn_traffic_shaping ) {
+                bw_limit = vap->kwn_final_dl_limit;
+            }
+        }
+        else {
+            if( !vap->kwn_suservice ) {
+                bw_limit = vap->kwn_su_kbps;
+            }
+            else {
+                if( vap->kwn_traffic_shaping ) {
+                    bw_limit = vap->kwn_final_ul_limit;
+                }
+            }
+        }
+        /* inc Tx packets/bytes offered by kernel to us */
+        iv_stats->tx_offer_pkt_cnt++;
+        iv_stats->tx_offer_pkt_bytes_cnt += skb->len;
+
+        if ( iv_stats->kwn_tx_tput_last_jiffies == 0 ) {
+            iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+        } else {
+            if ( (jiffies - iv_stats->kwn_tx_tput_last_jiffies) >= 1000 )
+            {
+                iv_stats->kwn_tx_tput_mbps = iv_stats->tx_offer_pkt_cnt > 0 ? 
+                    ( ( (iv_stats->tx_offer_pkt_bytes_cnt - iv_stats->tx_byte_drop_cnt ) * 8)) : 0;
+                iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+                iv_stats->tx_offer_pkt_cnt = 0;
+                iv_stats->tx_offer_pkt_bytes_cnt = 0;
+                iv_stats->tx_byte_drop_cnt = 0;
+            }
+            else {
+                /* If Traffic Shaping enabled or SU Service disabled, drop if total byte cnt > bw_limit in 1 sec */
+                if( bw_limit ) {
+                    if( iv_stats->tx_offer_pkt_bytes_cnt > ( ( bw_limit * 1000 ) / 8 ) ) {
+                        iv_stats->tx_offer_pkt_cnt--;
+                        iv_stats->tx_offer_pkt_bytes_cnt -= skb->len;
+                        break;
+                    }
+                }
+            }
+        }
+        pkt_q_delete( &vap->kwn_txq, pkt );
+        spin_unlock_irqrestore( &vap->kwn_tx_lock, lock );
+        vap->iv_kwn_send( pkt );
+        spin_lock_irqsave( &vap->kwn_tx_lock, lock );
+    }
+    if( pkt_q_count ( &vap->kwn_txq ) > 0 ) { 
+        tasklet_schedule( &vap->kwn_tx_q );
+    }
+    spin_unlock_irqrestore( &vap->kwn_tx_lock, lock );
+#endif
+    return;
+}
+
+
+    void
+ieee80211_send_kwn_txq( void *data )
+{
+#if 0
+	struct ieee80211vap *vap = (struct ieee80211vap *)data;
+    unsigned long lock;
+    void *pkt;
+    struct sk_buff *skb = NULL;
+    struct ieee80211_stats *iv_stats;
+    u_int32_t bw_limit = 0;
+    int tx_count = 0;
+    struct ieee80211com *ic = vap->iv_ic;
+
+    iv_stats = wlan_get_stats(vap);
+    /* Obtain Lock */
+    spin_lock_irqsave( &vap->kwn_tx_lock, lock );
+    while ( pkt_q_count( &vap->kwn_txq ) > 0 ) {
+        /* If not enough TX Buffers, then don't send any pkts */
+        tx_count = ic->ic_kwn_get_tx_bufs(ic);
+        if ( tx_count < 0 ) {
+            printk("tx_count: %d\n",tx_count);
+            break;
+        }
+        pkt = pkt_q_first( &vap->kwn_txq );
+        skb = (struct sk_buff *)pkt;
+        /* Traffic Shaping - Check */
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            if( vap->kwn_traffic_shaping ) {
+                bw_limit = vap->kwn_final_dl_limit;
+            }
+        }
+        else {
+            if( !vap->kwn_suservice ) {
+                bw_limit = vap->kwn_su_kbps;
+            }
+            else {
+                if( vap->kwn_traffic_shaping ) {
+                    bw_limit = vap->kwn_final_ul_limit;
+                }
+            }
+        }
+        /* inc Tx packets/bytes offered by kernel to us */
+        iv_stats->tx_offer_pkt_cnt++;
+        iv_stats->tx_offer_pkt_bytes_cnt += skb->len;
+
+        if ( iv_stats->kwn_tx_tput_last_jiffies == 0 ) {
+            iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+        } else {
+            if ( (jiffies - iv_stats->kwn_tx_tput_last_jiffies) >= 1000 )
+            {
+                iv_stats->kwn_tx_tput_mbps = iv_stats->tx_offer_pkt_cnt > 0 ? 
+                    ( ( (iv_stats->tx_offer_pkt_bytes_cnt - iv_stats->tx_byte_drop_cnt ) * 8)) : 0;
+                iv_stats->kwn_tx_tput_last_jiffies = jiffies;
+                iv_stats->tx_offer_pkt_cnt = 0;
+                iv_stats->tx_offer_pkt_bytes_cnt = 0;
+                iv_stats->tx_byte_drop_cnt = 0;
+            }
+            else {
+                /* If Traffic Shaping enabled or SU Service disabled, drop if total byte cnt > bw_limit in 1 sec */
+                if( bw_limit ) {
+                    if( iv_stats->tx_offer_pkt_bytes_cnt > ( ( bw_limit * 1000 ) / 8 ) ) {
+                        iv_stats->tx_offer_pkt_cnt--;
+                        iv_stats->tx_offer_pkt_bytes_cnt -= skb->len;
+                        break;
+                    }
+                }
+            }
+        }
+        pkt_q_delete( &vap->kwn_txq, pkt );
+        spin_unlock_irqrestore( &vap->kwn_tx_lock, lock );
+        vap->iv_kwn_send( pkt );
+        spin_lock_irqsave( &vap->kwn_tx_lock, lock );
+    }
+    if( pkt_q_count ( &vap->kwn_txq ) > 0 ) { 
+        tasklet_schedule( &vap->kwn_tx_q );
+    }
+    spin_unlock_irqrestore( &vap->kwn_tx_lock, lock );
+#endif
+    return;
+}
+
+void
+ieee80211_send_kwn_tput_tx_fr( void *data )
+{
+    struct ieee80211vap *vap = (struct ieee80211vap *)data;
+    struct ieee80211_node *ni;
+
+    if( vap->kwn_tput_test_curr_iter == vap->kwn_tput_test_max_iter_cnt - 1 ) {
+        printk(": TPUT: Stop Test...\n");
+        printk(": TPUT: Cancel Timer\n");
+        OS_CANCEL_TIMER(&vap->kwn_tput_timer);
+        vap->kwn_tput_test_user_started = 0;
+        vap->kwn_tput_test_start_time = 0;
+        vap->kwn_tput_test_in_progress = 0;
+        vap->kwn_tput_test_from_app = 0;
+        vap->kwn_tput_test_txseq = 0;
+        vap->kwn_tput_test_rxseq = 0;
+        vap->kwn_tput_test_rx_failed_cnt = 0;
+        vap->kwn_tput_test_max_iter_cnt = 0;
+        vap->kwn_tput_test_curr_iter = 0;
+        return;
+    }
+    vap->kwn_tput_test_curr_iter++;
+    vap->kwn_tput_test_start_time = jiffies;
+    vap->kwn_tput_test_txseq = 0;
+    vap->kwn_tput_test_rxseq = 0;
+    vap->kwn_tput_test_rx_failed_cnt = 0;
+    vap->kwn_tput_test_pkt_timer = 0;
+    vap->kwn_tput_test_pkt_count = 0;
+    printk(": TPUT: Pkts: Ms: %d S: %d CurIter: %d \n", vap->kwn_tput_test_pkt_per_ms, vap->kwn_tput_test_pkt_per_s, vap->kwn_tput_test_curr_iter);
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+        ni = ieee80211_find_node( &vap->iv_ic->ic_sta, vap->kwn_tput_test_mac );
+        if( ni == NULL ) {
+            printk("ni is NULL\n");
+            return;
+        }
+    }
+    else {
+        ni = vap->iv_bss;
+    }
+    /* Send TPUT Test Command to Remote and Start TPUT Test Locally */
+    if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 2 )
+        ieee80211_send_tput_test(vap, ni);
+    if( vap->kwn_tput_test_direction == 3 || vap->kwn_tput_test_direction == 1 )
+        OS_SET_TIMER(&vap->kwn_tput_timer, vap->kwn_tput_test_ms_timer);
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+        ieee80211_free_node( ni );
+    }
+    return;
+}
+
+void
+ieee80211_send_kwn_tput_tx( void *data )
+{
+    struct ieee80211vap *vap = (struct ieee80211vap *)data;
+    int pkt_per_ms = vap->kwn_tput_test_pkt_per_ms;
+    int pkt_size = vap->kwn_tput_test_pkt_size;
+    struct ether_header *eth;
+    struct net_device *dev;
+    struct kwn_tput_test_params *kparams;
+    //unsigned long lock;
+    struct ieee80211_node *ni;
+
+    if ( (dev = dev_get_by_name( &init_net, vap->iv_netdev_name )) == NULL )
+        return;
+
+    /* Check to limit PktPerS */
+    if ( vap->kwn_tput_test_pkt_count >= vap->kwn_tput_test_pkt_per_s ) { 
+        goto timer;
+    }
+
+    /* Calculate packet count per ms */
+    for ( ; pkt_per_ms > 0; --pkt_per_ms )
+    {
+        struct sk_buff *skb = NULL;
+        int offset = 0;
+        /* Create a packet */
+        skb = dev_alloc_skb ( pkt_size + 64 );
+        if ( skb == NULL ) {
+            dev_put( dev );	
+            return;
+        }
+        /* Fill the skb content */
+        skb_reserve( skb, 64 );
+        skb_put( skb, pkt_size );
+        skb->dev = dev;
+        eth = (struct ether_header *)skb->data;
+        IEEE80211_ADDR_COPY( eth->ether_shost, vap->iv_myaddr );
+        if ( vap->iv_opmode == IEEE80211_M_STA )
+            IEEE80211_ADDR_COPY( eth->ether_dhost, vap->iv_bss->ni_macaddr );
+        else
+            IEEE80211_ADDR_COPY( eth->ether_dhost, vap->kwn_tput_test_mac );
+        eth->ether_type = htons( skb->len - sizeof(*eth) );
+        memcpy(&skb->data[sizeof(*eth)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap));
+        offset += sizeof(*eth) + sizeof(kwn_tput_test_dsap);
+        kparams = (struct kwn_tput_test_params *)&skb->data[offset];
+        kparams->kwn_tput_test_txseq = htonl(vap->kwn_tput_test_txseq);
+        ++vap->kwn_tput_test_txseq;
+        ++vap->kwn_tput_test_pkt_count;
+        vap->kwn_tput_test_from_app = 0;
+        skb_reset_mac_header( skb );
+        dev_queue_xmit( skb );
+    }
+
+timer:
+    /* Schedule Tx Tasklet when test duration is not completed */
+    if ( vap->kwn_tput_test_start_time &&
+            (( jiffies - vap->kwn_tput_test_start_time ) < vap->kwn_tput_test_duration )) {
+        OS_SET_TIMER(&vap->kwn_tput_timer, vap->kwn_tput_test_ms_timer);
+        if ( vap->kwn_tput_test_pkt_timer < ( 1000 / vap->kwn_tput_test_ms_timer ) )
+            ++vap->kwn_tput_test_pkt_timer;
+        else {
+            vap->kwn_tput_test_pkt_timer = 0;
+            vap->kwn_tput_test_pkt_count = 0;
+        }
+    } else {
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            ni = ieee80211_find_node(&vap->iv_ic->ic_sta, vap->kwn_tput_test_mac);
+            if( ni == NULL ) {
+                printk("ni is NULL\n");
+                vap->kwn_tput_test_in_progress = 0;
+                OS_CANCEL_TIMER(&vap->kwn_tput_timer_fr);
+                dev_put( dev );	
+                return;
+            }
+        }
+        else {
+            ni = vap->iv_bss;
+        }
+        printk(": TPUT: Cancel Timer Current Iteration %d Max Iteration %d \n",vap->kwn_tput_test_curr_iter,vap->kwn_tput_test_max_iter_cnt);
+        OS_CANCEL_TIMER(&vap->kwn_tput_timer);
+        if( vap->kwn_tput_test_curr_iter < vap->kwn_tput_test_max_iter_cnt ) {
+            if( vap->kwn_tput_test_user_started ) {
+                ieee80211_tput_test_stats( vap, ni );
+                OS_SET_TIMER(&vap->kwn_tput_timer_fr, 1000);
+            }
+        }
+        else {
+            printk(": TPUT: Cancel Timer\n");
+            vap->kwn_tput_test_in_progress = 0;
+            ni->kwn_tput_running = 0;
+            OS_CANCEL_TIMER(&vap->kwn_tput_timer);
+        }
+        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+            ieee80211_free_node( ni );
+        }
+    } 
+    dev_put( dev );	
+    return;
+}
+
+
 #if DYNAMIC_BEACON_SUPPORT
 static OS_TIMER_FUNC(ieee80211_dbeacon_suspend_beacon)
 {
@@ -502,6 +1041,21 @@
         }
 #endif
 
+    OS_INIT_TIMER(ic->ic_osdev, &vap->kwn_tput_timer, ieee80211_send_kwn_tput_tx, vap, QDF_TIMER_TYPE_WAKE_APPS);
+    OS_INIT_TIMER(ic->ic_osdev, &vap->kwn_tput_timer_fr, ieee80211_send_kwn_tput_tx_fr, vap, QDF_TIMER_TYPE_WAKE_APPS);
+    vap->kwn_tput_test_start_time = 0;
+    /* KWN - Change1 */
+    tasklet_init(&vap->kwn_tx_q, (void *)ieee80211_send_kwn_txq, (unsigned long)vap);
+    OS_INIT_TIMER(ic->ic_osdev, &vap->kwn_txq_timer, ieee80211_send_kwn_txq, vap, QDF_TIMER_TYPE_WAKE_APPS);
+    spin_lock_init( &vap->kwn_tx_lock );
+	vap->iv_pkt_q_init = pkt_q_init;
+	vap->iv_pkt_q_add = pkt_q_add;
+	vap->iv_pkt_q_assemble = pkt_q_assemble;
+	vap->iv_pkt_q_purge = pkt_q_purge;
+    vap->iv_kwn_lock = kwn_spin_lock;
+    vap->iv_kwn_unlock = kwn_spin_unlock;
+    vap->iv_pkt_q_init( &vap->kwn_txq );
+
     vap->offchan_requestor = 0;
     vap->iv_csmode = IEEE80211_CSA_MODE_AUTO; /* csmode will be calculated dynamically */
     vap->iv_enable_ecsaie = true; /* Extended channel switch ie is enabled by default */
@@ -552,7 +1106,17 @@
 ieee80211_vap_detach(struct ieee80211vap *vap)
 {
     int i;
+    struct ieee80211com *ic = vap->iv_ic;
 
+    memset( &ic->kwn_scan.sa_result, 0, sizeof(struct kwn_sa_scan_result) );
+    memset( &ic->kwn_scan.acs_result, 0, sizeof(struct kwn_acs_result) );
+    OS_FREE_TIMER(&ic->kwn_scan.scan_timer);
+    OS_FREE_TIMER(&ic->kwn_scan.util_timer);
+    OS_FREE_TIMER(&ic->kwn_dcs.dcs_timer);
+    OS_FREE_TIMER(&ic->kwn_dcs.bl_timer);
+    OS_FREE_TIMER(&vap->kwn_tput_timer);
+    OS_FREE_TIMER(&vap->kwn_tput_timer_fr);
+    OS_FREE_TIMER(&vap->kwn_txq_timer);
     ieee80211_quiet_vdetach(vap);
     ieee80211_vap_ath_info_detach(vap->iv_vap_ath_info_handle);
     ieee80211_node_latevdetach(vap);
@@ -597,6 +1161,8 @@
 
     spin_lock_destroy(&vap->iv_lock);
     spin_lock_destroy(&vap->init_lock);
+    /* KWN */
+    spin_lock_destroy(&vap->kwn_tx_lock);
 }
 
 int
diff -urN qca-wifi-org/umac/include/ieee80211_channel.h qca-wifi-mod/umac/include/ieee80211_channel.h
--- qca-wifi-org/umac/include/ieee80211_channel.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_channel.h	2018-11-14 14:18:52.546497912 +0530
@@ -27,6 +27,7 @@
 u_int ieee80211_mhz2ieee(struct ieee80211com *ic, u_int freq, u_int flags);
 u_int ieee80211_ieee2mhz(struct ieee80211com *ic, u_int chan, u_int flags);
 struct ieee80211_channel *ieee80211_find_channel(struct ieee80211com *ic, int freq, u_int8_t des_cfreq2, u_int32_t flags);
+struct ieee80211_channel *kwn_find_channel(struct ieee80211com *ic, struct ieee80211vap *vap, u_int16_t freq );
 
 #if ATH_SUPPORT_PRIMARY_ALLOWED_CHAN
 int ieee80211_check_allowed_prim_chanlist(struct ieee80211com *ic,
diff -urN qca-wifi-org/umac/include/ieee80211_mlme.h qca-wifi-mod/umac/include/ieee80211_mlme.h
--- qca-wifi-org/umac/include/ieee80211_mlme.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_mlme.h	2019-03-20 20:26:57.873449384 +0530
@@ -715,9 +715,11 @@
     u_int16_t                   sequence_num;
     bool                        oce_cap;
 #endif
+    u_int8_t                    kwn_linktype;
 };
 
 int ieee80211_parse_beacon(struct ieee80211vap                  *vap,
+			   struct ieee80211_node 		*ni,
                            struct ieee80211_beacon_frame        *beacon_frame,
                            const struct ieee80211_frame         *wh,
                            u_int32_t                            beacon_frame_length,
diff -urN qca-wifi-org/umac/include/ieee80211_node.h qca-wifi-mod/umac/include/ieee80211_node.h
--- qca-wifi-org/umac/include/ieee80211_node.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_node.h	2019-05-06 16:55:54.033490787 +0530
@@ -142,6 +142,68 @@
     u_int64_t  ni_last_ack_jiffies;
 } ni_ctrl_stats_t;
 
+/* DDRS MACROS */
+#define KWN_LINKPARAM_TIMER_INT    2000
+#define KWN_STATS_TIMER_INT        1000
+#define KWN_SNR_TIMER_INT          50
+#define KWN_DDRS_TIMER_INT         1000
+#define KWN_DDRS_BACKOFF_INT       300
+#define KWN_DDRS_RATE_INC          1
+#define KWN_DDRS_RATE_DEC          2
+#define KWN_RATE_MIN               0
+#define KWN_11A_RATE_MAX           7
+#define KWN_11NA_RATE_MAX          15
+#define KWN_11AC_RATE_MAX          19
+#define KWN_11A_SRATE_MAX          7
+#define KWN_11NA_SRATE_MAX         7
+#define KWN_11AC_SRATE_MAX         9
+#define KWN_SNR_SAMPLES_MAX        20
+enum KWN_RTX {
+    KWN_RTX_INCREMENT = 1,
+    KWN_RTX_DECREMENT = 2,
+    KWN_RTX_SAME = 3
+};
+/* ATPC MACROS */
+#define KWN_ATPC_TIMER_INT         1000
+#define KWN_ATPC_POWER_MIN         0
+#define KWN_ATPC_POWER_MAX         26
+#define KWN_ATPC_UPPER_MARGIN      10
+#define KWN_ATPC_LOWER_MARGIN      10
+
+enum KWN_DEBUG {
+    KWN_DEBUG_DDRS = 1,
+    KWN_DEBUG_ATPC = 2,
+    KWN_DEBUG_SNR = 3
+};
+
+enum kwn_chainmask {
+    KWN_CHAINMASK_A1 = 1,
+    KWN_CHAINMASK_A2 = 2,
+    KWN_CHAINMASK_A1A2 = 3
+};
+
+enum kwn_spatialstream {
+    KWN_STREAM_SINGLE = 1,
+    KWN_STREAM_DUAL = 2,
+    KWN_STREAM_AUTO = 3
+};
+
+typedef struct kwn_snravg {
+    u_int8_t local_snr[ IEEE80211_MAX_ANTENNA ][ KWN_SNR_SAMPLES_MAX ];
+    u_int8_t local_snr_avg[ IEEE80211_MAX_ANTENNA ];
+    u_int8_t remote_snr_avg[ IEEE80211_MAX_ANTENNA ];
+    u_int8_t snr_indx;
+    u_int8_t sample_count;
+}kwn_snr_avg_t;
+
+/* KWN Raw Pkt Q */
+struct pkt_q {
+    struct sk_buff *head;
+    struct sk_buff *tail;
+    int count;
+    int len;
+};
+
 /*
  * Node information. A node could represents a BSS in infrastructure network,
  * or an ad-hoc station in IBSS mode, or an associated station in HOSTAP mode.
@@ -585,6 +647,64 @@
     bool        is_ft_reassoc;
     ni_mgmt_stats_t ni_mgmt_stats;
     ni_ctrl_stats_t ni_ctrl_stats;
+    u_int32_t   dg_count;
+    char	ni_latitude[32];
+    char	ni_longitude[32];
+    u_int8_t    remote_snr_a1;
+    u_int8_t    remote_snr_a2;
+    u_int8_t    ip_addr[20];
+    u_int64_t   tx_tput_mbps;
+    u_int32_t   remote_phy_err;
+    u_int32_t   remote_mpdu_err;
+    u_int32_t   kwn_local_retries;
+    u_int32_t   kwn_remote_retries;
+    u_int8_t	customer_name[33];
+    u_int8_t	link_id[16];
+    int16_t	    remote_noise_floor;
+    int8_t      kwn_txrate;
+    int8_t      kwn_txpwr;
+    int16_t     kwn_rxchan;
+    int8_t      kwn_rxrate;
+    int8_t      kwn_rxpwr;
+    os_timer_t  kwn_stats_timer;
+    os_timer_t  kwn_ddrs_timer;
+    os_timer_t  kwn_atpc_timer;
+    os_timer_t  kwn_snr_timer;
+    os_timer_t  kwn_link_timer;
+    os_timer_t  kwn_txba_timer;
+    kwn_link_profile_t kwn_profile_cfg;
+    kwn_snr_avg_t kwn_snr_avg;
+    u_int32_t   kwn_ul_limit;
+    u_int32_t   kwn_dl_limit;
+    u_int8_t    kwn_antenna_gain;
+    u_int32_t   kwn_last_tx_pkts;
+    u_int32_t   kwn_last_retries;
+    u_int8_t    kwn_local_rtx;
+    u_int8_t    kwn_remote_rtx;
+    u_int8_t    kwn_remote_tx_pwr;
+    u_int8_t    kwn_remote_tx_chainmask;
+    u_int8_t    kwn_remote_stream;
+    
+    u_int64_t   rx_tput_mbps;
+    u_int64_t   rx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+    u_int64_t   rx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+    u_int64_t   kwn_rx_tput_last_jiffies;
+    
+    u_int64_t   tx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+    u_int64_t   tx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+    u_int64_t   kwn_tx_tput_last_jiffies;
+    u_int64_t   tx_byte_drop_cnt; /* no of bytes dropped to umac for Tx*/
+    struct pkt_q  kwn_txq;
+    u_int8_t    kwn_send_retry;
+    u_int8_t    kwn_macinmac;
+    u_int8_t    kwn_linktype;
+    u_int8_t    kwn_lastfrag;
+    u_int8_t    kwn_tput_running;
+    u_int32_t   kwn_remote_tx_data;
+    u_int32_t   kwn_remote_rx_data;
+    u_int8_t    kwn_remote_shaping;
+    u_int8_t    kwn_txbasetup;
+    u_int8_t    kwn_traffic_shaping;
 } IEEE80211_NODE, *PIEEE80211_NODE;
 
 
diff -urN qca-wifi-org/umac/include/ieee80211_scan.h qca-wifi-mod/umac/include/ieee80211_scan.h
--- qca-wifi-org/umac/include/ieee80211_scan.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_scan.h	2019-03-20 20:27:08.473423650 +0530
@@ -451,6 +451,8 @@
 
 u_int8_t *ieee80211_scan_entry_rsn(ieee80211_scan_entry_t scan_entry);
 
+u_int8_t ieee80211_scan_entry_linktype(ieee80211_scan_entry_t scan_entry);
+
 u_int8_t *ieee80211_scan_entry_wpa(ieee80211_scan_entry_t scan_entry);
 
 u_int8_t *ieee80211_scan_entry_wps(ieee80211_scan_entry_t scan_entry);
@@ -587,6 +589,7 @@
 
 struct ieee80211_scan_entry *
 ieee80211_scan_table_update(struct ieee80211vap          *vap,
+			    struct ieee80211_node *ni,
                             struct ieee80211_frame *wh,
                             u_int32_t                    frame_length,
                             int                          subtype, 
diff -urN qca-wifi-org/umac/include/ieee80211_vap.h qca-wifi-mod/umac/include/ieee80211_vap.h
--- qca-wifi-org/umac/include/ieee80211_vap.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_vap.h	2019-03-14 16:48:48.425855527 +0530
@@ -177,4 +177,12 @@
  *  Return ieee80211_cwm_width
  */
 enum ieee80211_cwm_width ieee80211_get_vap_max_chwidth (struct ieee80211vap *vap);
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap,u_int32_t send_ack,struct ieee80211_node *ni);
+void ieee80211_send_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni );
+void ieee80211_send_link_params(struct ieee80211vap *vap, struct ieee80211_node *ni);
+void ieee80211_send_scan_entries(struct ieee80211vap *vap);
+void ieee80211_send_node_stats(struct ieee80211vap *vap, struct ieee80211_node *ni );
+void kwn_beacon_chanutil_update(struct ieee80211vap *vap);
+void kwn_sa_set_channel(struct ieee80211com *ic);
+void disassoc_stations( void* arg, wlan_if_t vap );
 #endif
diff -urN qca-wifi-org/umac/include/ieee80211_var.h qca-wifi-mod/umac/include/ieee80211_var.h
--- qca-wifi-org/umac/include/ieee80211_var.h	2018-06-08 11:00:49.000000000 +0530
+++ qca-wifi-mod/umac/include/ieee80211_var.h	2019-05-06 20:02:46.672177914 +0530
@@ -590,6 +590,17 @@
 #define RNR_MAX_SIZE               256    /* >= RNR_MAX_ENTRIES * (sizeof(rnr_ap_info_t) + sizeof(rnr_tbtt_info_t)) */
 #define ACR_MAX_ENTRIES            16     /* AP Channel Report entries */
 #define ACR_MAX_CHANNELS           16     /* Max number of channels for each op class */
+#define KWN_BL_TIME                10000
+#define KWN_RTX_TIME               1000
+
+#define KWN_TPUT_TEST_MAX_DURATION 172800
+
+enum kwn_linktype {
+    KWN_LINKTYPE_PTP = 1,
+    KWN_LINKTYPE_BACKHAUL = 2,
+    KWN_LINKTYPE_PTMP_TDMA = 3,
+    KWN_LINKTYPE_PTMP = 4
+};
 
 typedef struct ap_chan_rpt {
     u_int8_t op_class;
@@ -605,6 +616,36 @@
 
 } chan_util_stats_t;
 
+typedef struct kwn_dcs_param {
+    os_timer_t dcs_timer;
+    u_int16_t  dcs_time;
+    wlan_if_t  dcs_vap;
+    u_int8_t   dcs_status;
+    u_int8_t   dcs_thrld;
+    os_timer_t bl_timer;
+    u_int8_t   bl_timer_started;
+    u_int16_t  bl_int;
+    u_int8_t   dcs_triggered;
+} kwn_dcs_t;
+
+typedef struct kwn_scan_param {
+    os_timer_t scan_timer;
+    os_timer_t util_timer;
+    wlan_if_t  scan_vap;
+    u_int16_t  oper_freq;
+    u_int16_t  start_freq;
+    u_int16_t  end_freq;
+    u_int16_t  curr_freq;
+    u_int8_t   start_scan;
+    u_int16_t  scan_time;
+    u_int16_t  sa_scan_time;
+    u_int16_t  acs_scan_time;
+    u_int16_t  util_time;
+    u_int8_t   next_chan;
+    struct kwn_sa_scan_result sa_result;
+    struct kwn_acs_result acs_result;
+} kwn_scan_t;
+
 typedef struct ieee80211com {
     osdev_t                       ic_osdev; /* OS opaque handle */
     qdf_device_t                  ic_qdf_dev; /* ADF opaque handle */
@@ -1574,6 +1615,8 @@
     void                                (*ic_beacon_probe_template_update)(struct ieee80211_node *ni);
     int                                 (*ic_vap_set_param)(struct ieee80211vap *vap,
                                          ieee80211_param param, u_int32_t val);
+    int                                 (*ic_kwn_vap_set_param)(struct ieee80211vap *vap,
+                                         ieee80211_param param, u_int32_t val);
     int                                 (*ic_vap_sifs_trigger)(struct ieee80211vap *vap,
                                          u_int32_t val);
     int                                 (*ic_vap_get_param)(struct ieee80211vap *vap,
@@ -1886,6 +1929,33 @@
     u_int32_t                           ic_whc_scaling_factor; /* scaling factor for WHC best uplink algorithm */
     u_int32_t                           device_id;   /* Device id from probe */
     u_int32_t                           vendor_id;   /* Vendor id from probe */
+    int                                 sta_freq;        /* setting in Mhz */
+    u_int32_t                           dying_gasp;
+    u_int32_t                           ic_str_type;
+    u_int8_t                          	ic_link_id[16];
+    char                                ic_customer_name[33];
+    char                                ic_longitude[32];
+    char                                ic_latitude[32];
+    u_int32_t                           ic_dg_timer_interval;
+    u_int32_t                           ic_dg_ack_disable;
+    u_int32_t                           kwn_amsdu;
+    u_int16_t                           kwn_start_freq;
+    u_int16_t                           kwn_curr_freq;
+    u_int16_t                           kwn_end_freq;
+    void                                (*ic_kwn_get_ol_stats)(struct ieee80211vap *vap, struct ieee80211com *ic);
+    u_int8_t                            enable_sa_scan;
+    u_int8_t                            enable_acs;
+    kwn_scan_t                          kwn_scan;
+    kwn_dcs_t                           kwn_dcs;
+    uint8_t                             ic_ipaddr[20];
+    u_int8_t                            ic_dg_triggered;
+    u_int64_t                           ic_dg_jiffies;
+    u_int8_t                            kwn_macinmac;
+    u_int8_t                            kwn_linktype;
+    void                                (*ic_kwn_set_qboost)(struct ieee80211vap *vap, struct ieee80211com *ic, struct ieee80211_node *ni, int value);
+    os_timer_t                          kwn_rtx_timer;  /* Timer to measure the RTX perc */
+    u_int32_t                           kwn_tx_pkts;
+    u_int32_t                           kwn_retries;
 } IEEE80211COM, *PIEEE80211COM;
 
 #define BEST_UL_HYST_DEF        10
@@ -2283,6 +2353,9 @@
     struct ieee80211_stats            iv_stats; /* for backward compatibility */
     struct ieee80211_mac_stats        iv_unicast_stats;   /* mac statistics for unicast frames */
     struct ieee80211_mac_stats        iv_multicast_stats; /* mac statistics for multicast frames */
+#ifdef SIFY_MGMT_STATS
+	struct ieee80211_mgmt_stats       iv_mgmt_stats;
+#endif	
     struct tkip_countermeasure        iv_unicast_counterm;  /* unicast tkip countermeasure */
     struct tkip_countermeasure        iv_multicast_counterm;  /* unicast tkip countermeasure */
 
@@ -2538,6 +2611,7 @@
     u_int8_t						  iv_sko_th;        /* station kick out threshold */
 #endif /*ATH_SUPPORT_QUICK_KICKOUT*/
     struct ieee80211_chanutil_info     chanutil_info; /* Channel Utilization information */
+    struct kwn_chanutil_info           kwnchanutil_info; /* Channel Utilization information */
 #if UMAC_SUPPORT_CHANUTIL_MEASUREMENT
     u_int8_t                           iv_chanutil_enab;
 #endif /* UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
@@ -2673,6 +2747,7 @@
     void                        *iv_txrx_handle;
 #endif
     u_int8_t                   iv_vht_fixed_mcs;        /* VHT Fixed MCS Index */
+    u_int8_t                   iv_ht_fixed_mcs;         /* HT Fixed MCS Index */
     u_int8_t                   iv_nss;                  /* Spatial Stream Count */
     u_int8_t                   iv_tx_stbc;              /* TX STBC Enable:1 Disable:0 */
     u_int8_t                   iv_rx_stbc;              /* RX STBC Enable:(1,2,3) Disable:0 */
@@ -2908,8 +2983,91 @@
     bool                       iv_wps_session;
     csa_deauth_type            iv_csa_deauth_mode; /* if set, sends deauth to all stations after CSA */
     u_int8_t                   iv_filter_ssid[IEEE80211_NWID_LEN+1]; /* Filter SSID from scan results */
+    u_int32_t                  kwn_ul_limit;
+    u_int32_t                  kwn_dl_limit;
+    u_int8_t                   kwn_local_snr_a1;
+    u_int8_t                   kwn_local_snr_a2;
+    os_timer_t                 kwn_tput_timer;
+    os_timer_t                 kwn_tput_timer_fr;
+    u_int64_t                  kwn_tput_test_start_time;
+    u_int32_t                  kwn_tput_test_duration;
+    u_int32_t                  kwn_tput_test_pkt_size;
+    u_int32_t                  kwn_tput_test_pkt_per_ms;
+    u_int32_t                  kwn_tput_test_max_pkt_per_ms;
+    u_int32_t                  kwn_tput_test_pkt_per_s;
+    u_int32_t                  kwn_tput_test_max_pkt_per_s;
+    u_int32_t                  kwn_tput_test_low_pktpers;
+    u_int32_t                  kwn_tput_test_up_pktpers;
+    u_int16_t                  kwn_tput_test_pkt_timer;
+    u_int8_t                   kwn_tput_test_ms_timer;
+
+    char                       kwn_tput_test_mac[6];
+    u_int8_t                   kwn_tput_test_in_progress;
+    u_int8_t                   kwn_tput_test_direction;
+    u_int8_t                   kwn_tput_test_from_app;
+    u_int64_t                  kwn_tput_test_txseq;
+    u_int64_t                  kwn_tput_test_pkt_count;
+    u_int64_t                  kwn_tput_test_rxseq;
+    u_int64_t                  kwn_tput_test_rx_failed_cnt;
+    u_int8_t                   kwn_tput_test_user_started;
+    int32_t                    kwn_tput_test_curr_iter;
+    int32_t                    kwn_tput_test_max_iter_cnt;
+    u_int32_t                  kwn_local_phy_err;
+    u_int32_t                  kwn_local_phy_err1;
+    u_int32_t                  kwn_local_mpdu_err;
+    u_int32_t                  kwn_local_mpdu_err1;
+    u_int32_t                  kwn_local_tx_mgmt;
+    u_int32_t                  kwn_local_tx_mgmt1;
+    u_int32_t                  kwn_local_rx_mgmt;
+    u_int32_t                  kwn_local_rx_mgmt1;
+    u_int32_t                  kwn_mgmt_vlan_id;
+    char                       kwn_eth_mac_addr[6];
+    int16_t                    kwn_local_noise_floor;
+    u_int8_t                   kwn_flag;
+    u_int8_t                   kwn_noise_floor_offset;
+    char                       kwn_rate_node_mac[6];
+    struct kwn_link_txparam    kwn_txparam;
+    u_int8_t                   kwn_antenna_gain;
+    u_int8_t                   kwn_allow_tagged_mgmt;
+    u_int8_t                   kwn_assem_frag;
+    u_int16_t                  kwn_max_pkt_size;
+    u_int16_t                  kwn_frag_pkt_size;
+    u_int8_t                   kwn_traffic_shaping;
+    u_int32_t                  kwn_final_ul_limit;
+    u_int32_t                  kwn_final_dl_limit;
+    u_int8_t                   kwn_rxchan;
+    u_int8_t                   kwn_suservice;
+    u_int32_t                  kwn_su_kbps;
+    u_int16_t                  kwn_local_rtx;
+    u_int8_t                   kwn_softreset;
+    /* KWN - Change1 */
+    struct tasklet_struct      kwn_tx_q;             /* Holds a hrtimer to send broadcast probe response from a vap */
+    struct pkt_q               kwn_txq;
+    spinlock_t                 kwn_tx_lock;
+    os_timer_t                 kwn_txq_timer;
+    void                       (*iv_pkt_q_init)( struct pkt_q * );
+    void                       (*iv_pkt_q_add)(struct pkt_q *, void *);
+    void                       (*iv_pkt_q_purge)( struct pkt_q * );
+    struct sk_buff*            (*iv_pkt_q_assemble)(struct pkt_q *);
+    void                       (*iv_kwn_lock)( spinlock_t *slock, unsigned long lock);
+    void                       (*iv_kwn_unlock)( spinlock_t *slock, unsigned long lock);
+    void                       (*iv_kwn_send)( wbuf_t );
+    u_int8_t                   kwn_tx_init;
+    u_int8_t                   kwn_debug;
+    u_int8_t                   kwn_lastfrag;
+    u_int64_t                  kwn_last_scan_time;
 } IEEE80211VAP, *PIEEE80211VAP;
 
+/* KWN Flag */
+enum kwn_flag {
+    TPUT_TEST_MAC = 1,
+    PBB_DA_MAC = 2,
+    PBB_SA_MAC = 3,
+    SCAN_ENTRY_FLUSH = 4,
+    RATE_NODE_MAC = 5,
+    SA_RESULTS = 6,
+    CLEAR_NODE_STATS = 7
+};
 #if QCN_IE
 #define EFF_CHAN_TIME(_chantime, _buffer)  (((_chantime) && (_chantime > _buffer)) ? ((_chantime) - (_buffer)) : (0))
 #endif
diff -urN qca-wifi-org/umac/mlme/ieee80211_beacon.c qca-wifi-mod/umac/mlme/ieee80211_beacon.c
--- qca-wifi-org/umac/mlme/ieee80211_beacon.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_beacon.c	2019-03-22 16:20:25.668416445 +0530
@@ -594,6 +594,25 @@
         bo->bo_ibssdfs_trailerlen = 0;
     }
 #endif /* ATH_SUPPORT_IBSS_DFS */
+    /* Update latitude and longitude info if valid*/
+    if ( (strlen(ic->ic_latitude) != 0 ) && (strlen(ic->ic_longitude) != 0 ) ) {
+	    *frm++ = IEEE80211_ELEMID_RESERVED_47;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_latitude,32);
+	    frm += 32;
+	    *frm++ = IEEE80211_ELEMID_RESERVED_133;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_longitude,32);
+	    frm += 32;
+    }
+
+    /* Update Link Type */
+    if( ic->kwn_linktype != 0 ) {
+	   *frm++ = IEEE80211_ELEMID_LINKTYPE;
+	   *frm++ = 1;
+       *frm++ = ic->kwn_linktype;
+    }
+
 #if UMAC_SUPPORT_WNM
     bo->bo_fms_trailerlen = frm - bo->bo_fms_trailer;
 #endif /* UMAC_SUPPORT_WNM */
@@ -646,6 +665,7 @@
  *       that problem can be solved.
  */
     ieee80211_scan_table_update(vap,
+				NULL,
                                 (struct ieee80211_frame*)wh,
                                 frame_len,
                                 IEEE80211_FC0_SUBTYPE_BEACON,
@@ -857,6 +877,7 @@
     struct ieee80211_tim_ie *tie = NULL;
 	systime_t curr_time = OS_GET_TIMESTAMP();
     static systime_t prev_store_beacon_time;
+    int is2GHz = IEEE80211_IS_CHAN_2GHZ( ic->ic_curchan );
 #if UMAC_SUPPORT_WNM
     u_int32_t fms_counter_mask = 0;
     u_int8_t *fmsie = NULL;
@@ -943,9 +964,12 @@
         htole16(ni->ni_txseqs[IEEE80211_NON_QOS_SEQ] << IEEE80211_SEQ_SEQ_SHIFT);
     ni->ni_txseqs[IEEE80211_NON_QOS_SEQ]++;
 
+    if( vap->iv_opmode == IEEE80211_M_HOSTAP && !is2GHz ) {
+        vap->iv_update_vendor_ie = 1;
+    }
     /* If vendor ie enable configuration changed, then reinit the beacon */
     if (vap->iv_update_vendor_ie ) {
-        qdf_print("%s reinit beacon as vndor ie confguration chnaged \n",__func__);
+        //qdf_print("%s reinit beacon as vndor ie confguration chnaged \n",__func__);
         frm = (u_int8_t *) wbuf_header(wbuf) + sizeof(struct ieee80211_frame);
 	frm = ieee80211_beacon_init(ni, bo, frm);
 	update_beacon_copy = true;
diff -urN qca-wifi-org/umac/mlme/ieee80211_bssload.c qca-wifi-mod/umac/mlme/ieee80211_bssload.c
--- qca-wifi-org/umac/mlme/ieee80211_bssload.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_bssload.c	2018-11-14 14:19:50.902505495 +0530
@@ -68,6 +68,43 @@
 
 #endif /* UMAC_SUPPORT_BSSLOAD || UMAC_SUPPORT_CHANUTIL_MEASUREMENT */
 
+void kwn_beacon_chanutil_update(struct ieee80211vap *vap)
+{
+    struct ieee80211com *ic = vap->iv_ic;
+    struct ieee80211_mib_cycle_cnts cnts;
+    struct kwn_chanutil_info *cu = &vap->kwnchanutil_info;
+    
+    if (cu->cycle_count == 0) {
+        /* read the cycle counts and return */
+        ic->ic_rmgetcounters(ic, &cnts);
+        cu->cycle_count = cnts.cycle_count;
+        cu->rx_clear_count = cnts.rx_clear_count;
+        return;
+    }
+    //if (cu->beacon_count == CHAN_UTIL_BEACON_INTL_DEF) 
+    {
+        /* get the counter */
+        ic->ic_rmgetcounters(ic, &cnts);
+        if ((cnts.cycle_count > cu->cycle_count) &&
+            (cnts.rx_clear_count > cu->rx_clear_count)) {
+            u_int32_t cc_d = cnts.cycle_count - cu->cycle_count;
+            u_int32_t rc_d = cnts.rx_clear_count - cu->rx_clear_count;
+            if (cc_d > (0x80000000 >> 8)) {
+                cu->value = rc_d / (cc_d >> 8);
+            }
+            else {
+                cu->value = (rc_d << 8) / cc_d;
+            }
+            //printk("############ value %u\n",cu->value);
+            cu->count++;
+            cu->total += cu->value;
+        }
+        cu->cycle_count = cnts.cycle_count;
+        cu->rx_clear_count = cnts.rx_clear_count;
+    }
+    return;
+}
+
 #if UMAC_SUPPORT_BSSLOAD
 
 /*
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_ap.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_ap.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_ap.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_ap.c	2018-07-03 10:12:53.968984596 +0530
@@ -268,6 +268,27 @@
 	case IEEE80211_ELEMID_FT:
             ftcap = frm;
             break;
+        case IEEE80211_ELEMID_RESERVED_133:
+                if ( ni != NULL ) {
+                   printk(" %s:ni->ni_longitude:%s Element id 133, longitude recieved: %s \n",__func__,ni->ni_longitude,
+                        (u_int8_t *) ((struct ieee80211_ie_gps* )frm)->hc_coordinates);
+                   printk("sta MAC addr:%02x:%02x:%02x:%02x:%02x:%02x \n",
+                        ni->ni_macaddr[0],ni->ni_macaddr[1],ni->ni_macaddr[2],
+                        ni->ni_macaddr[3],ni->ni_macaddr[4],ni->ni_macaddr[5]);
+                   strncpy(ni->ni_longitude,((struct ieee80211_ie_gps* )frm)->hc_coordinates,32);
+                }
+            break;
+        case IEEE80211_ELEMID_RESERVED_47:
+                if ( ni != NULL ) {
+                   printk(" %s:ni->ni_latitude : %s Element id 47,latitude recieved: %s \n",__func__,ni->ni_latitude,
+                                (u_int8_t *) ((struct ieee80211_ie_gps* )frm)->hc_coordinates);
+                   printk("sta MAC addr:%02x:%02x:%02x:%02x:%02x:%02x \n",
+                        ni->ni_macaddr[0],ni->ni_macaddr[1],ni->ni_macaddr[2],
+                        ni->ni_macaddr[3],ni->ni_macaddr[4],ni->ni_macaddr[5]);
+                   strncpy(ni->ni_latitude,((struct ieee80211_ie_gps* )frm)->hc_coordinates,32);
+                }
+            break;
+
 
         case IEEE80211_ELEMID_VENDOR:
             if (iswpaoui(frm)) {
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_bss.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_bss.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_bss.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_bss.c	2019-03-22 16:20:45.512345935 +0530
@@ -444,6 +444,7 @@
 #endif
     u_int8_t *mbo = NULL;
     bool suppress_resp = false;
+    int is2GHz = IEEE80211_IS_CHAN_2GHZ( ic->ic_curchan );
 
     OS_MEMZERO(&extractx, sizeof(extractx));
 #if ATH_SUPPORT_AP_WDS_COMBO
@@ -604,10 +605,30 @@
             }
             break;
 #endif
+        case IEEE80211_ELEMID_LINKTYPE:
+            {
+                if ( ni != NULL ) {
+                    ni->kwn_linktype = ((struct ieee80211_erp_ie *) frm)->value;
+                    //printk("########### Local Link Type %d Remote Link Type %d \n",ic->kwn_linktype,ni->kwn_linktype);
+                    if( ic->kwn_linktype != 0 && ni->kwn_linktype != 0 ) {
+                        if( ( ic->kwn_linktype != KWN_LINKTYPE_PTMP_TDMA && ic->kwn_linktype != KWN_LINKTYPE_PTMP ) && 
+                                    ic->kwn_linktype != ni->kwn_linktype )
+                        {
+                            //printk("Probe recv Failed: Local Link Type %d Remote Link Type %d \n",ic->kwn_linktype,ni->kwn_linktype);
+                            return -EINVAL;
+                        }
+                    }
+                }
+            }
+            break;
         }
         frm += frm[1] + 2;
     }
 
+    if( ni != NULL && ni->kwn_linktype == 0 && !is2GHz ) {
+        //printk("Probe recv Failed: Local Link Type %d Remote Link Type %d \n",ic->kwn_linktype,ni->kwn_linktype);
+        return -EINVAL;
+    }
     if (frm > efrm) {
         ret = -EINVAL;
         goto exit;
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt.c qca-wifi-mod/umac/mlme/ieee80211_mgmt.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt.c	2019-05-14 19:04:39.035916982 +0530
@@ -22,10 +22,21 @@
 #include "ieee80211_wifipos_pvt.h"
 #endif
 #include "dfs_ioctl.h"
+#include <linux/inetdevice.h>
+#include <linux/rtnetlink.h>
+
 /*
  * xmit management processing code.
  */
 
+/* KWN */
+extern int edma_get_mgmt_vlan_id( struct net_device *dev );
+extern int ieee80211_get_scanentries( struct net_device *dev, struct ieee80211_action_vht_scan_entries *entries );
+
+unsigned int dg_ack_rcvd;
+unsigned int dg_seq;
+EXPORT_SYMBOL(dg_ack_rcvd);
+
 /*
  * Set the direction field and address fields of an outgoing
  * non-QoS frame.  Note this should be called early on in
@@ -418,6 +429,13 @@
     frm = ieee80211_add_rates(frm, &vap->iv_op_rates[mode]);
     frm = ieee80211_add_xrates(frm, &vap->iv_op_rates[mode]);
 
+    /* Update Link Type */
+    if( ic->kwn_linktype != 0 ) {
+	   *frm++ = IEEE80211_ELEMID_LINKTYPE;
+	   *frm++ = 1;
+       *frm++ = ic->kwn_linktype;
+    }
+
      /* 11ac or  11n  and ht allowed for this vap */
     if ((IEEE80211_IS_CHAN_11AC(ic->ic_curchan) ||
         IEEE80211_IS_CHAN_11N(ic->ic_curchan)) &&
@@ -597,7 +615,9 @@
     if (status == IEEE80211_STATUS_SUCCESS) {
         vap->iv_stats.mlme_auth_success++;
     }
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.aut_xmit++;
+#endif
     return ieee80211_send_mgmt(vap,ni, wbuf,false);
 }
 
@@ -692,7 +712,9 @@
         ieee80211_vap_set_complete_buf_handler(wbuf, handler, (void *)ni);
     }
 #endif
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.deaut_xmit++;
+#endif
     if (vap->iv_vap_is_down)
         return ieee80211_send_mgmt(vap, ni, wbuf, true);
     else
@@ -884,7 +906,9 @@
             frm = res;
         }
     }
-
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.disassoc_xmit++;
+#endif
     if (vap->iv_mesh_mgmt_txsend_config == 0)
     {
         wbuf_set_pktlen(wbuf, (frm - (u_int8_t *)wbuf_header(wbuf)));
@@ -921,6 +945,377 @@
             return 0;
     }
 }
+int get_default_ipaddr_by_devname(const char *devname)
+{
+	int addr;
+	struct net_device *dev;
+	if (!devname) return 0;
+	/* find netdev by name, increment refcnt */
+	dev=dev_get_by_name(&init_net,devname);
+	if (!dev) return 0;
+	/* get ip addr from rtable (global scope) */
+	addr = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);
+	/* decrement netdev refcnt */
+	dev_put(dev);
+	return addr;
+}
+
+void ieee80211_send_dying_gasp(struct ieee80211vap *vap, u_int32_t send_ack, struct ieee80211_node *ack_ni)
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap) {
+        struct ieee80211_node   *ni = NULL; 
+        if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP && !send_ack) {
+            /* create temporary node for broadcast */
+            ni = ieee80211_tmp_node(vap, IEEE80211_GET_BCAST_ADDR(vap->iv_ic));
+        } else {
+            if ( send_ack ) {
+                ni = ack_ni;
+            }
+            else {
+                ni = vap->iv_bss;
+            }
+        }
+        if (ni != NULL) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_DYING_GASP;
+            actionargs.arg1     = send_ack;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action(ni, &actionargs, NULL);
+            if (ieee80211vap_get_opmode(vap) == IEEE80211_M_HOSTAP && !send_ack) {
+                /* temporary node - decrement reference count so that the node will be
+                 * automatically freed upon completion */
+                ieee80211_free_node(ni);
+            }
+        }
+    }
+}
+
+void ieee80211_send_link_params( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_LINK_PARAM;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+		}
+	}
+}
+
+void ieee80211_send_node_stats( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+	struct ieee80211_action_mgt_args actionargs;
+
+	if( NULL != vap ) {
+		if( ni != NULL ) {
+			actionargs.category = IEEE80211_ACTION_CAT_VHT;
+			actionargs.action   = IEEE80211_ACTION_NODE_STATS;
+			actionargs.arg1     = 0;
+			actionargs.arg2     = 0;
+			actionargs.arg3     = 0;
+			ieee80211_send_action( ni, &actionargs, NULL );
+		}
+	}
+}
+
+void ieee80211_send_tput_test( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_TPUT_TEST;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );
+        }
+    }
+}
+
+void ieee80211_tput_test_stats( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_TPUT_TEST_STATS;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );
+        }
+    }
+}
+
+void ieee80211_send_txbasetup( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_TXBA_SETUP;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );
+        }
+    }
+}
+
+void ieee80211_send_clear_node_stats( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_CLEAR_NODE_STATS;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );
+        }
+    }
+}
+
+void ieee80211_send_scan_entries( struct ieee80211vap *vap )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        struct ieee80211_node *ni = NULL; 
+        ni = vap->iv_bss;
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_SCAN_ENTRIES;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );	
+        }
+    }
+}
+
+void ieee80211_send_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni )
+{
+    struct ieee80211_action_mgt_args actionargs;
+
+    if( NULL != vap ) {
+        if( ni != NULL ) {
+            actionargs.category = IEEE80211_ACTION_CAT_VHT;
+            actionargs.action   = IEEE80211_ACTION_TX_PARAMS;
+            actionargs.arg1     = 0;
+            actionargs.arg2     = 0;
+            actionargs.arg3     = 0;
+            ieee80211_send_action( ni, &actionargs, NULL );
+        }
+    }
+}
+
+#define kwmin(x,y) ((x) < (y) ? (x) : (y))
+
+void ieee80211_apply_txparams( struct ieee80211vap *vap, struct ieee80211_node *ni, int16_t chan, int8_t rate, int8_t pwr )
+{
+    struct rate_wmi_val {
+        int a_rate[8];
+        int na_rate[16];
+        int ac_rate[20];
+    };
+    struct rate_wmi_val rate_val = { { 3, 7, 2, 6, 1, 5, 0, 4 },
+                                     { 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151 },
+                                     { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217 } };
+    struct rate_wmi_val rate_val_pwr_20 = { { 3, 7, 2, 6, 1, 5, 0, 4 },
+      { 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151 },
+      { 23, 23, 23, 23, 23, 22, 21, 20, 20, 20, 23, 23, 23, 23, 23, 22, 21, 20, 20, 20 } }; 
+    
+    struct rate_wmi_val rate_val_pwr_40 = { { 3, 7, 2, 6, 1, 5, 0, 4 },
+      { 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151 },
+      { 23, 23, 23, 23, 23, 22, 21, 20, 19, 18, 23, 23, 23, 23, 23, 22, 21, 20, 19, 18 } }; 
+    
+    struct rate_wmi_val rate_val_pwr_80 = { { 3, 7, 2, 6, 1, 5, 0, 4 },
+      { 128, 129, 130, 131, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151 },
+      { 23, 23, 23, 23, 23, 22, 21, 19, 18, 17, 23, 23, 23, 23, 23, 22, 21, 19, 18, 17 } }; 
+
+    struct ieee80211_channel *channel;
+    struct ieee80211com *ic = vap->iv_ic;
+    int is2GHz = IEEE80211_IS_CHAN_2GHZ( ic->ic_curchan );
+    int rPwr = 0;
+    int txchainmask = ieee80211com_get_tx_chainmask(ic);
+
+
+    if( ni == NULL ) {
+        printk("%s() : %d : Node pointer is NULL \n",__func__,__LINE__);
+        return;
+    }
+    if ( ieee80211vap_get_opmode( vap ) == IEEE80211_M_HOSTAP ) {
+        if( chan != -1 ) {
+            channel = ieee80211_find_dot11_channel( ic, chan, 0, wlan_get_current_phymode(vap) | ic->ic_chanbwflag );
+            printk("############### set channel %d %d ############# \n",channel->ic_ieee,channel->ic_freq);
+            ieee80211_set_channel( ic, channel );
+        }
+        if( pwr != -1 ) {
+            ni->kwn_txpwr = pwr;
+            //ic->ic_set_node_tpc( ic, ni, pwr );
+            /* Get the MaxPower for the current Rate based on CBW */
+            if ( IEEE80211_IS_CHAN_11AC_VHT20( ic->ic_curchan ) ) {
+              rPwr = rate_val_pwr_20.ac_rate[ ni->kwn_txrate ];
+            } else if ( IEEE80211_IS_CHAN_11AC_VHT40PLUS( ic->ic_curchan ) ||
+                IEEE80211_IS_CHAN_11AC_VHT40MINUS( ic->ic_curchan ) ) {
+              rPwr = rate_val_pwr_40.ac_rate[ ni->kwn_txrate ];
+            } else if ( IEEE80211_IS_CHAN_11AC_VHT80( ic->ic_curchan )) {
+              rPwr = rate_val_pwr_80.ac_rate[ ni->kwn_txrate ];
+            }
+            /* Apply Min( UserPower, RateMaxPower ) */
+            if ( rPwr != 0 ) {
+              pwr = kwmin( pwr, rPwr );
+              if ( txchainmask == 3 )
+                pwr += 3;
+              ic->ic_set_txPowerLimit( ic, 2 * pwr, 2 * pwr, is2GHz );
+              printk(": ATPC: rPwr: %d NiTxPwr: %d\n", pwr, ni->kwn_txpwr);
+            }
+        }
+        if( rate != -1 ) {
+            switch( wlan_get_current_phymode(vap) )
+            {
+                case IEEE80211_MODE_11A:
+                case IEEE80211_MODE_TURBO_A:
+                    {
+                        ni->ni_fixed_rate = rate_val.a_rate[ rate ];
+                        break;
+                    }
+                case IEEE80211_MODE_11NA_HT20:
+                case IEEE80211_MODE_11NA_HT40PLUS:
+                case IEEE80211_MODE_11NA_HT40MINUS:
+                case IEEE80211_MODE_11NA_HT40:
+                    {
+                        ni->ni_fixed_rate = rate_val.na_rate[ rate ];
+                        break;
+                    }
+                case IEEE80211_MODE_11AC_VHT20:
+                case IEEE80211_MODE_11AC_VHT40PLUS:
+                case IEEE80211_MODE_11AC_VHT40MINUS:
+                case IEEE80211_MODE_11AC_VHT40:
+                case IEEE80211_MODE_11AC_VHT80:
+                case IEEE80211_MODE_11AC_VHT160:
+                case IEEE80211_MODE_11AC_VHT80_80:
+                    {
+                      ni->ni_fixed_rate = rate_val.ac_rate[ rate ];
+                      /* Get the MaxPower for the current Rate based on CBW */
+                      if ( IEEE80211_IS_CHAN_11AC_VHT20( ic->ic_curchan ) ) {
+                        rPwr = rate_val_pwr_20.ac_rate[ rate ];
+                      } else if ( IEEE80211_IS_CHAN_11AC_VHT40PLUS( ic->ic_curchan ) ||
+                          IEEE80211_IS_CHAN_11AC_VHT40MINUS( ic->ic_curchan ) ) {
+                        rPwr = rate_val_pwr_40.ac_rate[ rate ];
+                      } else if ( IEEE80211_IS_CHAN_11AC_VHT80( ic->ic_curchan )) {
+                        rPwr = rate_val_pwr_80.ac_rate[ rate ];
+                      }
+                      break;
+                    }
+                default:
+                    return;
+            }
+            ni->kwn_txrate = rate;
+            ic->ic_set_sta_fixed_rate( ni );
+            /* Apply Min( UserPower, RateMaxPower ) */
+            if ( rPwr != 0 ) {
+              rPwr = kwmin( rPwr, ni->kwn_txpwr );
+              if ( txchainmask == 3 )
+                rPwr += 3;
+              ic->ic_set_txPowerLimit( ic, 2 * rPwr, 2 * rPwr, is2GHz );
+              printk(": DDRS: rPwr: %d NiTxPwr: %d\n", rPwr, ni->kwn_txpwr);
+            }
+        }
+    }
+    else {
+        if( chan != -1 ) {
+            channel = ieee80211_find_dot11_channel( ic, chan, 0, wlan_get_current_phymode(vap) | ic->ic_chanbwflag );
+            printk("############### set channel %d %d ############# \n",channel->ic_ieee,channel->ic_freq);
+            ieee80211_set_channel( ic, channel );
+        }
+        if( pwr != -1 ) {
+            ni->kwn_txpwr = pwr;
+            if ( IEEE80211_IS_CHAN_11AC_VHT20( ic->ic_curchan ) ) {
+              rPwr = rate_val_pwr_20.ac_rate[ ni->kwn_txrate ];
+            } else if ( IEEE80211_IS_CHAN_11AC_VHT40PLUS( ic->ic_curchan ) ||
+                IEEE80211_IS_CHAN_11AC_VHT40MINUS( ic->ic_curchan ) ) {
+              rPwr = rate_val_pwr_40.ac_rate[ ni->kwn_txrate ];
+            } else if ( IEEE80211_IS_CHAN_11AC_VHT80( ic->ic_curchan )) {
+              rPwr = rate_val_pwr_80.ac_rate[ ni->kwn_txrate ];
+            }
+            /* Apply Min( UserPower, RateMaxPower ) */
+            if ( rPwr != 0 ) {
+              pwr = kwmin( pwr, rPwr );
+              if ( txchainmask == 3 )
+                pwr += 3;
+              ic->ic_set_txPowerLimit( ic, 2 * pwr, 2 * pwr, is2GHz );
+              printk(":ATPC: rPwr: %d NiTxPwr: %d\n", pwr, ni->kwn_txpwr);
+            }
+        }
+        if( rate != -1 ) {
+            switch( wlan_get_current_phymode(vap) )
+            {
+                case IEEE80211_MODE_11A:
+                case IEEE80211_MODE_TURBO_A:
+                    {
+                        ni->kwn_txrate = rate;
+                        ic->ic_kwn_vap_set_param( vap, IEEE80211_FIXED_RATE, rate_val.a_rate[ rate ] );
+                        break;
+                    }
+                case IEEE80211_MODE_11NA_HT20:
+                case IEEE80211_MODE_11NA_HT40PLUS:
+                case IEEE80211_MODE_11NA_HT40MINUS:
+                case IEEE80211_MODE_11NA_HT40:
+                    {
+                        ni->kwn_txrate = rate;
+                        ic->ic_kwn_vap_set_param( vap, IEEE80211_FIXED_RATE, rate_val.na_rate[ rate ] );
+                        break;
+                    }
+                case IEEE80211_MODE_11AC_VHT20:
+                case IEEE80211_MODE_11AC_VHT40PLUS:
+                case IEEE80211_MODE_11AC_VHT40MINUS:
+                case IEEE80211_MODE_11AC_VHT40:
+                case IEEE80211_MODE_11AC_VHT80:
+                case IEEE80211_MODE_11AC_VHT160:
+                case IEEE80211_MODE_11AC_VHT80_80:
+                    {
+                        ni->kwn_txrate = rate;
+                        ic->ic_kwn_vap_set_param( vap, IEEE80211_FIXED_VHT_MCS, rate_val.ac_rate[ rate ] );
+                        /* Get the MaxPower for the current Rate based on CBW */
+                        if ( IEEE80211_IS_CHAN_11AC_VHT20( ic->ic_curchan ) ) {
+                          rPwr = rate_val_pwr_20.ac_rate[ rate ];
+                        } else if ( IEEE80211_IS_CHAN_11AC_VHT40PLUS( ic->ic_curchan ) ||
+                            IEEE80211_IS_CHAN_11AC_VHT40MINUS( ic->ic_curchan ) ) {
+                          rPwr = rate_val_pwr_40.ac_rate[ rate ];
+                        } else if ( IEEE80211_IS_CHAN_11AC_VHT80( ic->ic_curchan )) {
+                          rPwr = rate_val_pwr_80.ac_rate[ rate ];
+                        }
+                        break;
+                    }
+                default:
+                    return;
+            }
+            /* Apply Min( UserPower, RateMaxPower ) */
+            if ( rPwr != 0 ) {
+              rPwr = kwmin( rPwr, ni->kwn_txpwr );
+              if ( txchainmask == 3 )
+                rPwr += 3;
+              ic->ic_set_txPowerLimit( ic, 2 * rPwr, 2 * rPwr, is2GHz );
+              printk(":DDRS: rPwr: %d NiTxPwr: %d\n", rPwr, ni->kwn_txpwr);
+            }
+        }
+    }
+}
 
 int
 ieee80211_send_action(
@@ -1183,21 +1578,218 @@
     break;
 
     case IEEE80211_ACTION_CAT_VHT: {
-        struct ieee80211_action_vht_opmode *opmode_frame;
+        struct ieee80211_action_vht_opmode *frame_opmode;
+        struct ieee80211_action_vht_dying_gasp *frame;
+        struct ieee80211_action_vht_link_param *frame_lmt;
+        struct ieee80211_action_vht_node_stats *frame_stats;
+        struct ieee80211_action_vht_tput_test *frame_tput;
+        struct ieee80211_action_vht_scan_entries *frame_scan;
+        struct ieee80211_action_vht_tx_params *frame_txparam;
+        struct ieee80211_action_vht_tput_test_stats *frame_tput_stats;
+        struct ieee80211_action_vht_txba_setup *frame_txba;
+        struct ieee80211_action_vht_clear_node_stats *frame_clear_node_stats;
+        struct ieee80211_stats *iv_stats;
+        struct net_device *dev;
         enum ieee80211_cwm_width cw_width = ic->ic_cwm_get_width(ic);
-        IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
-                           "%s: VHT Op Mode Notify action frame. Width %d Nss = %d",
-                            __func__, cw_width, vap->iv_nss);
-        wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
-        if (wbuf == NULL) {
-            error = -ENOMEM;
-            break;
-        }
-        opmode_frame = (struct ieee80211_action_vht_opmode *)frm;
-        opmode_frame->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
-        opmode_frame->at_header.ia_action  = IEEE80211_ACTION_VHT_OPMODE;
-        ieee80211_add_opmode((u_int8_t *)&opmode_frame->at_op_mode, ni, ic, IEEE80211_ACTION_CAT_VHT);
-        frm += sizeof(struct ieee80211_action_vht_opmode);
+       
+	switch (actionargs->action) { 
+		case IEEE80211_ACTION_DYING_GASP:
+			wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
+			if (wbuf == NULL) {
+				error = -ENOMEM;
+				break;
+			}
+			frame = (struct ieee80211_action_vht_dying_gasp *)frm;
+			frame->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame->at_header.ia_action  = IEEE80211_ACTION_DYING_GASP;
+			if ( actionargs->arg1 == 0 ) {
+				frame->at_dying_gasp.type = DG_PKT_TYPE_INFORM;
+				//frame->at_dying_gasp.ipv4 = get_default_ipaddr_by_devname("br-lan");
+				strncpy( frame->at_dying_gasp.ipv4, ic->ic_ipaddr, sizeof( ic->ic_ipaddr ) );
+				frame->at_dying_gasp.ts = jiffies;
+				frame->at_dying_gasp.seq_no = dg_seq++;
+				strncpy( frame->at_dying_gasp.link_id, ic->ic_link_id, 15 );
+				strncpy(frame->at_dying_gasp.customer_name,ic->ic_customer_name,32);
+			}
+			else if ( actionargs->arg1 == 1 ) {
+				frame->at_dying_gasp.type = DG_PKT_TYPE_ACK;
+			}
+			frm += sizeof(struct ieee80211_action_vht_dying_gasp);
+			break;
+		case IEEE80211_ACTION_LINK_PARAM:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_lmt = ( struct ieee80211_action_vht_link_param * )frm;
+			frame_lmt->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_lmt->at_header.ia_action  = IEEE80211_ACTION_LINK_PARAM;
+			//frame_lmt->at_uldl_limit.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			strncpy( frame_lmt->at_uldl_limit.ipv4, ic->ic_ipaddr, sizeof( ic->ic_ipaddr ) );
+            if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                frame_lmt->at_uldl_limit.ul_limit = vap->kwn_final_ul_limit;
+                frame_lmt->at_uldl_limit.dl_limit = vap->kwn_final_dl_limit;
+            }
+            else {
+                frame_lmt->at_uldl_limit.ul_limit = vap->kwn_ul_limit;
+                frame_lmt->at_uldl_limit.dl_limit = vap->kwn_dl_limit;
+            }
+			memcpy( frame_lmt->at_uldl_limit.customer_name, ic->ic_customer_name, sizeof( ic->ic_customer_name ) );
+			memcpy( frame_lmt->at_uldl_limit.link_id, ic->ic_link_id, sizeof( ic->ic_link_id ) );
+			frame_lmt->at_uldl_limit.antenna_gain = vap->kwn_antenna_gain;
+			frame_lmt->at_uldl_limit.kwn_assem_frag = vap->kwn_assem_frag;
+			frame_lmt->at_uldl_limit.kwn_max_pkt_size = vap->kwn_max_pkt_size;
+			frame_lmt->at_uldl_limit.kwn_frag_pkt_size = vap->kwn_frag_pkt_size;
+			frame_lmt->at_uldl_limit.kwn_macinmac = ic->kwn_macinmac;
+			frame_lmt->at_uldl_limit.kwn_linktype = ic->kwn_linktype;
+			frame_lmt->at_uldl_limit.kwn_shaping = vap->kwn_traffic_shaping;
+			frm += sizeof( struct ieee80211_action_vht_link_param );
+			break;
+		case IEEE80211_ACTION_NODE_STATS:
+			iv_stats = wlan_get_stats(vap);
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_stats = ( struct ieee80211_action_vht_node_stats * )frm;
+			frame_stats->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_stats->at_header.ia_action  = IEEE80211_ACTION_NODE_STATS;
+			//frame_stats->at_node_stats.ipv4 = get_default_ipaddr_by_devname("br-lan");
+			strncpy( frame_stats->at_node_stats.ipv4, ic->ic_ipaddr, sizeof( ic->ic_ipaddr ) );
+			frame_stats->at_node_stats.snr_avg[0] = ni->kwn_snr_avg.local_snr_avg[0];
+			frame_stats->at_node_stats.snr_avg[1] = ni->kwn_snr_avg.local_snr_avg[1];
+			frame_stats->at_node_stats.noise_floor = vap->kwn_local_noise_floor;
+            if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                frame_stats->at_node_stats.rx_tput_mbps = ni->tx_tput_mbps;
+            } else {
+                frame_stats->at_node_stats.rx_tput_mbps = iv_stats->kwn_tx_tput_mbps;
+                //frame_stats->at_node_stats.tx_tput_mbps = iv_stats->kwn_rx_tput_mbps;
+            }
+			frame_stats->at_node_stats.phy_err = vap->kwn_local_phy_err;
+			frame_stats->at_node_stats.mpdu_err = vap->kwn_local_mpdu_err;
+			frame_stats->at_node_stats.retries = ni->kwn_remote_retries;
+			frame_stats->at_node_stats.rtx = ni->kwn_local_rtx;
+            frame_stats->at_node_stats.tx_pwr = 
+                ( ni->kwn_profile_cfg.txparam.atpc_status == 1 ? ni->kwn_profile_cfg.atpc_power : ni->kwn_profile_cfg.txparam.power );
+            frame_stats->at_node_stats.tx_chainmask = ieee80211com_get_tx_chainmask( ic );
+            frame_stats->at_node_stats.stream = ni->kwn_profile_cfg.txparam.spatial_stream;
+            frame_stats->at_node_stats.tx_data = ni->ni_stats.ns_tx_data;
+            frame_stats->at_node_stats.rx_data = ni->ni_stats.ns_rx_data;
+            frm += sizeof( struct ieee80211_action_vht_node_stats );
+			break;
+		case IEEE80211_ACTION_TPUT_TEST:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_tput = ( struct ieee80211_action_vht_tput_test * )frm;
+			frame_tput->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_tput->at_header.ia_action  = IEEE80211_ACTION_TPUT_TEST;
+			strncpy( frame_tput->at_tput_test.ipv4, ic->ic_ipaddr, sizeof( ic->ic_ipaddr ) );
+			frame_tput->at_tput_test.start_stop = vap->kwn_tput_test_in_progress;
+			frame_tput->at_tput_test.duration = vap->kwn_tput_test_duration;
+			frame_tput->at_tput_test.pkt_size = vap->kwn_tput_test_pkt_size;
+			frame_tput->at_tput_test.cnt = vap->kwn_tput_test_pkt_per_ms;
+			frame_tput->at_tput_test.pkt_cnt = vap->kwn_tput_test_pkt_per_s;
+			frame_tput->at_tput_test.ms_timer = vap->kwn_tput_test_ms_timer;
+			frm += sizeof( struct ieee80211_action_vht_tput_test );
+			break;
+		case IEEE80211_ACTION_SCAN_ENTRIES:
+            dev = dev_get_by_name( &init_net, "ath1" );
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_scan = ( struct ieee80211_action_vht_scan_entries * )frm;
+			frame_scan->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_scan->at_header.ia_action  = IEEE80211_ACTION_SCAN_ENTRIES;
+            ieee80211_get_scanentries( dev, frame_scan );
+			frm += sizeof( struct ieee80211_action_vht_scan_entries );
+            dev_put( dev );
+			break;
+		case IEEE80211_ACTION_TX_PARAMS:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_txparam = ( struct ieee80211_action_vht_tx_params * )frm;
+			frame_txparam->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_txparam->at_header.ia_action  = IEEE80211_ACTION_TX_PARAMS;
+			frame_txparam->at_tx_param.chan = ni->kwn_rxchan;
+			frame_txparam->at_tx_param.txpower = ni->kwn_rxpwr;
+			frame_txparam->at_tx_param.rate = ni->kwn_rxrate;
+			frm += sizeof( struct ieee80211_action_vht_tx_params );
+			break;
+		case IEEE80211_ACTION_TPUT_TEST_STATS:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_tput_stats = ( struct ieee80211_action_vht_tput_test_stats * )frm;
+			frame_tput_stats->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_tput_stats->at_header.ia_action  = IEEE80211_ACTION_TPUT_TEST_STATS;
+      if( vap->kwn_tput_test_user_started ) {
+        frame_tput_stats->at_tput_test_stats.rx_seq = 0;
+        frame_tput_stats->at_tput_test_stats.rx_failed_cnt = 0;
+        printk(": TPUT: Get TPUT Test Stats\n");
+      }
+      else {
+        frame_tput_stats->at_tput_test_stats.rx_seq = vap->kwn_tput_test_rxseq;
+        frame_tput_stats->at_tput_test_stats.rx_failed_cnt = vap->kwn_tput_test_rx_failed_cnt;
+        printk(": TPUT: Send TPUT Test Stats: %llu %llu\n", vap->kwn_tput_test_rxseq, vap->kwn_tput_test_rx_failed_cnt);
+      }
+      frm += sizeof( struct ieee80211_action_vht_tput_test_stats );
+			break;
+		case IEEE80211_ACTION_TXBA_SETUP:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_txba = ( struct ieee80211_action_vht_txba_setup * )frm;
+			frame_txba->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_txba->at_header.ia_action  = IEEE80211_ACTION_TXBA_SETUP;
+			frame_txba->at_txba_setup.start_txba = 1;
+			frame_txba->at_txba_setup.pkt_per_ms = vap->kwn_tput_test_pkt_per_ms;
+			frame_txba->at_txba_setup.pkt_size = vap->kwn_tput_test_pkt_size;
+			frm += sizeof( struct ieee80211_action_vht_txba_setup );
+			break;
+        case IEEE80211_ACTION_CLEAR_NODE_STATS:
+			wbuf = ieee80211_getmgtframe( ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0 );
+			if( wbuf == NULL ) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_clear_node_stats = ( struct ieee80211_action_vht_clear_node_stats * )frm;
+			frame_clear_node_stats->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_clear_node_stats->at_header.ia_action  = IEEE80211_ACTION_CLEAR_NODE_STATS;
+			frame_clear_node_stats->at_clear_node_stats.clear_node_stats = 1;
+			frm += sizeof( struct ieee80211_action_vht_clear_node_stats );
+            break;
+		case IEEE80211_ACTION_VHT_OPMODE:
+			IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
+					"%s: VHT Op Mode Notify action frame. Width %d Nss = %d",
+					__func__, cw_width, vap->iv_nss);
+			wbuf = ieee80211_getmgtframe(ni, IEEE80211_FC0_SUBTYPE_ACTION, &frm, 0);
+			if (wbuf == NULL) {
+				error = -ENOMEM;
+				break;
+			}
+			frame_opmode = (struct ieee80211_action_vht_opmode *)frm;
+			frame_opmode->at_header.ia_category = IEEE80211_ACTION_CAT_VHT;
+			frame_opmode->at_header.ia_action  = IEEE80211_ACTION_VHT_OPMODE;
+			ieee80211_add_opmode((u_int8_t *)&frame_opmode->at_op_mode, ni, ic, IEEE80211_ACTION_CAT_VHT);
+			frm += sizeof(struct ieee80211_action_vht_opmode);	
+			break;
+		default :
+			break;
+	}
     }
     break;
 
@@ -2241,6 +2833,7 @@
 }
 int
 ieee80211_parse_beacon(struct ieee80211vap                  *vap,
+		       struct ieee80211_node *ni,
                        struct ieee80211_beacon_frame        *beacon_frame,
                        const struct ieee80211_frame         *wh,
                        u_int32_t                            beacon_frame_length,
@@ -2404,6 +2997,9 @@
             scan_entry_parameters->ie_list.htcap = (u_int8_t *) &(((struct ieee80211_ie_htcap *) info_element)->hc_ie);
             break;
         case IEEE80211_ELEMID_RESERVED_47:
+		//printk(" subtype = %d ,latitude recieved: %s\n",subtype,(u_int8_t *)((struct ieee80211_ie_gps* )info_element)->hc_coordinates);
+		if ( ni != NULL )
+		   strncpy(ni->ni_latitude,((struct ieee80211_ie_gps* )info_element)->hc_coordinates,32);
             break;
         case IEEE80211_ELEMID_RSN:
             scan_entry_parameters->ie_list.rsn = (u_int8_t *) info_element;
@@ -2435,6 +3031,9 @@
             scan_entry_parameters->ie_list.extcaps = (u_int8_t *) info_element;
             break;
         case IEEE80211_ELEMID_RESERVED_133:
+		//printk(" subtype: %d longitude recieved: %s\n",subtype,(u_int8_t *)((struct ieee80211_ie_gps* )info_element)->hc_coordinates);
+		if ( ni != NULL )
+		   strncpy(ni->ni_longitude,((struct ieee80211_ie_gps* )info_element)->hc_coordinates,32);
             break;
         case IEEE80211_ELEMID_TPC:
             break;
@@ -2596,6 +3195,23 @@
 
                 break;
             }
+        case IEEE80211_ELEMID_LINKTYPE:
+            {
+                scan_entry_parameters->kwn_linktype = ((struct ieee80211_erp_ie *) info_element)->value;
+                if ( ni != NULL ) {
+                    ni->kwn_linktype = ((struct ieee80211_erp_ie *) info_element)->value;
+                    //printk("##########Local Link Type %d Remote Link Type %d \n",ic->kwn_linktype,ni->kwn_linktype);
+                    if( ic->kwn_linktype != 0 && ni->kwn_linktype != 0 ) {
+                        if( ( ni->kwn_linktype != KWN_LINKTYPE_PTMP_TDMA && ni->kwn_linktype != KWN_LINKTYPE_PTMP ) && 
+                                ic->kwn_linktype != ni->kwn_linktype )
+                        {
+                            //printk("Beacon Failed: Local Link Type %d Remote Link Type %d \n",ic->kwn_linktype,ni->kwn_linktype);
+                            return -EINVAL;
+                        }
+                    }
+                }
+            }
+            break;
         default:
             IEEE80211_DISCARD_IE(vap, IEEE80211_MSG_ELEMID,
                                  "unhandled",
@@ -2864,6 +3480,7 @@
     }
 
     scan_entry = ieee80211_scan_table_update(ni->ni_vap,
+					     ni,
                                              wh,
                                              wbuf_get_pktlen(wbuf),
                                              subtype,
@@ -3825,13 +4442,297 @@
 
                     ieee80211_parse_opmode(ni, (u_int8_t *)&ia_opmode->at_op_mode, subtype);
                 }
+                action_taken = FALSE;// set to false so that it is forwarded to hostapd
+                break;
+            case IEEE80211_ACTION_DYING_GASP: 
+                {
+                    struct ieee80211_action_vht_dying_gasp *frame = (struct ieee80211_action_vht_dying_gasp *)frm;
+                    u_int8_t ip[20];
+
+                    if(frame->at_dying_gasp.type == DG_PKT_TYPE_INFORM ) {
+                        /* Step1: Send ACK to SU from AP */
+                        if (vap->iv_opmode == IEEE80211_M_HOSTAP && !vap->iv_ic->ic_dg_ack_disable) {
+                            ieee80211_send_dying_gasp( vap , 1, ni );
+                        }
+
+                        /* Step2: Syslog */
+                        strncpy( ip, frame->at_dying_gasp.ipv4, sizeof( frame->at_dying_gasp.ipv4 ) );
+                        if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                            printk("(%9lu) Outdoor Subscriber Power Off [ Time stamp : %9lu][Cus name:%s][Link id:%s][%s] Seq No:%d --> Recv pkts %d \n",
+                                    jiffies,frame->at_dying_gasp.ts, frame->at_dying_gasp.customer_name,frame->at_dying_gasp.link_id,
+                                    ip,frame->at_dying_gasp.seq_no,ni->dg_count++);
+                        }
+                        else {
+                            printk("(%9lu) Outdoor Base Power Off [ Time stamp : %9lu][Cus name:%s][Link id:%s][%s] Seq No:%d --> Recv pkts %d \n",
+                                    jiffies,frame->at_dying_gasp.ts, frame->at_dying_gasp.customer_name,frame->at_dying_gasp.link_id,
+                                    ip,frame->at_dying_gasp.seq_no,ni->dg_count++);
+                        }
+
+                        /* Step3: Application Event Log & SU Dis-assoc in AP */
+                        if( ni->dg_count == 1 ) {
+                            struct net_device *dev = dev_get_by_name(&init_net,"ath1");
+                            union iwreq_data wreq = {{0}};
+                            memset(&wreq, 0, sizeof(wreq));
+                            wreq.addr.sa_family = ARPHRD_ETHER;
+                            memcpy(wreq.addr.sa_data, ni->ni_macaddr, 6);
+                            if( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                                wreq.addr.sa_data[6] = IEEE80211_EV_DYING_GASP_AP;
+                                wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+                                wlan_mlme_disassoc_request( vap, ni->ni_macaddr, IEEE80211_REASON_UNSPECIFIED );
+                            } else {
+                                wreq.addr.sa_data[6] = IEEE80211_EV_DYING_GASP_SU;
+                                wireless_send_event(dev, IWEVEXPIRED, &wreq, NULL);
+                            }
+                            dev_put(dev);
+                        }
+                    }
+                    else if (frame->at_dying_gasp.type == DG_PKT_TYPE_ACK ) {
+                        dg_ack_rcvd = 1;
+                    }
+                }
+                break;
+            case IEEE80211_ACTION_LINK_PARAM: 
+                {
+                    struct ieee80211_action_vht_link_param *frame_lmt = (struct ieee80211_action_vht_link_param *)frm;
+                    u_int8_t ip[20];
+
+                    strncpy( ip, frame_lmt->at_uldl_limit.ipv4, sizeof( frame_lmt->at_uldl_limit.ipv4 ) );
+                    /* printk("######### Received [Uplink Limit:%d][Downlink Limit:%d][%s] ##############\n",
+                       frame_lmt->at_uldl_limit.ul_limit,frame_lmt->at_uldl_limit.dl_limit,ip); */
+                    if ( vap->iv_opmode == IEEE80211_M_HOSTAP ) {
+                        ni->kwn_remote_shaping = frame_lmt->at_uldl_limit.kwn_shaping;
+                        if( vap->kwn_traffic_shaping == 1 && ni->kwn_remote_shaping == 1 ) {
+                            ni->kwn_traffic_shaping = 1;
+                            ni->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit > vap->kwn_ul_limit ? 
+                                vap->kwn_ul_limit : frame_lmt->at_uldl_limit.ul_limit;
+                            ni->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit > vap->kwn_dl_limit ? 
+                                vap->kwn_dl_limit : frame_lmt->at_uldl_limit.dl_limit;
+                        }
+                        else if( vap->kwn_traffic_shaping == 1 ) {
+                            ni->kwn_traffic_shaping = 1;
+                            ni->kwn_ul_limit = vap->kwn_ul_limit;
+                            ni->kwn_dl_limit = vap->kwn_dl_limit;
+                        }
+                        else if( ni->kwn_remote_shaping == 1 ) {
+                            ni->kwn_traffic_shaping = 1;
+                            ni->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit;
+                            ni->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit;
+                        }
+                        vap->kwn_final_ul_limit = ni->kwn_ul_limit;
+                        vap->kwn_final_dl_limit = ni->kwn_dl_limit;
+                        ieee80211_send_link_params( vap, ni );
+                        if( ic->kwn_linktype == KWN_LINKTYPE_PTMP_TDMA ) {
+                            ic->ic_kwn_set_qboost( vap, ic, ni, 1 );
+                        }
+                        else {
+                            ic->ic_kwn_set_qboost( vap, ic, ni, 0 );
+                        }
+                    }
+                    else {
+                        ni->kwn_traffic_shaping = vap->kwn_traffic_shaping;
+                        ni->kwn_remote_shaping = frame_lmt->at_uldl_limit.kwn_shaping;
+                        ni->kwn_ul_limit = frame_lmt->at_uldl_limit.ul_limit;
+                        ni->kwn_dl_limit = frame_lmt->at_uldl_limit.dl_limit;
+                        vap->kwn_final_ul_limit = ni->kwn_ul_limit;
+                        vap->kwn_final_dl_limit = ni->kwn_dl_limit;
+                        vap->kwn_assem_frag = frame_lmt->at_uldl_limit.kwn_assem_frag;
+                        vap->kwn_max_pkt_size = frame_lmt->at_uldl_limit.kwn_max_pkt_size;
+                        vap->kwn_frag_pkt_size = frame_lmt->at_uldl_limit.kwn_frag_pkt_size;
+                        if( frame_lmt->at_uldl_limit.kwn_linktype == KWN_LINKTYPE_PTMP_TDMA ) {
+                            ic->ic_kwn_set_qboost( vap, ic, ni, 1 );
+                        }
+                        else {
+                            ic->ic_kwn_set_qboost( vap, ic, ni, 0 );
+                        }
+                        /* Free Link Param exchange timer as BSU link parameters received on SU */
+                        OS_FREE_TIMER( &ni->kwn_link_timer );
+                    }
+                    memcpy(ni->customer_name, frame_lmt->at_uldl_limit.customer_name, sizeof(frame_lmt->at_uldl_limit.customer_name));
+                    memcpy(ni->link_id, frame_lmt->at_uldl_limit.link_id, sizeof(frame_lmt->at_uldl_limit.link_id));
+                    ni->kwn_antenna_gain = frame_lmt->at_uldl_limit.antenna_gain;
+                    ni->kwn_macinmac = frame_lmt->at_uldl_limit.kwn_macinmac;
+                    printk("After negotiation[%s], Traffic Shaping: %d Uplink Limit: %d Downlink Limit: %d \n",
+                            ip, ni->kwn_traffic_shaping, vap->kwn_final_ul_limit, vap->kwn_final_dl_limit );
+                }
+                break;
+            case IEEE80211_ACTION_NODE_STATS: 
+                {
+                    struct ieee80211_action_vht_node_stats *frame_stats = (struct ieee80211_action_vht_node_stats *)frm;
+#if 0
+                    u_int8_t ip[20];
+                    strncpy( ip, frame_stats->at_node_stats.ipv4, sizeof( frame_stats->at_node_stats.ipv4 ) );
+                    printk("######### Received Local [SNR1:%d][SNR2:%d] Remote [SNR1:%d][SNR2:%d][%s] ##############\n",
+                            vap->local_snr_a1,vap->local_snr_a2,
+                            frame_stats->at_node_stats.snr_a1,frame_stats->at_node_stats.snr_a2,ip);
+#endif
+                    ni->kwn_snr_avg.remote_snr_avg[0] = frame_stats->at_node_stats.snr_avg[0];
+                    ni->kwn_snr_avg.remote_snr_avg[1] = frame_stats->at_node_stats.snr_avg[1];
+                    ni->remote_noise_floor = frame_stats->at_node_stats.noise_floor;
+                    strncpy( ni->ip_addr, frame_stats->at_node_stats.ipv4, sizeof( frame_stats->at_node_stats.ipv4 ) );
+                    //ni->rx_tput_mbps = frame_stats->at_node_stats.rx_tput_mbps;
+                    //ni->tx_tput_mbps = frame_stats->at_node_stats.tx_tput_mbps;
+                    ni->remote_phy_err = frame_stats->at_node_stats.phy_err;
+                    ni->remote_mpdu_err = frame_stats->at_node_stats.mpdu_err;
+                    ni->kwn_local_retries = frame_stats->at_node_stats.retries;
+                    ni->kwn_remote_rtx = frame_stats->at_node_stats.rtx;
+                    ni->kwn_remote_tx_pwr = frame_stats->at_node_stats.tx_pwr;
+                    ni->kwn_remote_tx_chainmask = frame_stats->at_node_stats.tx_chainmask;
+                    ni->kwn_remote_stream = frame_stats->at_node_stats.stream;
+                    ni->kwn_remote_tx_data = frame_stats->at_node_stats.tx_data;
+                    ni->kwn_remote_rx_data = frame_stats->at_node_stats.rx_data;
+                }
+                break;
+            case IEEE80211_ACTION_TPUT_TEST: 
+                {
+                    struct ieee80211_action_vht_tput_test *frame_tput = (struct ieee80211_action_vht_tput_test *)frm;
+                    if ( frame_tput->at_tput_test.start_stop ) {
+                        printk("\n Start Test ...\n");
+                        IEEE80211_ADDR_COPY(vap->kwn_tput_test_mac, ni->ni_macaddr);
+                        vap->kwn_tput_test_duration = frame_tput->at_tput_test.duration;
+                        vap->kwn_tput_test_pkt_size = frame_tput->at_tput_test.pkt_size;
+                        vap->kwn_tput_test_pkt_per_ms = frame_tput->at_tput_test.cnt;
+                        vap->kwn_tput_test_pkt_per_s = frame_tput->at_tput_test.pkt_cnt;
+                        vap->kwn_tput_test_ms_timer = frame_tput->at_tput_test.ms_timer;
+                        printk(": TPUT: Pkt per ms %d %d %d \n",vap->kwn_tput_test_pkt_per_ms, vap->kwn_tput_test_pkt_per_s, 
+                                vap->kwn_tput_test_ms_timer);
+                        vap->kwn_tput_test_start_time = jiffies;
+                        vap->kwn_tput_test_in_progress = 1;
+                        ni->kwn_tput_running = 1;
+                        vap->kwn_tput_test_from_app = 1;
+                        vap->kwn_tput_test_txseq = 0;
+                        vap->kwn_tput_test_rxseq = 0;
+                        vap->kwn_tput_test_pkt_timer = 0;
+                        vap->kwn_tput_test_pkt_count = 0;
+                        vap->kwn_tput_test_rx_failed_cnt = 0;
+                        OS_SET_TIMER(&vap->kwn_tput_timer, vap->kwn_tput_test_ms_timer);
+                    } else {
+                        printk("\n Stop Test...\n");
+                        vap->kwn_tput_test_start_time = 0;
+                        vap->kwn_tput_test_in_progress = 0;
+                        vap->kwn_tput_test_from_app = 0;
+                        ni->kwn_tput_running = 0;
+                    }
+                }
+                break;
+            case IEEE80211_ACTION_SCAN_ENTRIES: 
+                {
+                    int i;
+                    struct ieee80211_action_vht_scan_entries *frame_scan = ( struct ieee80211_action_vht_scan_entries * )frm;
+                    for( i = 0; i < frame_scan->at_scan_entry.count; i++ )
+                    {
+                        printk(": Link: Received Scan entry Channel: %d %d RSSI:%d\n",
+                                frame_scan->at_scan_entry.entry[i].channel, frame_scan->at_scan_entry.entry[i].frequency, frame_scan->at_scan_entry.entry[i].rssi);
+                    }
+                    /* TODO: Channel can get changed based on best channel selection algorithm */
+                    //ieee80211_apply_txparams( vap, ni, frame_scan->at_scan_entry.entry[i].channel, -1, -1 );
+                }
+                break;
+            case IEEE80211_ACTION_TX_PARAMS: 
+                {
+                    struct ieee80211_action_vht_tx_params *frame_txparam = ( struct ieee80211_action_vht_tx_params * )frm;
+                    printk(": Link: Received Tx Params Chan:%d Power:%d Rate:%d\n",
+                            frame_txparam->at_tx_param.chan, frame_txparam->at_tx_param.txpower,
+                            frame_txparam->at_tx_param.rate);
+                    ieee80211_apply_txparams( vap, ni, frame_txparam->at_tx_param.chan, frame_txparam->at_tx_param.rate, frame_txparam->at_tx_param.txpower );
+                }
+                break;
+            case IEEE80211_ACTION_TPUT_TEST_STATS: 
+                {
+                    struct ieee80211_action_vht_tput_test_stats *frame_tput_stats = (struct ieee80211_action_vht_tput_test_stats *)frm;
+                    u_int64_t failed_cnt = 0;
+                    u_int8_t curr_iter = 0;
+
+                    if( vap->kwn_tput_test_user_started ) {
+                        OS_CANCEL_TIMER(&vap->kwn_tput_timer_fr);
+                        printk("\n\n");
+                        printk(": TPUT: Tx Seq : %llu Received Rx Seq %llu and Failed cnt %llu \n",vap->kwn_tput_test_txseq, frame_tput_stats->at_tput_test_stats.rx_seq,
+                                frame_tput_stats->at_tput_test_stats.rx_failed_cnt);
+
+                        failed_cnt = frame_tput_stats->at_tput_test_stats.rx_failed_cnt;
+                        /* Update the failed counter is rx_seq is not updated from remote-end */
+                        if ( frame_tput_stats->at_tput_test_stats.rx_seq == 0 )
+                            failed_cnt = 1;
+                        curr_iter = vap->kwn_tput_test_curr_iter;
+
+                        if( vap->kwn_tput_test_curr_iter == vap->kwn_tput_test_max_iter_cnt - 1 ) {
+                            printk(": TPUT: Stop Test...\n");
+                            printk(": TPUT: Cancel Timer\n");
+                            OS_CANCEL_TIMER(&vap->kwn_tput_timer);
+                            vap->kwn_tput_test_user_started = 0;
+                            vap->kwn_tput_test_start_time = 0;
+                            vap->kwn_tput_test_in_progress = 0;
+                            vap->kwn_tput_test_from_app = 0;
+                            vap->kwn_tput_test_txseq = 0;
+                            vap->kwn_tput_test_rxseq = 0;
+                            vap->kwn_tput_test_rx_failed_cnt = 0;
+                            vap->kwn_tput_test_max_iter_cnt = 0;
+                            vap->kwn_tput_test_curr_iter = 0;
+                            ni->kwn_tput_running = 0;
+                            break;
+                        }
+                        printk(": TPUT: Response: Before Low %d Up %d PktPerS %d PktPerMs: %d \n",vap->kwn_tput_test_low_pktpers,vap->kwn_tput_test_up_pktpers,vap->kwn_tput_test_pkt_per_s, vap->kwn_tput_test_pkt_per_ms);
+                        /* Calculate PktPerS based on failed Count and limit it to MaxPktPerS */
+                        if( failed_cnt == 0 ) {
+                            vap->kwn_tput_test_low_pktpers = vap->kwn_tput_test_pkt_per_s;
+                            if( vap->kwn_tput_test_up_pktpers == 0 ) {
+                                if ( ( vap->kwn_tput_test_low_pktpers * 2 ) <= vap->kwn_tput_test_max_pkt_per_s )
+                                    vap->kwn_tput_test_pkt_per_s = vap->kwn_tput_test_low_pktpers * 2;
+                                else
+                                    vap->kwn_tput_test_pkt_per_s = vap->kwn_tput_test_max_pkt_per_s;
+                            }
+                            else {
+                                vap->kwn_tput_test_pkt_per_s = (uint32_t) ( ( vap->kwn_tput_test_low_pktpers + vap->kwn_tput_test_up_pktpers ) / 2 );
+                            }
+                        }
+                        else {
+                            vap->kwn_tput_test_up_pktpers = vap->kwn_tput_test_pkt_per_s;
+                            if( vap->kwn_tput_test_low_pktpers == 0 ) {
+                                vap->kwn_tput_test_pkt_per_s = (uint32_t) ( vap->kwn_tput_test_up_pktpers / 2 );
+                            }
+                            else {
+                                vap->kwn_tput_test_pkt_per_s = (uint32_t) ( ( vap->kwn_tput_test_low_pktpers + vap->kwn_tput_test_up_pktpers ) / 2 );
+                            }
+                        }
+
+                        /* Calculate PktPerMs based on PktPerS */
+                        vap->kwn_tput_test_pkt_per_ms = (vap->kwn_tput_test_pkt_per_s / 1000);
+                        vap->kwn_tput_test_pkt_per_ms++;
+                        OS_SET_TIMER(&vap->kwn_tput_timer_fr, 1000);
+                        printk(": TPUT: Response: After Low %d Up %d PktPerS %d PktPerMs: %d \n",vap->kwn_tput_test_low_pktpers,vap->kwn_tput_test_up_pktpers,vap->kwn_tput_test_pkt_per_s, vap->kwn_tput_test_pkt_per_ms);
+                        printk("\n\n");
+                    }
+                    else {
+                        printk(": TPUT: Received Get request...Send TPUT Test Stats\n");
+                        ieee80211_tput_test_stats( vap, ni );
+                    }
+                }
+                break;
+            case IEEE80211_ACTION_TXBA_SETUP: 
+                {
+                    struct ieee80211_action_vht_txba_setup *frame_txba = ( struct ieee80211_action_vht_txba_setup * )frm;
+                    if( frame_txba->at_txba_setup.start_txba && !ni->kwn_txbasetup ) {
+                        vap->kwn_tput_test_pkt_per_ms = frame_txba->at_txba_setup.pkt_per_ms;
+                        vap->kwn_tput_test_pkt_size = frame_txba->at_txba_setup.pkt_size;
+                        ni->kwn_txbasetup = 1;
+                        printk("Start Tx BA Setup %s\n",ether_sprintf(ni->ni_macaddr));
+                        OS_SET_TIMER( &ni->kwn_txba_timer, 1000 );
+                    }
+                }
+                break;
+            case IEEE80211_ACTION_CLEAR_NODE_STATS:
+                {
+                    struct ieee80211_action_vht_clear_node_stats *frame_clear_node_stats = ( struct ieee80211_action_vht_clear_node_stats * )frm;
+                    if( frame_clear_node_stats->at_clear_node_stats.clear_node_stats == 1 )
+                    {
+                        ni->kwn_remote_retries = 0;
+                    }
+                }
                 break;
             default:
                 IEEE80211_NOTE(vap, IEEE80211_MSG_ACTION, ni,
                         "%s: Unhandled OR invalid VHT action code - %d", __func__, ia->ia_action);
                 break;
         }
-        action_taken = FALSE; // set to false so that it is forwarded to hostapd
         break;
     }
 
@@ -4002,6 +4903,10 @@
     switch (subtype) {
     case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
     case IEEE80211_FC0_SUBTYPE_BEACON:
+#ifdef SIFY_MGMT_STATS
+        if( subtype == IEEE80211_FC0_SUBTYPE_BEACON )
+            vap->iv_mgmt_stats.bcn_recv++;
+#endif
         ieee80211_recv_beacon(ni, wbuf, subtype, rs);
         /*store all received beacon info*/
         if(vap->iv_beacon_info_count>=100)
@@ -4092,6 +4997,9 @@
         break;
 
     case IEEE80211_FC0_SUBTYPE_AUTH:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.aut_recv++;
+#endif
 #if ATH_NON_BEACON_AP
         if(IEEE80211_VAP_IS_NON_BEACON_ENABLED(vap)){
             /*Don't response to auth for non-beaconing AP VAP*/
@@ -4107,10 +5015,34 @@
     case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
     case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:
         ieee80211_recv_asresp(ni, wbuf, subtype);
-        break;
+	/* Configure MgmtVLAN if enabled */
+	{
+
+		struct net_device *eth_dev;
+		int vlan = 0;
+		eth_dev = dev_get_by_name( &init_net, "eth0" );
+		if ( eth_dev ) {
+			vlan = edma_get_mgmt_vlan_id( eth_dev );
+			printk(": MgmtVlan: %d Vlan: %d\n", vap->kwn_mgmt_vlan_id, vlan);
+			vap->kwn_mgmt_vlan_id = vlan;
+			memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+			printk(": Eth0MAC: %0x:%0x:%0x:%0x:%0x:%0x \n",
+					vap->kwn_eth_mac_addr[0],
+					vap->kwn_eth_mac_addr[1],
+					vap->kwn_eth_mac_addr[2],
+					vap->kwn_eth_mac_addr[3],
+					vap->kwn_eth_mac_addr[4],
+					vap->kwn_eth_mac_addr[5]);
+			dev_put( eth_dev );
+		}
+	}
+	break;
 
     case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
     case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.assoc_recv++;
+#endif
 #if ATH_NON_BEACON_AP
         if(IEEE80211_VAP_IS_NON_BEACON_ENABLED(vap)){
             /*Don't response to auth for non-beaconing AP VAP*/
@@ -4158,13 +5090,40 @@
 #endif
         if (ieee80211_recv_asreq(ni, wbuf, subtype) == -EBUSY)
             forward_to_filter = 0;
-        break;
+	/* Configure MgmtVLAN if enabled */
+	{
+
+		struct net_device *eth_dev;
+		int vlan = 0;
+		eth_dev = dev_get_by_name( &init_net, "eth0" );
+		if ( eth_dev ) {
+			vlan = edma_get_mgmt_vlan_id( eth_dev );
+			printk(": MgmtVlan: %d Vlan: %d\n", vap->kwn_mgmt_vlan_id, vlan);
+			vap->kwn_mgmt_vlan_id = vlan;
+			memcpy(vap->kwn_eth_mac_addr, eth_dev->dev_addr, 6);
+			printk(": Eth0MAC: %0x:%0x:%0x:%0x:%0x:%0x \n",
+					vap->kwn_eth_mac_addr[0],
+					vap->kwn_eth_mac_addr[1],
+					vap->kwn_eth_mac_addr[2],
+					vap->kwn_eth_mac_addr[3],
+					vap->kwn_eth_mac_addr[4],
+					vap->kwn_eth_mac_addr[5]);
+			dev_put( eth_dev );
+		}
+	}
+	break;
 
     case IEEE80211_FC0_SUBTYPE_DEAUTH:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.deaut_recv++;
+#endif
         ieee80211_recv_deauth(ni, wbuf, subtype);
         break;
 
     case IEEE80211_FC0_SUBTYPE_DISASSOC:
+#ifdef SIFY_MGMT_STATS
+                vap->iv_mgmt_stats.disassoc_recv++;
+#endif
         ret = ieee80211_recv_disassoc(ni, wbuf, subtype);
         if(ret){
             /*Something wrong, don't fwd to filter*/
diff -urN qca-wifi-org/umac/mlme/ieee80211_mgmt_sta.c qca-wifi-mod/umac/mlme/ieee80211_mgmt_sta.c
--- qca-wifi-org/umac/mlme/ieee80211_mgmt_sta.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mgmt_sta.c	2018-08-22 16:31:38.123887700 +0530
@@ -1074,6 +1074,17 @@
 	frm = ieee80211_add_extender_ie(vap, IEEE80211_FRAME_TYPE_ASSOCREQ, frm);
     }
 #endif
+     /* Update latitude and longitude info if valid*/
+    if ( (strlen(ic->ic_latitude) != 0 ) && (strlen(ic->ic_longitude) != 0 ) ) {	
+	    *frm++ = IEEE80211_ELEMID_RESERVED_47;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_latitude,32);
+	    frm += 32;
+	    *frm++ = IEEE80211_ELEMID_RESERVED_133;
+	    *frm++ = 32;
+	    strncpy(frm,ic->ic_longitude,32);
+	    frm += 32;
+    }
 
     return (frm - (u_int8_t *)wh);
 }
@@ -1094,6 +1105,9 @@
     if (wbuf == NULL)
         return -ENOMEM;
 
+#ifdef SIFY_MGMT_STATS
+        vap->iv_mgmt_stats.assoc_xmit++;
+#endif
     length = ieee80211_setup_assoc(ni, (struct ieee80211_frame *)wbuf_header(wbuf),
                                    reassoc, prev_bssid);
 
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme_ap.c qca-wifi-mod/umac/mlme/ieee80211_mlme_ap.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme_ap.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme_ap.c	2019-02-27 17:53:42.910823699 +0530
@@ -33,6 +33,7 @@
     u_int8_t                      flag=0;
     u_int8_t                      node_leave = 0,isvht;
     int                           status = 0;
+    int is2GHz = IEEE80211_IS_CHAN_2GHZ( ic->ic_curchan );
 
     /* AP  must be up and running */
     if (!mlme_priv->im_connection_up || ieee80211_vap_ready_is_clear(vap)) {
@@ -251,6 +252,17 @@
     }
 
 end:
+#ifdef SIFY_MGMT_STATS  
+    if (assocstatus != IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.assoc_reject_xmit++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.assoc_confirm_xmit++;
+    }
+    vap->iv_mgmt_stats.assoc_reason = assocstatus;
+#endif
     /* Now send the notification and remove the node if needed */
     if (reassoc) {
         IEEE80211_DELIVER_EVENT_MLME_REASSOC_INDICATION(vap, ni->ni_macaddr,
@@ -284,6 +296,16 @@
     if (node_leave) {
 	IEEE80211_NODE_LEAVE(ni);
     }
+    else {
+            if( !is2GHz ) {
+                printk(": Link: Established, Started DDRS ATPC Timer\n");
+                memcpy( &ni->kwn_profile_cfg.txparam, &vap->kwn_txparam, sizeof( struct kwn_link_txparam ) );
+                OS_SET_TIMER( &ni->kwn_snr_timer, 0 );
+                OS_SET_TIMER( &ni->kwn_stats_timer, 0 );
+                OS_SET_TIMER( &ni->kwn_ddrs_timer, 0 );
+                OS_SET_TIMER( &ni->kwn_atpc_timer, 0 );
+            }
+    }
 
     return status;
 }
@@ -960,7 +982,17 @@
         if (indication_status != IEEE80211_STATUS_SUCCESS ){
             /* auth is not success, remove the node from node table*/
             IEEE80211_NODE_LEAVE(ni);
+#ifdef SIFY_MGMT_STATS
+            vap->iv_mgmt_stats.aut_reject_xmit++;
+#endif
+        }
+#ifdef SIFY_MGMT_STATS
+        else
+        {
+            vap->iv_mgmt_stats.aut_confirm_xmit++;
         }
+        vap->iv_mgmt_stats.auth_reason = indication_status;
+#endif
     }
 
 #if UMAC_SUPPORT_ACL
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme.c qca-wifi-mod/umac/mlme/ieee80211_mlme.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme.c	2019-03-23 17:37:54.694986459 +0530
@@ -623,6 +623,16 @@
                       __func__,ether_sprintf(ni->ni_macaddr));
     IEEE80211_ADDR_COPY(macaddr, ni->ni_macaddr);
 
+    OS_FREE_TIMER( &ni->kwn_stats_timer );
+    OS_FREE_TIMER( &ni->kwn_snr_timer );
+    OS_FREE_TIMER( &ni->kwn_ddrs_timer );
+    OS_FREE_TIMER( &ni->kwn_atpc_timer );
+    OS_FREE_TIMER( &ni->kwn_link_timer );
+    OS_FREE_TIMER( &ni->kwn_txba_timer );
+    if( ni->kwn_tput_running ) {
+        OS_FREE_TIMER( &vap->kwn_tput_timer );
+        OS_FREE_TIMER( &vap->kwn_tput_timer_fr );
+    }
     associd = ni->ni_associd;
     IEEE80211_DPRINTF(vap, IEEE80211_MSG_AUTH, "%s: sending DEAUTH to %s, reason %d\n",
             __func__, ether_sprintf(ni->ni_macaddr), IEEE80211_REASON_AUTH_LEAVE);
@@ -643,6 +653,17 @@
     struct ieee80211vap    *vap = ni->ni_vap;
     u_int8_t macaddr[6];
     u_int8_t *only_rptr_clients = (u_int8_t *)arg;
+
+    OS_FREE_TIMER( &ni->kwn_stats_timer );
+    OS_FREE_TIMER( &ni->kwn_snr_timer );
+    OS_FREE_TIMER( &ni->kwn_ddrs_timer );
+    OS_FREE_TIMER( &ni->kwn_atpc_timer );
+    OS_FREE_TIMER( &ni->kwn_link_timer );
+    OS_FREE_TIMER( &ni->kwn_txba_timer );
+    if( ni->kwn_tput_running ) {
+        OS_FREE_TIMER( &vap->kwn_tput_timer );
+        OS_FREE_TIMER( &vap->kwn_tput_timer_fr );
+    }
     if (only_rptr_clients && ((*only_rptr_clients) == 0x1)) {
 	if (!ni->is_extender_client) {
 	    return;
diff -urN qca-wifi-org/umac/mlme/ieee80211_mlme_sta.c qca-wifi-mod/umac/mlme/ieee80211_mlme_sta.c
--- qca-wifi-org/umac/mlme/ieee80211_mlme_sta.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/mlme/ieee80211_mlme_sta.c	2019-02-27 17:53:52.578848229 +0530
@@ -548,6 +548,7 @@
     int                           mlme_request_type = mlme_priv->im_request_type;
     int                           error;
     u_int32_t                     rxlinkspeed, txlinkspeed; /* bits/sec */
+    int is2GHz = IEEE80211_IS_CHAN_2GHZ( ic->ic_curchan );
 #if ATH_SUPPORT_WRAP
     /* Changes for Legacy Wrap support */
     struct ath_softc_net80211 *scn = ATH_SOFTC_NET80211(ic);
@@ -655,6 +656,18 @@
         error = mlme_process_timeout_interval_elements(ni, ie_data, ie_length);
     }
 
+#ifdef SIFY_MGMT_STATS
+    if (status_code != IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.assoc_reject_recv++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.assoc_confirm_recv++;
+    }
+    vap->iv_mgmt_stats.assoc_reason = status_code;
+#endif
+
     /* indicate linkspeed */
      mlme_get_linkrate(ni, &rxlinkspeed, &txlinkspeed);
      IEEE80211_DELIVER_EVENT_LINK_SPEED(vap, rxlinkspeed, txlinkspeed);
@@ -672,6 +685,16 @@
     default:
         break;
     }
+    /* Link is established */
+    if( !is2GHz ) {
+        printk(": Link: Established, Started DDRS ATPC Timer\n");
+        memcpy( &ni->kwn_profile_cfg.txparam, &vap->kwn_txparam, sizeof( struct kwn_link_txparam ) );
+        OS_SET_TIMER( &ni->kwn_snr_timer, 0 );
+        OS_SET_TIMER( &ni->kwn_stats_timer, 0 );
+        OS_SET_TIMER( &ni->kwn_ddrs_timer, 0 );
+        OS_SET_TIMER( &ni->kwn_atpc_timer, 0 );
+        OS_SET_TIMER( &ni->kwn_link_timer, 0 );
+    }
 }
 
 /* Send association or reassociation request */
@@ -1295,6 +1318,17 @@
     }
 
     IEEE80211_DPRINTF(vap, IEEE80211_MSG_MLME, "%s: mlme_auth_complete\n", __func__);
+#ifdef SIFY_MGMT_STATS
+    if (status_code == IEEE80211_STATUS_SUCCESS)
+    {
+        vap->iv_mgmt_stats.aut_confirm_recv++;
+    }
+    else
+    {
+        vap->iv_mgmt_stats.aut_reject_recv++;
+    }
+    vap->iv_mgmt_stats.auth_reason = status_code;
+#endif
 
     /* Request complete */
     mlme_priv->im_request_type = MLME_REQ_NONE;
diff -urN qca-wifi-org/umac/scan/ieee80211_aplist.c qca-wifi-mod/umac/scan/ieee80211_aplist.c
--- qca-wifi-org/umac/scan/ieee80211_aplist.c	2018-06-08 11:00:47.000000000 +0530
+++ qca-wifi-mod/umac/scan/ieee80211_aplist.c	2019-03-23 12:29:38.746318009 +0530
@@ -1449,7 +1449,7 @@
     if (age >= maximum_age) {
         IEEE80211_DPRINTF(vaphandle, IEEE80211_MSG_SCANENTRY, "%s Age %d, MaxAge %d\n", 
                           " - Reject (Old Entry)", age, maximum_age);
-        return false;
+        //return false;
     }
 
     /*
diff -urN qca-wifi-org/umac/scan/ieee80211_scanentry.c qca-wifi-mod/umac/scan/ieee80211_scanentry.c
--- qca-wifi-org/umac/scan/ieee80211_scanentry.c	2018-06-08 11:00:48.000000000 +0530
+++ qca-wifi-mod/umac/scan/ieee80211_scanentry.c	2019-03-20 20:28:09.545275303 +0530
@@ -121,6 +121,7 @@
     u_int8_t                          se_flag;            /* general flag for se */
     u_int32_t                         se_bcn_ie_chksum;   /* checksum of interested beacon IEs */
     bool                              se_oce_cap;         /* OCE capable AP or not */
+    u_int8_t                          se_kwn_linktype;
 };
 
 struct ieee80211_scan_table {
@@ -700,6 +701,11 @@
     return scan_entry->se_phy_mode;
 }
 
+u_int8_t ieee80211_scan_entry_linktype(ieee80211_scan_entry_t scan_entry)
+{
+    return scan_entry->se_kwn_linktype;
+}
+
 enum ieee80211_opmode ieee80211_scan_entry_bss_type(ieee80211_scan_entry_t scan_entry)
 {
     return (scan_entry->se_capinfo & IEEE80211_CAPINFO_ESS) ? IEEE80211_M_STA : IEEE80211_M_IBSS;
@@ -755,7 +761,8 @@
     const u_int8_t              *ssid_ie,
     struct ieee80211_channel    *chan,
     int                         subtype,
-    osdev_t                     st_osdev)
+    osdev_t                     st_osdev,
+    u_int8_t                    kwn_linktype)
 {
     struct ieee80211_scan_entry    *scan_entry;
 
@@ -817,6 +824,7 @@
     scan_entry->se_subtype  = subtype;   /* Initial subtype */
     scan_entry->se_avgrssi  = ATH_RSSI_DUMMY_MARKER;
     scan_entry->se_rssi     = 0;
+    scan_entry->se_kwn_linktype     = kwn_linktype;
 
     IEEE80211_SCANENTRY_PRINTF(vaphandle->iv_ic, IEEE80211_MSG_SCANENTRY,
         "%s: %02X:%02X:%02X:%02X:%02X:%02X SSID=%.*s chan=%3d p=%08p\n",
@@ -1874,6 +1882,11 @@
                 if (ssid_match) {
                     ASSERT(scan_entry_match == NULL);
                     scan_entry_match = current_scan_entry;
+                    if( scan_entry_match ) {
+                        if( scan_entry_parameters->kwn_linktype != 0 ) {
+                            current_scan_entry->se_kwn_linktype = scan_entry_parameters->kwn_linktype;
+                        }
+                    }
                     bMatch = true;
                 }
 
@@ -1946,7 +1959,8 @@
                                                            scan_entry_parameters->ie_list.ssid,
                                                            scan_entry_parameters->chan,
                                                            subtype,
-                                                           scan_table->st_osdev);
+                                                           scan_table->st_osdev,
+                                                           scan_entry_parameters->kwn_linktype);
         if (scan_entry_match != NULL) {
              new_ap = 1;
             /* Update the newly created entry */
@@ -2048,6 +2062,7 @@
 
 struct ieee80211_scan_entry *
 ieee80211_scan_table_update(struct ieee80211vap          *vap,
+			    struct ieee80211_node *ni,
                             struct ieee80211_frame *wh,
                             u_int32_t                    frame_length,
                             int                          subtype,
@@ -2070,6 +2085,7 @@
      * Parse and validate the beacon first
      */
     if (ieee80211_parse_beacon(vap,
+			       ni,
                                beacon_frame,
                                wh,
                                beacon_length,
@@ -2715,6 +2731,11 @@
     return ieee80211_scan_entry_phymode(scan_entry);
 }
 
+u_int8_t wlan_scan_entry_linktype(wlan_scan_entry_t scan_entry)
+{
+    return ieee80211_scan_entry_linktype(scan_entry);
+}
+
 u_int8_t *wlan_scan_entry_ssid(wlan_scan_entry_t scan_entry, u_int8_t *len)
 {
     if (len == NULL)
