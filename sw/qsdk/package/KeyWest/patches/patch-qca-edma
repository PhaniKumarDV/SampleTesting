diff -urN qca-edma-org/edma.c qca-edma-mod/edma.c
--- qca-edma-org/edma.c	2018-07-09 14:25:58.833210000 +0530
+++ qca-edma-mod/edma.c	2018-08-13 14:45:32.336515418 +0530
@@ -26,6 +26,147 @@
 extern u8 edma_per_prec_stats_enable;
 extern u32 edma_iad_stats_enable;
 
+/* KWN: Export VLAN Routines for accessibility to the wifi driver */
+EXPORT_SYMBOL(edma_set_vid_bitmap);
+EXPORT_SYMBOL(edma_clear_vid_bitmap);
+EXPORT_SYMBOL(edma_set_vlan_mode);
+EXPORT_SYMBOL(edma_set_allow_untagged);
+EXPORT_SYMBOL(edma_set_allow_all_tagged_trunk);
+EXPORT_SYMBOL(edma_set_access_vlan_id);
+EXPORT_SYMBOL(edma_set_native_vlan_id);
+EXPORT_SYMBOL(edma_set_mgmt_vlan_id);
+EXPORT_SYMBOL(edma_get_tx_pkts);
+EXPORT_SYMBOL(edma_get_tx_errors);
+EXPORT_SYMBOL(edma_get_tx_bytes);
+EXPORT_SYMBOL(edma_get_rx_pkts);
+EXPORT_SYMBOL(edma_get_rx_errors);
+EXPORT_SYMBOL(edma_get_rx_bytes);
+
+unsigned long edma_get_tx_pkts( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_packets;
+	return value;
+}
+
+unsigned long edma_get_tx_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_errors;
+	return value;
+}
+
+unsigned long edma_get_tx_bytes( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_bytes;
+	return value;
+}
+
+unsigned long edma_get_rx_pkts( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_packets;
+	return value;
+}
+
+unsigned long edma_get_rx_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_errors;
+	return value;
+}
+
+unsigned long edma_get_rx_bytes( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_bytes;
+	return value;
+}
+
+int edma_set_vid_bitmap( struct net_device *dev, uint16_t vid, uint16_t flags )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	set_bit(vid, edma_cinfo->vlan_bitmap);
+	printk(":@@@@@@@@@@ set_vid: %d\n",vid);
+	return 0;
+}
+
+int edma_clear_vid_bitmap( struct net_device *dev, uint16_t vid )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	clear_bit(vid, edma_cinfo->vlan_bitmap);
+	printk(":@@@@@@@@@@ clear_vid: %d\n",vid);
+	return 0;
+}
+
+int edma_set_vlan_mode( struct net_device *dev, uint8_t vlan_mode )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->vlan_mode = vlan_mode;
+	printk(": @@@@@@@@@ VLAN Mode: %d\n",vlan_mode);
+	return 0;
+}
+
+int edma_set_allow_untagged( struct net_device *dev, uint8_t allow_untagged )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_untagged = allow_untagged;
+	printk(": @@@@@@@@@ Allow Untagged : %d\n",allow_untagged );
+	return 0;
+}
+
+int edma_set_allow_all_tagged_trunk( struct net_device *dev, uint8_t allow_all )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_all_tagged_trunk = allow_all;
+	printk(": @@@@@@@@@ Allow All Tagged Trunk : %d\n",allow_all );
+	return 0;
+}
+
+int edma_set_access_vlan_id( struct net_device *dev, uint16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->access_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Access VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_native_vlan_id( struct net_device *dev, uint16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->native_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Native VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_mgmt_vlan_id( struct net_device *dev, uint16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->mgmt_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Mgmt VlanId : %d\n",vlan_id );
+	return 0;
+}
 /* edma_skb_priority_offset()
  *	get edma skb priority
  */
@@ -1535,6 +1676,40 @@
 	return __EDMA_LINKDOWN;
 }
 
+
+static loff_t pos = 0;
+int sify_filewrite (int input)
+{
+       struct file *file;
+       char up_data [] ="Ethernet Up";  
+       char down_data [] ="Ethernet Down"; 
+       mm_segment_t old_fs;
+
+       old_fs = get_fs();  //Save the current FS segment
+       set_fs(get_ds());
+
+       file = filp_open("/tmp/eth_events.txt", O_WRONLY| O_CREAT| O_APPEND | O_SYNC, 0644);
+
+       if(file){
+
+               if (input == 0)
+               {
+                       vfs_write(file, up_data, sizeof (up_data), &pos);
+                       pos = pos+sizeof (up_data);
+               }
+               else
+               {
+                       vfs_write(file, down_data, (sizeof(down_data)+1), &pos);
+                       pos = pos+(sizeof (down_data)+1);
+
+               }
+
+       }
+       filp_close(file,NULL);
+       set_fs(old_fs); //Reset to save FS
+
+}
+
 /* edma_adjust_link()
  *	check for edma link status
  */
@@ -1551,12 +1726,14 @@
 
 	if (status == __EDMA_LINKUP && adapter->link_state == __EDMA_LINKDOWN) {
 		dev_info(&adapter->pdev->dev, "%s: GMAC Link is up with phy_speed=%d\n", netdev->name, phydev->speed);
+                sify_filewrite(1);
 		adapter->link_state = __EDMA_LINKUP;
 		netif_carrier_on(netdev);
 		if (netif_running(netdev))
 			netif_tx_wake_all_queues(netdev);
 	} else if (status == __EDMA_LINKDOWN && adapter->link_state == __EDMA_LINKUP) {
 		dev_info(&adapter->pdev->dev, "%s: GMAC Link is down\n", netdev->name);
+                sify_filewrite(0);
 		adapter->link_state = __EDMA_LINKDOWN;
 		netif_carrier_off(netdev);
 		netif_tx_stop_all_queues(netdev);
diff -urN qca-edma-org/edma.h qca-edma-mod/edma.h
--- qca-edma-org/edma.h	2018-07-09 14:25:58.833210000 +0530
+++ qca-edma-mod/edma.h	2018-08-13 14:46:04.052514368 +0530
@@ -44,6 +44,10 @@
 #include <linux/if_pppox.h>
 #include "ess_edma.h"
 
+#define EDMA_VLAN_MODE_TRANSPARENT	0
+#define EDMA_VLAN_MODE_ACCESS		1
+#define EDMA_VLAN_MODE_TRUNK		2
+
 #define EDMA_CPU_CORES_SUPPORTED 4
 #define EDMA_MAX_PORTID_SUPPORTED 5
 #define EDMA_MAX_VLAN_SUPPORTED  EDMA_MAX_PORTID_SUPPORTED
@@ -393,6 +397,14 @@
 	struct edma_per_cpu_queues_info edma_percpu_info[CONFIG_NR_CPUS]; /* per cpu information */
 	spinlock_t stats_lock; /* protect edma stats area for updation */
 	u32 num_cores;
+	/* KWN: Vlan Parameters */
+	unsigned long vlan_bitmap[512];	/* Vlan Trunk Table */
+	uint8_t vlan_mode;	/* Vlan Modes: Transparent, Access, Trunk & QinQ */
+	uint8_t allow_untagged;	/* Allow UnTagged in Trunk Mode */
+	uint16_t access_vlan_id;	/* Tag UnTagged traffic in Access Mode */
+	uint16_t native_vlan_id;	/* Tag UnTagged traffic in Trunk Mode */
+	uint16_t mgmt_vlan_id;	/* Tag UnTagged traffic in all modes */
+	uint8_t allow_all_tagged_trunk; /* Allow all Tagged traffic in Trunk Mode */
 };
 
 /* transimit packet descriptor (tpd) ring */
@@ -547,4 +559,19 @@
 void edma_iad_process_flow(struct edma_common_info *edma_cinfo,
 			   struct sk_buff *skb, u8 dir, u8 precedence);
 
+/* KWN: Routines to maintain the VID Information */
+int edma_set_vid_bitmap(struct net_device *dev, uint16_t vid, uint16_t flags);
+int edma_clear_vid_bitmap(struct net_device *dev, uint16_t vid);
+int edma_set_vlan_mode(struct net_device *dev, uint8_t vlan_mode);
+int edma_set_allow_untagged(struct net_device *dev, uint8_t allow_untagged);
+int edma_set_allow_all_tagged_trunk( struct net_device *dev, uint8_t allow_all );
+int edma_set_access_vlan_id( struct net_device *dev, uint16_t vlan_id );
+int edma_set_native_vlan_id( struct net_device *dev, uint16_t vlan_id );
+int edma_set_mgmt_vlan_id( struct net_device *dev, uint16_t vlan_id );
+unsigned long edma_get_tx_pkts( struct net_device *dev );
+unsigned long edma_get_tx_errors( struct net_device *dev );
+unsigned long edma_get_tx_bytes( struct net_device *dev );
+unsigned long edma_get_rx_pkts( struct net_device *dev );
+unsigned long edma_get_rx_errors( struct net_device *dev );
+unsigned long edma_get_rx_bytes( struct net_device *dev );
 #endif /* _EDMA_H_ */
