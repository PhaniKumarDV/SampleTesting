diff -urN qca-edma-org/edma.c qca-edma-mod/edma.c
--- qca-edma-org/edma.c	2018-07-09 14:25:58.833210000 +0530
+++ qca-edma-mod/edma.c	2019-02-15 18:12:09.220992307 +0530
@@ -26,6 +26,618 @@
 extern u8 edma_per_prec_stats_enable;
 extern u32 edma_iad_stats_enable;
 
+/* KWN: Export VLAN Routines for accessibility to the wifi driver */
+EXPORT_SYMBOL(edma_set_vid_bitmap);
+EXPORT_SYMBOL(edma_clear_vid_bitmap);
+EXPORT_SYMBOL(edma_set_vlan_mode);
+EXPORT_SYMBOL(edma_set_allow_tagged_mgmt);
+EXPORT_SYMBOL(edma_set_allow_untagged);
+EXPORT_SYMBOL(edma_set_allow_all_tagged_trunk);
+EXPORT_SYMBOL(edma_set_access_vlan_id);
+EXPORT_SYMBOL(edma_set_native_vlan_id);
+EXPORT_SYMBOL(edma_set_mgmt_vlan_id);
+EXPORT_SYMBOL(edma_get_mgmt_vlan_id);
+EXPORT_SYMBOL(edma_set_svlan_id);
+EXPORT_SYMBOL(edma_set_svlan_etherType);
+EXPORT_SYMBOL(edma_get_tx_pkts);
+EXPORT_SYMBOL(edma_get_tx_errors);
+EXPORT_SYMBOL(edma_get_tx_bytes);
+EXPORT_SYMBOL(edma_get_tx_thrpt);
+EXPORT_SYMBOL(edma_get_rx_pkts);
+EXPORT_SYMBOL(edma_get_rx_errors);
+EXPORT_SYMBOL(edma_get_rx_bytes);
+EXPORT_SYMBOL(edma_get_rx_thrpt);
+EXPORT_SYMBOL(edma_set_pbb_da_mac);
+EXPORT_SYMBOL(edma_set_pbb_sa_mac);
+EXPORT_SYMBOL(edma_set_pbb_bvid);
+EXPORT_SYMBOL(edma_set_pbb_isid);
+EXPORT_SYMBOL(edma_set_suservice);
+EXPORT_SYMBOL(edma_set_sukbps);
+EXPORT_SYMBOL(edma_clear_eth_stats);
+EXPORT_SYMBOL(edma_filtering_status);
+EXPORT_SYMBOL(edma_filtering_l2mcast);
+EXPORT_SYMBOL(edma_filtering_l3mcast);
+EXPORT_SYMBOL(edma_filtering_l2bcast);
+EXPORT_SYMBOL(edma_filtering_l3bcast);
+EXPORT_SYMBOL(edma_get_fil_tx_l2mcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_rx_l2mcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_tx_l3mcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_rx_l3mcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_tx_l2bcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_rx_l2bcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_tx_l3bcast_drpcnt);
+EXPORT_SYMBOL(edma_get_fil_rx_l3bcast_drpcnt);
+EXPORT_SYMBOL(edma_get_tx_failure);
+EXPORT_SYMBOL(edma_get_rx_failure);
+EXPORT_SYMBOL(edma_get_rx_crc_errors);
+EXPORT_SYMBOL(edma_get_rx_frame_oversize_errors);
+EXPORT_SYMBOL(edma_get_rx_frame_overrun_errors);
+EXPORT_SYMBOL(edma_get_tx_multicastpkt);
+EXPORT_SYMBOL(edma_get_rx_multicastpkt);
+EXPORT_SYMBOL(edma_get_tx_unicastpkt);
+EXPORT_SYMBOL(edma_get_rx_unicastpkt);
+EXPORT_SYMBOL(edma_set_kwn_tput_pkt_per_ms);
+EXPORT_SYMBOL(edma_set_kwn_tput_pkt_size);
+EXPORT_SYMBOL(edma_set_kwn_tput_duration);
+EXPORT_SYMBOL(edma_set_kwn_tput_direction);
+EXPORT_SYMBOL(edma_set_kwn_test_mac);
+EXPORT_SYMBOL(edma_set_kwn_tput_start);
+EXPORT_SYMBOL(edma_get_kwn_tput_rxseq_failed_cnt);
+
+void edma_send_tput_tx(unsigned long data);
+/* Phani: Tx Send Timer for KWN Ethernet TPUT Test */
+char kwn_tput_test_dsap[6] = {0xaa,0xaa,0xab,0xac,0xad,0xae};
+struct kwn_tput_test_params {
+	int kwn_tput_test_duration;
+	int kwn_tput_test_pktsize;
+	int kwn_tput_test_pktperms;
+	int kwn_tput_test_direction;
+	int kwn_tput_start_test;
+	uint64_t kwn_tput_test_txseq;
+	uint64_t kwn_tput_test_rxseq;
+};
+uint64_t edma_get_tx_pkts( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_packets;
+	return value;
+}
+
+uint64_t edma_get_tx_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_errors;
+	return value;
+}
+
+uint64_t edma_get_tx_bytes( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_bytes;
+	return value;
+}
+
+uint64_t edma_get_tx_thrpt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    unsigned long value;
+
+    value = edma_cinfo->kwn_tx_tput_mbps;
+	return value;
+}
+
+uint64_t edma_get_rx_pkts( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_packets;
+	return value;
+}
+
+uint64_t edma_get_rx_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_errors;
+	return value;
+}
+
+uint64_t edma_get_rx_bytes( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_bytes;
+	return value;
+}
+
+uint64_t edma_get_rx_thrpt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    unsigned long value;
+
+    value = edma_cinfo->kwn_rx_tput_mbps;
+	return value;
+}
+
+int edma_set_vid_bitmap( struct net_device *dev, int16_t vid, int16_t flags )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	set_bit(vid, edma_cinfo->vlan_bitmap);
+	printk(":@@@@@@@@@@ set_vid: %d\n",vid);
+	return 0;
+}
+
+int edma_clear_vid_bitmap( struct net_device *dev, int16_t vid )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	if ( vid == 0 ) {
+		bitmap_zero(edma_cinfo->vlan_bitmap, 4096);
+		printk(":@@@@@@@@@@ clear_all_vids: %d\n",vid);
+	}
+	else {
+		clear_bit(vid, edma_cinfo->vlan_bitmap);
+		printk(":@@@@@@@@@@ clear_vid: %d\n",vid);
+	}
+	return 0;
+}
+
+int edma_set_vlan_mode( struct net_device *dev, int8_t vlan_mode )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->vlan_mode = vlan_mode;
+	printk(": @@@@@@@@@ VLAN Mode: %d\n",vlan_mode);
+	return 0;
+}
+
+int edma_set_allow_tagged_mgmt( struct net_device *dev, int8_t allow_tagged_mgmt )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_tagged_mgmt = allow_tagged_mgmt;
+	printk(": @@@@@@@@@ Allow Tagged Mgmt: %d\n",allow_tagged_mgmt );
+	return 0;
+}
+
+int edma_set_allow_untagged( struct net_device *dev, int8_t allow_untagged )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_untagged = allow_untagged;
+	printk(": @@@@@@@@@ Allow Untagged : %d\n",allow_untagged );
+	return 0;
+}
+
+int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_all_tagged_trunk = allow_all;
+	printk(": @@@@@@@@@ Allow All Tagged Trunk : %d\n",allow_all );
+	return 0;
+}
+
+int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->access_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Access VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->native_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Native VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->mgmt_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Mgmt VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_get_mgmt_vlan_id( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	return edma_cinfo->mgmt_vlan_id;
+}
+
+int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->svlan_id = vlan_id;
+	printk(": @@@@@@@@@ SVlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->svlan_etherType = etherType;
+	printk(": @@@@@@@@@ SVLan EtherType : %x\n",etherType );
+	return 0;
+}
+
+int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int i = 0;
+	memcpy(edma_cinfo->pbb_da_mac, mac, 6);
+	printk("@@@@@@@ PBB B-DA-MAC: ");
+	for ( i = 0; i < 6; i++ ) {
+		printk(": %x",mac[i]);
+	}
+	printk("\n");
+	return 0;
+}
+
+int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int i = 0;
+	memcpy(edma_cinfo->pbb_sa_mac, mac, 6);
+	printk("@@@@@@@ PBB B-SA-MAC: ");
+	for ( i = 0; i < 6; i++ ) {
+		printk(": %x",mac[i]);
+	}
+	printk("\n");
+	return 0;
+}
+
+int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->pbb_bvid = vlan_id;
+	printk(": @@@@@@@@@ PBB B VlanID : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->pbb_isid = vlan_id;
+	printk(": @@@@@@@@@ PBB B VlanID : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_suservice( struct net_device *dev, uint8_t suservice )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	printk(": @@@@@@@@@ SU Service : %d\n",suservice );
+	edma_cinfo->kwn_suservice = suservice;
+	return 0;
+}
+
+int edma_set_sukbps( struct net_device *dev, uint32_t kbps )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	printk(": @@@@@@@@@ SU Dflt kbps : %d\n",kbps );
+	edma_cinfo->kwn_sukbps = kbps;
+	return 0;
+}
+
+int edma_clear_eth_stats( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	memset(&adapter->stats, 0, sizeof(adapter->stats));
+	memset(&edma_cinfo->fil_drop_count, 0, sizeof(edma_cinfo->fil_drop_count));
+	return 0;
+}
+
+int edma_filtering_status( struct net_device *dev, uint8_t status )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    edma_cinfo->kwn_fil_status = status;
+	printk(": @@@@@@@@@ Filtering Status : %d\n",status );
+	return 0;
+}
+
+int edma_filtering_l2mcast( struct net_device *dev, uint8_t l2mcast)
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    edma_cinfo->kwn_fil_l2mcast = l2mcast;
+	printk(": @@@@@@@@@ Filtering l2mcast : %d\n",l2mcast );
+	return 0;
+}
+
+int edma_filtering_l3mcast(struct net_device *dev, uint8_t l3mcast)
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    edma_cinfo->kwn_fil_l3mcast = l3mcast;
+	printk(": @@@@@@@@@ Filtering l3mcast : %d\n",l3mcast );
+	return 0;
+}
+
+int edma_filtering_l2bcast(struct net_device *dev, uint8_t l2bcast)
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    edma_cinfo->kwn_fil_l2bcast = l2bcast;
+	printk(": @@@@@@@@@ Filtering l2bcast : %d\n",l2bcast );
+	return 0;
+}
+
+int edma_filtering_l3bcast(struct net_device *dev, uint8_t l3bcast)
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    edma_cinfo->kwn_fil_l3bcast = l3bcast;
+	printk(": @@@@@@@@@ Filtering l3bcast : %d\n",l3bcast );
+	return 0;
+}
+
+uint64_t edma_get_fil_tx_l2mcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_tx_l2mcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_rx_l2mcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_rx_l2mcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_tx_l3mcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_tx_l3mcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_rx_l3mcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_rx_l3mcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_tx_l2bcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_tx_l2bcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_rx_l2bcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_rx_l2bcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_tx_l3bcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_tx_l3bcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_fil_rx_l3bcast_drpcnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_fil_rx_l3bcast_dropcnt;
+	return value;
+}
+
+uint64_t edma_get_tx_failure( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    uint64_t value;
+
+    value = adapter->stats.tx_dropped;
+	return value;
+}
+
+uint64_t edma_get_rx_failure( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    uint64_t value;
+
+    value = adapter->stats.rx_dropped;
+	return value;
+}
+
+uint64_t edma_get_rx_crc_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    uint64_t value;
+
+    value = adapter->stats.rx_crc_errors;
+	return value;
+}
+
+uint64_t edma_get_rx_frame_oversize_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    uint64_t value;
+
+    value = adapter->stats.rx_over_errors;
+	return value;
+}
+
+uint64_t edma_get_rx_frame_overrun_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    uint64_t value;
+
+    value = adapter->stats.rx_fifo_errors;
+	return value;
+}
+
+uint64_t edma_get_tx_multicastpkt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_tx_multicast;
+	return value;
+}
+
+uint64_t edma_get_rx_multicastpkt( struct net_device *dev )
+{
+    struct edma_adapter *adapter = netdev_priv(dev);
+    uint64_t value;
+
+    value = adapter->stats.multicast;
+	return value;
+}
+
+uint64_t edma_get_tx_unicastpkt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_tx_unicast;
+	return value;
+}
+
+uint64_t edma_get_rx_unicastpkt( struct net_device *dev )
+{
+    struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    uint64_t value;
+
+    value = edma_cinfo->fil_drop_count.kwn_rx_unicast;
+	return value;
+}
+
+int edma_set_kwn_tput_pkt_per_ms( struct net_device *dev, uint32_t pkt_per_ms )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	printk(": @@@@@@@@@ KWN Ethernet PktPerMs : %d\n",pkt_per_ms );
+	edma_cinfo->kwn_pkt_per_ms = pkt_per_ms;
+	return 0;
+}
+
+int edma_set_kwn_tput_pkt_size( struct net_device *dev, uint32_t pkt_size )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	printk(": @@@@@@@@@ KWN Ethernet PktSize : %d\n",pkt_size );
+	edma_cinfo->kwn_pkt_size = pkt_size;
+	return 0;
+}
+
+int edma_set_kwn_tput_duration( struct net_device *dev, uint32_t duration )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	printk(": @@@@@@@@@ KWN Ethernet Duration : %d\n",duration );
+	edma_cinfo->kwn_duration = duration;
+	return 0;
+}
+
+int edma_set_kwn_tput_direction( struct net_device *dev, uint32_t direction )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	printk(": @@@@@@@@@ KWN Ethernet Direction : %d\n",direction );
+	edma_cinfo->kwn_direction = direction;
+	return 0;
+}
+
+int edma_set_kwn_test_mac( struct net_device *dev, uint8_t *mac )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int i = 0;
+	memcpy(edma_cinfo->kwn_test_mac, mac, 6);
+	printk("@@@@@@@ KWN Test MAC: ");
+	for ( i = 0; i < 6; i++ ) {
+		printk(": %x",mac[i]);
+	}
+	printk("\n");
+	return 0;
+}
+
+int edma_set_kwn_tput_start( struct net_device *dev, uint32_t start )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    printk(": @@@@@@@@@ KWN Tput Test : %d\n",start );
+    edma_cinfo->kwn_start = start;
+    if ( start ) {
+        edma_cinfo->kwn_tput_start_time = jiffies;
+        edma_cinfo->kwn_tput_txseq = 0;
+        printk(": KWN Tput Test Started: \n");
+        mod_timer(&edma_cinfo->kwn_tput_timer, jiffies + 1);
+    } else {
+        edma_cinfo->kwn_tput_start_time = jiffies - edma_cinfo->kwn_duration;
+    }
+    return 0;
+}
+
+uint64_t edma_get_kwn_tput_rxseq_failed_cnt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    return edma_cinfo->kwn_tput_rx_failed_cnt;
+}
+
 /* edma_skb_priority_offset()
  *	get edma skb priority
  */
@@ -772,24 +1384,344 @@
 					skb_set_hash(skb, rd->rrd2, PKT_HASH_TYPE_L4);
 			}
 
+            /* Advanced ethernet stats */
+            if ( is_unicast_ether_addr( eth_hdr(skb)->h_dest ) )
+            {
+                edma_cinfo->fil_drop_count.kwn_rx_unicast++;
+            }
+
+            /* KWN FILTERING */
+            if ( edma_cinfo->kwn_fil_status && ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) != 0 )  )
+            {
+                if ( edma_cinfo->kwn_fil_l2mcast )
+                {
+                    if ( is_multicast_ether_addr(eth_hdr(skb)->h_dest) ) 
+                    {
+                        edma_cinfo->fil_drop_count.kwn_fil_rx_l2mcast_dropcnt++;
+                        dev_kfree_skb_any( skb );
+                        continue;
+                    }
+                }
+                if ( edma_cinfo->kwn_fil_l2bcast )
+                {
+                    if ( is_broadcast_ether_addr(eth_hdr(skb)->h_dest) )
+                    {
+                        edma_cinfo->fil_drop_count.kwn_fil_rx_l2bcast_dropcnt++;
+                        dev_kfree_skb_any( skb );
+                        continue;
+                    }
+                }
+                if ( edma_cinfo->kwn_fil_l3mcast )
+                {
+                    if ( ipv4_is_multicast (ip_hdr(skb)->daddr) )
+                    {
+                        edma_cinfo->fil_drop_count.kwn_fil_rx_l3mcast_dropcnt++;
+                        dev_kfree_skb_any( skb );
+                        continue;
+                    }
+                }
+                if ( edma_cinfo->kwn_fil_l3bcast )
+                {
+                    if ( ipv4_is_lbcast (ip_hdr(skb)->daddr) )
+                    {
+                        edma_cinfo->fil_drop_count.kwn_fil_rx_l3bcast_dropcnt++;
+                        dev_kfree_skb_any( skb );
+                        continue;
+                    }
+                }
+            }
+
 #ifdef CONFIG_NF_FLOW_COOKIE
 			skb->flow_cookie = rd->rrd3 & EDMA_RRD_FLOW_COOKIE_MASK;
 #endif
 			edma_receive_checksum(rd, skb);
 
-			/* Process VLAN HW acceleration indication provided by HW */
-			if (adapter->default_vlan_tag != rd->rrd4) {
-				vlan = rd->rrd4;
-				if (likely(rd->rrd7 & EDMA_RRD_CVLAN))
+#if 0
+			printk("RRD Dump\n rrd0:%x rrd1: %x rrd2: %x rrd3: %x rrd4: %x rrd5: %x rrd6: %x rrd7: %x",
+					rd->rrd0, rd->rrd1, rd->rrd2, rd->rrd3, rd->rrd4, rd->rrd5, rd->rrd6, rd->rrd7);
+			printk("Num_rfds: %d, src_port: %d, pkt_size: %d, cvlan_tag: %d svlan_tag: %d protocol: %x\n",
+					num_rfds, rd->rrd1 & EDMA_RRD_SRC_PORT_NUM_MASK,
+					rd->rrd6 & EDMA_RRD_PKT_SIZE_MASK, rd->rrd7 & EDMA_RRD_CVLAN, rd->rrd1 & EDMA_RRD_SVLAN, skb->protocol);
+#endif
+
+			skb->vlan_proto_kwn = 0;
+			skb->vlan_tci_kwn = 0;
+			skb->pbb_bvid = 0;
+			skb->pbb_isid = 0;
+			
+			/* KWN: Vlan Ingress Path */
+			switch( edma_cinfo->vlan_mode ) 
+			{
+				case EDMA_VLAN_MODE_TRANSPARENT:
+					/* Allow Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan != edma_cinfo->mgmt_vlan_id ) {
+							__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+						}
+					} 
+					break;
+				case EDMA_VLAN_MODE_TRUNK:
+					/* Tagged Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } else {
+							if ( test_bit(vlan, edma_cinfo->vlan_bitmap) || edma_cinfo->allow_all_tagged_trunk ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+							} else {
+								/*printk(":(RX): Trunk Mode: Skb vlan(%d) != Trunk Vlan Table: Result: Drop \n", 
+										vlan);*/
+								dev_kfree_skb_any( skb );
+								continue;
+							}
+						}
+					} else { /* UnTagged Traffic */
+                        if ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+                            break;
+                        }
+						if ( edma_cinfo->allow_untagged ) {
+							if ( edma_cinfo->native_vlan_id > 0 ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->native_vlan_id);
+							} else {  /* Allow UnTagged packets when native vlanid is not set */; }
+						} else {
+							/*printk(": (RX): Trunk Mode: !AllowUntagged:  Skb UnTagged : Result: Drop \n");*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} 
+					break;
+				case EDMA_VLAN_MODE_ACCESS:
+#if 0
+                    /*  Tagged Traffic */
+					if( adapter->default_vlan_tag != rd->rrd4 ) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } 
+						else if ( edma_cinfo->access_vlan_id > 0 && 
+								edma_cinfo->access_vlan_id == vlan  ) {
+							__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->access_vlan_id);
+						} else { 
+							/*printk(": (RX): Access Mode: Skb vlan(%d) != Access/Mgmt VlanID(%d/%d) : Result: Drop \n",
+									rd->rrd4, edma_cinfo->access_vlan_id, edma_cinfo->mgmt_vlan_id);*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} else {  /* Untagged Traffic */
+                        if ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+                            break;
+                        }
+						/*printk(": (RX): Access Mode: Skb vlan(%d) != AccessVlanID(%d) : Result: Drop \n",
+								edma_cinfo->access_vlan_id, rd->rrd4);*/
+						dev_kfree_skb_any( skb );
+						continue;
+					}
+					break;
+#else
+                    /* Step1: Tag the untagged traffic in Ethernet RX towards BSU 
+                     * Step2: Allow MgmtVLANID traffic if enabled for local access and drop any other Tagged Traffic */
+                    /*  Tagged Traffic */
+                    if( adapter->default_vlan_tag != rd->rrd4 ) {
+                        vlan = rd->rrd4;
+                        if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } 
+                        else { 
+                            /*printk(": (RX): Access Mode: Skb vlan(%d) != Access/Mgmt VlanID(%d/%d) : Result: Drop \n",
+                              rd->rrd4, edma_cinfo->access_vlan_id, edma_cinfo->mgmt_vlan_id);*/
+                            dev_kfree_skb_any( skb );
+                            continue;
+                        }
+                    } else {  /* Untagged Traffic */
+                        if ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+                            break;
+                        }
+                        /* Tag the Unatagged Traffic with Access VLAN-ID */
+                        __vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->access_vlan_id);
+                    }
+                    break;
+
+#endif
+				case EDMA_VLAN_MODE_QINQ:
+					/* Tagged Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } else {
+							if ( test_bit(vlan, edma_cinfo->vlan_bitmap) || edma_cinfo->allow_all_tagged_trunk ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+								/* Configure the SVLAN Parameters in skb parameters if enabled */
+								skb->vlan_proto_kwn = edma_cinfo->svlan_etherType;
+								skb->vlan_tci_kwn = edma_cinfo->svlan_id;
+							} else {
+								/*printk(":(RX): Trunk Mode: Skb vlan(%d) != Trunk Vlan Table: Result: Drop \n", 
+								  vlan);*/
+								dev_kfree_skb_any( skb );
+								continue;
+							}
+						}
+					} else { /* UnTagged Traffic */
+                        if ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+                            break;
+                        }
+						if ( edma_cinfo->allow_untagged ) {
+							if ( edma_cinfo->native_vlan_id > 0 ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->native_vlan_id);
+							} else {  /* Allow UnTagged packets when native vlanid is not set */; }
+						} else {
+							/*printk(": (RX): Trunk Mode: !AllowUntagged:  Skb UnTagged : Result: Drop \n");*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} 
+					break;
+				case EDMA_VLAN_MODE_PBB:
+					/* Tagged Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } else {
+							if ( test_bit(vlan, edma_cinfo->vlan_bitmap) || edma_cinfo->allow_all_tagged_trunk ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+								/* KWN: 802.1ad */
+								skb->vlan_proto_kwn = edma_cinfo->svlan_etherType;
+								skb->vlan_tci_kwn = edma_cinfo->svlan_id;
+								/* KWN: PBB */
+								memcpy(skb->pbb_da_mac, edma_cinfo->pbb_da_mac, 
+										sizeof(edma_cinfo->pbb_da_mac));
+								memcpy(skb->pbb_sa_mac, edma_cinfo->pbb_sa_mac, 
+										sizeof(edma_cinfo->pbb_sa_mac));
+								skb->pbb_bvid = edma_cinfo->pbb_bvid;
+								skb->pbb_isid = edma_cinfo->pbb_isid;
+							} else {
+								/*printk(":(RX): Trunk Mode: Skb vlan(%d) != Trunk Vlan Table: Result: Drop \n", 
+								  vlan);*/
+								dev_kfree_skb_any( skb );
+								continue;
+							}
+						}
+					} else { /* UnTagged Traffic */
+                        if ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+                            break;
+                        }
+						if ( edma_cinfo->allow_untagged ) {
+							if ( edma_cinfo->native_vlan_id > 0 ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->native_vlan_id);
+							} else {  /* Allow UnTagged packets when native vlanid is not set */; }
+						} else {
+							/*printk(": (RX): Trunk Mode: !AllowUntagged:  Skb UnTagged : Result: Drop \n");*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} 
+					break;
+				default:
+					break;
+			}
+#if 0
+			if (likely(rd->rrd7 & EDMA_RRD_CVLAN)) {
 					__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
-				else if (rd->rrd1 & EDMA_RRD_SVLAN)
+				}
+				else if (rd->rrd1 & EDMA_RRD_SVLAN) {
 					__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021AD), vlan);
-			}
-
+				}
+#endif
 			/* Update rx statistics */
 			adapter->stats.rx_packets++;
 			adapter->stats.rx_bytes += length;
 
+            /* Calculate rx throughput */
+            edma_cinfo->rx_offer_pkt_cnt++;
+            edma_cinfo->rx_offer_pkt_bytes_cnt += length;
+
+            if ( edma_cinfo->kwn_rx_tput_last_jiffies == 0 ) {
+                edma_cinfo->kwn_rx_tput_last_jiffies = jiffies;
+            } else {
+                if ( (jiffies - edma_cinfo->kwn_rx_tput_last_jiffies) >= 1000 )
+                {
+                    edma_cinfo->kwn_rx_tput_mbps = edma_cinfo->rx_offer_pkt_cnt > 0 ?
+                        ( ( ( edma_cinfo->rx_offer_pkt_bytes_cnt - edma_cinfo->rx_byte_drop_cnt )* 8)) : 0;
+                    edma_cinfo->kwn_rx_tput_last_jiffies = jiffies;
+                    edma_cinfo->rx_offer_pkt_cnt = 0;
+                    edma_cinfo->rx_offer_pkt_bytes_cnt = 0;
+                    edma_cinfo->rx_byte_drop_cnt = 0;
+#if 0
+                    printk(": RX Tput: %llu %llu %llu %llu\n",edma_cinfo->kwn_rx_tput_mbps, 
+                            edma_cinfo->kwn_tput_txseq,
+                            edma_cinfo->kwn_tput_rxseq,
+                            edma_cinfo->kwn_tput_rx_failed_cnt);
+#endif
+                }
+                else 
+                {
+                    if( !edma_cinfo->kwn_suservice ) {
+                        if ( memcmp( netdev->dev_addr, eth_hdr(skb)->h_dest, 6) != 0 ) {
+                            //if( edma_cinfo->rx_offer_pkt_bytes_cnt > ( (edma_cinfo->kwn_sukbps * 1000 ) / 8 ) ) 
+                            {
+                                edma_cinfo->rx_byte_drop_cnt += length;
+                                dev_kfree_skb_any( skb );
+                                continue;
+                            }
+                        }
+                    }
+                }
+            }
+
+            /* Process the KWN Ethernet Test packets */
+            /* In case of KWN Tput Packets, then drop them immediately */
+            if ( skb->len > 20 && 
+                    ( (memcmp(&skb->data[sizeof(struct ether_header)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap)) == 0) ||
+                      (memcmp(&skb->data[0], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap)) == 0) ) ) {
+                if ( 1  ) {
+                    struct kwn_tput_test_params *kparams;
+                    int offset = 0;
+
+                    //offset += sizeof(struct ether_header) + sizeof(kwn_tput_test_dsap);
+                    offset += sizeof(kwn_tput_test_dsap);
+                    kparams = (struct kwn_tput_test_params *)&skb->data[ offset ];
+                    if ( ntohl(kparams->kwn_tput_test_txseq) == 0 ) 
+                    {
+                        printk(": TPUT: Reset params: \n");
+                        /* Reset the params */
+                        edma_cinfo->kwn_tput_rxseq = 0;
+                        edma_cinfo->kwn_tput_rx_failed_cnt = 0;
+                        if ( edma_cinfo->kwn_start == 0 ) {
+                            /* Start the BiDi test based on input parameters */
+                            edma_cinfo->kwn_direction = ntohl(kparams->kwn_tput_test_direction);
+                            if ( edma_cinfo->kwn_direction == 3 ) {
+                                edma_cinfo->kwn_duration = ntohl(kparams->kwn_tput_test_duration);
+                                edma_cinfo->kwn_pkt_size = ntohl(kparams->kwn_tput_test_pktsize);
+                                edma_cinfo->kwn_pkt_per_ms = ntohl(kparams->kwn_tput_test_pktperms);
+                                memcpy(edma_cinfo->kwn_test_mac, eth_hdr(skb)->h_source, 6);
+                                /* Start the Test */
+                                printk(": @@@@@@@@@ BiDi KWN Tput Test : \n");
+                                edma_cinfo->kwn_tput_start_time = jiffies;
+                                edma_cinfo->kwn_tput_txseq = 0;
+                                edma_cinfo->kwn_start = 1;
+                                printk(": Bi-Di KWN Tput Test Started: \n");
+                                mod_timer(&edma_cinfo->kwn_tput_timer, jiffies + 1);
+                            }
+                        }
+                    } else {
+                        if( ntohl(kparams->kwn_tput_test_txseq) > edma_cinfo->kwn_tput_rxseq ) {
+                            if ( ntohl(kparams->kwn_tput_test_txseq) - edma_cinfo->kwn_tput_rxseq > 1 ) {
+                                edma_cinfo->kwn_tput_rx_failed_cnt += ( ntohl(kparams->kwn_tput_test_txseq) - edma_cinfo->kwn_tput_rxseq - 1 );
+                            }
+                            edma_cinfo->kwn_tput_rxseq = ntohl(kparams->kwn_tput_test_txseq);
+                        }
+                        else if( ntohl(kparams->kwn_tput_test_txseq) == edma_cinfo->kwn_tput_rxseq ) {
+                        }
+                        else {
+                            edma_cinfo->kwn_tput_rx_failed_cnt = ( edma_cinfo->kwn_tput_rx_failed_cnt > 0 ? 
+                                    edma_cinfo->kwn_tput_rx_failed_cnt - 1 : 0 );
+                        }
+                        /* Stop the BiDi test if started */
+                        edma_cinfo->kwn_start = ntohl(kparams->kwn_tput_start_test);
+                        if ( edma_cinfo->kwn_start == 0 && edma_cinfo->kwn_direction == 3 ) {
+                            edma_cinfo->kwn_tput_start_time = jiffies - edma_cinfo->kwn_duration;
+                        }
+                    }
+
+                }
+                dev_kfree_skb_any ( skb );
+                continue;
+            }
+
+
 			/* Check if we reached refill threshold */
 			if (cleaned_count == EDMA_RX_BUFFER_WRITE) {
 				ret_count = edma_alloc_rx_buf(edma_cinfo, erdr, cleaned_count, queue_id);
@@ -961,9 +1893,11 @@
 static void edma_free_rfs_flow_table(struct edma_adapter *adapter)
 {
 	int i;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 
 	/* Remove sync timer */
 	del_timer_sync(&adapter->rfs.expire_rfs);
+    del_timer_sync(&edma_cinfo->kwn_tput_timer);
 	spin_lock_bh(&adapter->rfs.rfs_ftab_lock);
 
 	/* Free EDMA RFS table entries */
@@ -1324,7 +2258,6 @@
 		word3 |= (1 << EDMA_TX_INS_CVLAN);
 		word3 |= (adapter->default_vlan_tag) << EDMA_TX_CVLAN_TAG_SHIFT;
 	}
-
 	if (packet_is_rstp) {
 		word3 |= dp_bitmap << EDMA_TPD_PORT_BITMAP_SHIFT;
 		word3 |= from_cpu << EDMA_TPD_FROM_CPU_SHIFT;
@@ -1535,6 +2468,38 @@
 	return __EDMA_LINKDOWN;
 }
 
+
+static loff_t pos = 0;
+int sify_filewrite (int input)
+{
+    struct file *file;
+    char up_data [] ="Ethernet is Up\n";  
+    char down_data [] ="Ethernet is Down\n"; 
+    mm_segment_t old_fs;
+
+    old_fs = get_fs();  //Save the current FS segment
+    set_fs(get_ds());
+
+    file = filp_open("/etc/eth_events.txt", O_WRONLY| O_CREAT| O_APPEND | O_SYNC, 0644);
+    if(file) {
+
+        if (input == 1)
+        {
+            vfs_write(file, up_data, (sizeof (up_data)), &pos);
+            pos = pos+(sizeof (up_data));
+        }
+        else
+        {
+            vfs_write(file, down_data, (sizeof(down_data)), &pos);
+            pos = pos+(sizeof (down_data));
+
+        }
+    }
+    filp_close(file,NULL);
+    set_fs(old_fs); //Reset to save FS
+    return 0;
+}
+
 /* edma_adjust_link()
  *	check for edma link status
  */
@@ -1551,12 +2516,14 @@
 
 	if (status == __EDMA_LINKUP && adapter->link_state == __EDMA_LINKDOWN) {
 		dev_info(&adapter->pdev->dev, "%s: GMAC Link is up with phy_speed=%d\n", netdev->name, phydev->speed);
+                //sify_filewrite(1);
 		adapter->link_state = __EDMA_LINKUP;
 		netif_carrier_on(netdev);
 		if (netif_running(netdev))
 			netif_tx_wake_all_queues(netdev);
 	} else if (status == __EDMA_LINKDOWN && adapter->link_state == __EDMA_LINKUP) {
 		dev_info(&adapter->pdev->dev, "%s: GMAC Link is down\n", netdev->name);
+                //sify_filewrite(0);
 		adapter->link_state = __EDMA_LINKDOWN;
 		netif_carrier_off(netdev);
 		netif_tx_stop_all_queues(netdev);
@@ -1576,6 +2543,68 @@
 	return stats;
 }
 
+void edma_send_tput_tx(unsigned long data)
+{
+	struct edma_adapter *adapter = (struct edma_adapter *)data;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int pkt_per_ms = edma_cinfo->kwn_pkt_per_ms;
+  	int pkt_size = edma_cinfo->kwn_pkt_size;
+	struct ether_header *eth;
+	struct net_device *dev;
+	struct kwn_tput_test_params *kparams;
+
+	if ( (dev = dev_get_by_name( &init_net, "eth0" )) == NULL )
+		return;
+
+    /* Calculate packet count per ms */
+	for ( ; pkt_per_ms > 0; --pkt_per_ms )
+	{
+        struct sk_buff *skb = NULL;
+        int offset = 0;
+		/* Create a packet */
+		skb = dev_alloc_skb ( pkt_size + 64 );
+		if ( skb == NULL ) {
+			return;
+		}
+		/* Fill the skb content */
+		skb_reserve( skb, 64 );
+		
+        skb_put( skb, pkt_size );
+		
+		skb->dev = dev;
+        
+        eth = (struct ether_header *)skb->data;
+        memcpy( eth->ether_shost, dev->dev_addr, 6 );
+        memcpy( eth->ether_dhost, edma_cinfo->kwn_test_mac, 6 );
+		eth->ether_type = htons( skb->len - sizeof(*eth) );
+		
+        memcpy(&skb->data[sizeof(*eth)], kwn_tput_test_dsap, sizeof(kwn_tput_test_dsap));
+        offset += sizeof(*eth) + sizeof(kwn_tput_test_dsap);
+        
+        kparams = (struct kwn_tput_test_params *)&skb->data[offset];
+        
+        kparams->kwn_tput_test_duration = htonl(edma_cinfo->kwn_duration);
+        kparams->kwn_tput_test_pktsize = htonl(edma_cinfo->kwn_pkt_size);
+        kparams->kwn_tput_test_pktperms = htonl(edma_cinfo->kwn_pkt_per_ms);
+        kparams->kwn_tput_test_direction = htonl(edma_cinfo->kwn_direction);
+        kparams->kwn_tput_test_txseq = htonl(edma_cinfo->kwn_tput_txseq);
+        kparams->kwn_tput_start_test = htonl(edma_cinfo->kwn_start);
+        ++edma_cinfo->kwn_tput_txseq;
+        skb_reset_mac_header( skb );
+        dev_queue_xmit( skb );
+	}
+	/* Schedule Tx Tasklet when test duration is not completed */
+    if ( edma_cinfo->kwn_tput_start_time &&
+            (( jiffies - edma_cinfo->kwn_tput_start_time ) < edma_cinfo->kwn_duration )) {
+        mod_timer(&edma_cinfo->kwn_tput_timer, jiffies + 1);
+    } else {
+        printk(": KWN Tput Test Completed: \n");
+        edma_cinfo->kwn_start = 0;
+    }
+	dev_put( dev );	
+	return;
+}
+
 /* edma_xmit()
  *	Main api to be called by the core for packet transmission
  */
@@ -1590,6 +2619,7 @@
 	unsigned int flags_transmit = 0;
 	bool packet_is_rstp = false;
 	struct netdev_queue *nq = NULL;
+	u16 vlan = 0;
 
 	if (skb_shinfo(skb)->nr_frags) {
 		nr_frags_first = skb_shinfo(skb)->nr_frags;
@@ -1651,13 +2681,212 @@
 		edma_cinfo->edma_ethstats.tx_desc_error++;
 		return NETDEV_TX_BUSY;
 	}
+   
+    /* Advanced Ethernet statitics */
+    if ( is_multicast_ether_addr( eth_hdr(skb)->h_dest ) )
+    {
+        edma_cinfo->fil_drop_count.kwn_tx_multicast++;
+    }
+    if ( is_unicast_ether_addr( eth_hdr(skb)->h_dest ) )
+    {
+        edma_cinfo->fil_drop_count.kwn_tx_unicast++;
+    }
+
+
+    /* KWN FILTERING */
+    if ( edma_cinfo->kwn_fil_status && ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) != 0 )  )
+    {
+        if ( edma_cinfo->kwn_fil_l2mcast )
+        {
+            if ( is_multicast_ether_addr( eth_hdr(skb)->h_dest ) )
+            {
+                edma_cinfo->fil_drop_count.kwn_fil_tx_l2mcast_dropcnt++;
+                goto drop1;
+            }
+        }
+        if ( edma_cinfo->kwn_fil_l2bcast )
+        {
+            if ( is_broadcast_ether_addr(eth_hdr(skb)->h_dest) )
+            {
+                edma_cinfo->fil_drop_count.kwn_fil_tx_l2bcast_dropcnt++;
+                goto drop1;
+            }
+        }
+        if ( edma_cinfo->kwn_fil_l3mcast )
+        {
+            if ( ipv4_is_multicast(ip_hdr(skb)->daddr) )
+            {
+                edma_cinfo->fil_drop_count.kwn_fil_tx_l3mcast_dropcnt++;
+                goto drop1;
+            }
+        }
+        if ( edma_cinfo->kwn_fil_l3bcast )
+        {
+            if ( ipv4_is_lbcast(ip_hdr(skb)->daddr) )
+            {
+                edma_cinfo->fil_drop_count.kwn_fil_tx_l3bcast_dropcnt++;
+                goto drop1;
+            }
+        }
+    }
+
+    /* KWN: Vlan Egress Path */
+	switch( edma_cinfo->vlan_mode ) 
+	{
+		case EDMA_VLAN_MODE_TRANSPARENT:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0 && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(": Transparent Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+			}
+			break;
+		case EDMA_VLAN_MODE_TRUNK:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(": (TX): Trunk Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			}
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			/* 802.1Q Enabled - Tagged Traffic */
+			if ( vlan_tx_tag_present( skb ) ) {
+				vlan = vlan_tx_tag_get( skb );
+				if( edma_cinfo->allow_untagged && 
+						vlan == edma_cinfo->native_vlan_id ) {
+					skb = skb_vlan_untag( skb );
+					if ( unlikely(!skb) ) { 
+						/*printk(": (TX): Trunk Mode: SKB Untag Failed: Result: Drop\n");*/
+						goto drop;
+					}
+				} else if ( vlan == edma_cinfo->mgmt_vlan_id ) {
+					;
+				} else if ( !edma_cinfo->allow_all_tagged_trunk &&
+						!test_bit(vlan, edma_cinfo->vlan_bitmap) ) {
+					/*printk(": (TX): Trunk Mode: SKB Vlan(%d) != VLan Trunk Table: Result: Drop\n",
+							vlan);*/
+					goto drop1;
+				} 
+			} else { /* UnTagged Traffic */
+				if ( (!edma_cinfo->allow_untagged) ||
+						(edma_cinfo->allow_untagged &&
+						 edma_cinfo->native_vlan_id > 0) ) {
+					/*printk(":(TX): Trunk Mode: SKB UnTagged: Native VlanID(%d) Set: Result: Drop\n",
+					  edma_cinfo->native_vlan_id);*/
+					goto drop1;
+				}
+			}
+			break;
+		case EDMA_VLAN_MODE_ACCESS:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(":(TX): Access Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			} 		
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			/* Tagged Traffic */
+			if ( vlan_tx_tag_present( skb ) ) {
+				vlan = vlan_tx_tag_get( skb );
+				if( edma_cinfo->access_vlan_id > 0 && 
+						vlan == edma_cinfo->access_vlan_id ) {
+					skb = skb_vlan_untag( skb );
+					if ( unlikely(!skb) ) { 
+						/*printk(":(TX): Access Mode: SKB Untag Failed: Result: Drop\n");*/
+						goto drop;
+					}
+                    skb->vlan_tci = 0;
+				} else if ( vlan == edma_cinfo->mgmt_vlan_id ) {
+					;
+				} else {
+					/*printk(":(TX): Access Mode: Skb Tagged Pkt(%d) != Access VlanId(%d): Result: Drop\n",
+							vlan, edma_cinfo->access_vlan_id);*/
+					goto drop1;
+				}	
+			} else {
+				/*printk(":(TX): Access Mode: UnTagged Packet in Egress Path : Result: Drop\n");*/
+				goto drop1;
+			} 
+			break;
+		case EDMA_VLAN_MODE_QINQ:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(":(TX): Access Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			}
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			/* QinQ Enabled - Tagged Traffic */
+			if ( edma_cinfo->svlan_id > 0 ) {
+				if ( skb->protocol == cpu_to_be16( ETH_P_8021AD ) ||
+						skb->protocol == cpu_to_be16( ETH_P_8021AH ) ) {
+					uint8_t *var;
+					struct vlan_ethhdr *vhdr;
+					var = ( uint8_t *)skb->data;
+					memmove( var + 4, var, 12 );
+					skb_pull( skb, 4 );
+					vhdr = (struct vlan_ethhdr *)skb->data;
+					vlan = ntohs(vhdr->h_vlan_TCI);
+					skb->vlan_tci = 0;
+					if ( !edma_cinfo->allow_all_tagged_trunk &&
+							!test_bit(vlan, edma_cinfo->vlan_bitmap) ) {
+						/*printk(": (SVLAN: TX): Trunk Mode: SKB Vlan(%d) != VLan Trunk" 
+						  "Table: Result: Drop\n",
+						  vlan);*/
+						goto drop1;
+					}
+				} else if ( skb->protocol == cpu_to_be16( ETH_P_8021Q )) {
+					struct vlan_ethhdr *vhdr;
+					vhdr = (struct vlan_ethhdr *)skb->data;
+					vlan = ntohs(vhdr->h_vlan_TCI);
+					skb->vlan_tci = 0;
+					if ( !edma_cinfo->allow_all_tagged_trunk &&
+							!test_bit(vlan, edma_cinfo->vlan_bitmap) ) {
+						/*printk(": (SVLAN: TX): Trunk Mode: SKB Vlan(%d) != VLan Trunk" 
+						  "Table: Result: Drop\n",
+						  vlan);*/
+						goto drop1;
+					}
+				}
+				break;
+			}
+			break;
+		case EDMA_VLAN_MODE_PBB:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(":(TX): Access Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			}
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			break;
+		default:
+			break;
+	}
+
+	/* KWN: Vlan SW Tagging in XMIT Path */
+	if ( vlan_tx_tag_present( skb ) ) {
+		vlan = vlan_tx_tag_get( skb );
+		skb = __vlan_put_tag( skb, skb->vlan_proto, vlan );
+		if (unlikely(!skb)) {
+			goto drop;
+		}
+		skb->vlan_tci = 0;
+	}
 
 	/* Check and mark VLAN tag offload */
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 21))
-	if (vlan_tx_tag_present(skb))
+	if (vlan_tx_tag_present(skb)) 
 #else
-	if (skb_vlan_tag_present(skb))
-#endif
+	if (skb_vlan_tag_present(skb)) 
+#endif 
 		flags_transmit |= EDMA_VLAN_TX_TAG_INSERT_FLAG;
 	else if (adapter->default_vlan_tag)
 		flags_transmit |= EDMA_VLAN_TX_TAG_INSERT_DEFAULT_FLAG;
@@ -1683,6 +2912,30 @@
 	adapter->stats.tx_packets++;
 	adapter->stats.tx_bytes += skb->len;
 
+    edma_cinfo->tx_offer_pkt_cnt++;
+    edma_cinfo->tx_offer_pkt_bytes_cnt += skb->len;
+
+    if ( edma_cinfo->kwn_tx_tput_last_jiffies == 0 ) {
+        edma_cinfo->kwn_tx_tput_last_jiffies = jiffies;
+    } else {
+        if ( (jiffies - edma_cinfo->kwn_tx_tput_last_jiffies) >= 1000 )
+        {
+            edma_cinfo->kwn_tx_tput_mbps = edma_cinfo->tx_offer_pkt_cnt > 0 ?
+                ( (edma_cinfo->tx_offer_pkt_bytes_cnt * 8)) : 0;
+            edma_cinfo->kwn_tx_tput_last_jiffies = jiffies;
+            edma_cinfo->tx_offer_pkt_cnt = 0;
+            edma_cinfo->tx_offer_pkt_bytes_cnt = 0;
+            //printk(": Tx Tput: %llu\n",edma_cinfo->kwn_tx_tput_mbps);
+        }
+    }
+	goto netdev_okay;
+
+drop1:
+	dev_kfree_skb_any(skb);
+drop:
+	adapter->stats.tx_errors++;
+	goto netdev_okay;
+	
 netdev_okay:
 	local_bh_enable();
 	return NETDEV_TX_OK;
@@ -2297,6 +3550,7 @@
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
 	struct platform_device *pdev = adapter->edma_cinfo->pdev;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 
 	netif_tx_start_all_queues(netdev);
 	edma_initialise_rfs_flow_table(adapter);
@@ -2318,6 +3572,11 @@
 		adapter->link_state = __EDMA_LINKUP;
 		netif_carrier_on(netdev);
 	}
+
+    /* KWN */
+    init_timer(&edma_cinfo->kwn_tput_timer);
+    edma_cinfo->kwn_tput_timer.function = edma_send_tput_tx;
+    edma_cinfo->kwn_tput_timer.data = (unsigned long)adapter;
 	mutex_unlock(&adapter->poll_mutex);
 
 	return 0;
diff -urN qca-edma-org/edma.h qca-edma-mod/edma.h
--- qca-edma-org/edma.h	2018-07-09 14:25:58.833210000 +0530
+++ qca-edma-mod/edma.h	2018-12-23 20:27:59.388253885 +0530
@@ -44,6 +44,12 @@
 #include <linux/if_pppox.h>
 #include "ess_edma.h"
 
+#define EDMA_VLAN_MODE_TRANSPARENT	0
+#define EDMA_VLAN_MODE_ACCESS		1
+#define EDMA_VLAN_MODE_TRUNK		2
+#define EDMA_VLAN_MODE_QINQ		3
+#define EDMA_VLAN_MODE_PBB		4
+
 #define EDMA_CPU_CORES_SUPPORTED 4
 #define EDMA_MAX_PORTID_SUPPORTED 5
 #define EDMA_MAX_VLAN_SUPPORTED  EDMA_MAX_PORTID_SUPPORTED
@@ -366,6 +372,20 @@
 	struct edma_common_info *edma_cinfo; /* edma common info */
 };
 
+struct edma_drop_count {
+    u64 kwn_fil_tx_l2mcast_dropcnt;
+    u64 kwn_fil_rx_l2mcast_dropcnt;
+    u64 kwn_fil_tx_l3mcast_dropcnt;
+    u64 kwn_fil_rx_l3mcast_dropcnt;
+    u64 kwn_fil_tx_l2bcast_dropcnt;
+    u64 kwn_fil_rx_l2bcast_dropcnt;
+    u64 kwn_fil_tx_l3bcast_dropcnt;
+    u64 kwn_fil_rx_l3bcast_dropcnt;
+    u64 kwn_tx_multicast;
+    u64 kwn_tx_unicast;
+    u64 kwn_rx_unicast;
+};
+
 /* edma specific common info */
 struct edma_common_info {
 	struct edma_tx_desc_ring *tpd_ring[16]; /* 16 Tx queues */
@@ -393,6 +413,49 @@
 	struct edma_per_cpu_queues_info edma_percpu_info[CONFIG_NR_CPUS]; /* per cpu information */
 	spinlock_t stats_lock; /* protect edma stats area for updation */
 	u32 num_cores;
+	/* KWN: Vlan Parameters */
+	unsigned long vlan_bitmap[512];	/* Vlan Trunk Table */
+	int8_t vlan_mode;	/* Vlan Modes: Transparent, Access, Trunk & QinQ */
+	int8_t allow_untagged;	/* Allow UnTagged in Trunk Mode */
+	int16_t access_vlan_id;	/* Tag UnTagged traffic in Access Mode */
+	int16_t native_vlan_id;	/* Tag UnTagged traffic in Trunk Mode */
+	int16_t mgmt_vlan_id;	/* Tag UnTagged traffic in all modes */
+	int8_t allow_all_tagged_trunk; /* Allow all Tagged traffic in Trunk Mode */
+	int16_t svlan_id;	/* SVLAN-ID */
+	uint16_t svlan_etherType;	/* SVLAN: EtherType */
+	uint8_t pbb_da_mac[6];	/* PBB: B-DA-MAC */
+	uint8_t pbb_sa_mac[6];	/* PBB: B-SA-MAC */
+	int16_t pbb_bvid;		/* PBB: B-VLAN-ID */
+	int32_t pbb_isid;		/* PBB: B-I-SID */
+	int8_t allow_tagged_mgmt;	/* Allow Tagged Mgmt */
+	uint64_t tx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+	uint64_t tx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+	uint64_t kwn_tx_tput_mbps;
+	uint64_t kwn_tx_tput_last_jiffies;
+	uint64_t rx_offer_pkt_cnt;
+	uint64_t rx_offer_pkt_bytes_cnt;
+	uint64_t kwn_rx_tput_mbps;
+	uint64_t kwn_rx_tput_last_jiffies;
+    uint64_t rx_byte_drop_cnt;
+    uint8_t kwn_suservice;
+	uint32_t kwn_sukbps;
+    uint8_t kwn_fil_status;
+    uint8_t kwn_fil_l2mcast;
+    uint8_t kwn_fil_l3mcast;
+    uint8_t kwn_fil_l2bcast;
+    uint8_t kwn_fil_l3bcast;
+    struct edma_drop_count fil_drop_count;
+    uint32_t kwn_pkt_per_ms;
+    uint32_t kwn_pkt_size;
+    uint32_t kwn_duration;
+    uint32_t kwn_direction;
+	uint8_t  kwn_test_mac[6];	/* KWN Test MAC */
+    uint32_t kwn_start;
+    uint64_t kwn_tput_start_time;
+    uint64_t kwn_tput_txseq;
+    uint64_t kwn_tput_rxseq;
+    uint64_t kwn_tput_rx_failed_cnt;
+	struct timer_list kwn_tput_timer; /* timer function for edma_rps_may_expire_flow */
 };
 
 /* transimit packet descriptor (tpd) ring */
@@ -441,6 +504,13 @@
 	struct timer_list expire_rfs; /* timer function for edma_rps_may_expire_flow */
 };
 
+struct ether_header {
+    uint8_t    ether_dhost[6];
+    uint8_t    ether_shost[6];
+    uint16_t   ether_type;
+} __packed;
+
+
 /* EDMA net device structure */
 struct edma_adapter {
 	struct net_device *netdev; /* netdevice */
@@ -473,6 +543,16 @@
 	__be16 proto;
 };
 
+/* KWN: PBB */
+struct kwn_pbb {
+	uint8_t  b_da_mac[6];
+	uint8_t  b_sa_mac[6];
+	uint16_t b_vid;
+	uint16_t tpid;
+	uint32_t i_sid;
+};
+
+
 int edma_alloc_queues_tx(struct edma_common_info *edma_cinfo);
 int edma_alloc_queues_rx(struct edma_common_info *edma_cinfo);
 int edma_open(struct net_device *netdev);
@@ -547,4 +627,61 @@
 void edma_iad_process_flow(struct edma_common_info *edma_cinfo,
 			   struct sk_buff *skb, u8 dir, u8 precedence);
 
+/* KWN: Routines to maintain the VID Information */
+int edma_set_vid_bitmap(struct net_device *dev, int16_t vid, int16_t flags);
+int edma_clear_vid_bitmap(struct net_device *dev, int16_t vid);
+int edma_set_vlan_mode(struct net_device *dev, int8_t vlan_mode);
+int edma_set_allow_tagged_mgmt(struct net_device *dev, int8_t allow_tagged_mgmt);
+int edma_set_allow_untagged(struct net_device *dev, int8_t allow_untagged);
+int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all );
+int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_get_mgmt_vlan_id( struct net_device *dev );
+int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType );
+uint64_t edma_get_tx_pkts( struct net_device *dev );
+uint64_t edma_get_tx_errors( struct net_device *dev );
+uint64_t edma_get_tx_bytes( struct net_device *dev );
+uint64_t edma_get_tx_thrpt( struct net_device *dev );
+uint64_t edma_get_rx_pkts( struct net_device *dev );
+uint64_t edma_get_rx_errors( struct net_device *dev );
+uint64_t edma_get_rx_bytes( struct net_device *dev );
+uint64_t edma_get_rx_thrpt( struct net_device *dev );
+int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac );
+int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac );
+int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id );
+int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id );
+int edma_set_suservice( struct net_device *dev, uint8_t suservice );
+int edma_set_sukbps( struct net_device *dev, uint32_t kbps );
+int edma_clear_eth_stats( struct net_device *dev );
+int edma_filtering_status( struct net_device *dev, uint8_t status );
+int edma_filtering_l2mcast( struct net_device *dev, uint8_t l2mcast );
+int edma_filtering_l3mcast( struct net_device *dev, uint8_t l3mcast );
+int edma_filtering_l2bcast( struct net_device *dev, uint8_t l2bcast );
+int edma_filtering_l3bcast( struct net_device *dev, uint8_t l3bcast );
+uint64_t edma_get_fil_tx_l2mcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_rx_l2mcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_tx_l3mcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_rx_l3mcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_tx_l2bcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_rx_l2bcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_tx_l3bcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_fil_rx_l3bcast_drpcnt( struct net_device *dev );
+uint64_t edma_get_tx_failure( struct net_device *dev );
+uint64_t edma_get_rx_failure( struct net_device *dev );
+uint64_t edma_get_rx_crc_errors( struct net_device *dev );
+uint64_t edma_get_rx_frame_oversize_errors( struct net_device *dev );
+uint64_t edma_get_rx_frame_overrun_errors( struct net_device *dev );
+uint64_t edma_get_tx_multicastpkt( struct net_device *dev );
+uint64_t edma_get_rx_multicastpkt( struct net_device *dev );
+uint64_t edma_get_tx_unicastpkt( struct net_device *dev );
+uint64_t edma_get_rx_unicastpkt( struct net_device *dev );
+int edma_set_kwn_tput_pkt_per_ms( struct net_device *dev, uint32_t pkt_per_ms );
+int edma_set_kwn_tput_pkt_size( struct net_device *dev, uint32_t pkt_size );
+int edma_set_kwn_tput_duration( struct net_device *dev, uint32_t duration );
+int edma_set_kwn_tput_direction( struct net_device *dev, uint32_t direction );
+int edma_set_kwn_test_mac( struct net_device *dev, uint8_t *mac );
+int edma_set_kwn_tput_start( struct net_device *dev, uint32_t start );
+uint64_t edma_get_kwn_tput_rxseq_failed_cnt( struct net_device *dev );
 #endif /* _EDMA_H_ */
