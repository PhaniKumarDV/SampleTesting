diff -urN qca-edma-org/edma.c qca-edma-mod/edma.c
--- qca-edma-org/edma.c	2018-07-09 14:25:58.833210000 +0530
+++ qca-edma-mod/edma.c	2018-11-23 12:20:15.015723631 +0530
@@ -26,6 +26,258 @@
 extern u8 edma_per_prec_stats_enable;
 extern u32 edma_iad_stats_enable;
 
+/* KWN: Export VLAN Routines for accessibility to the wifi driver */
+EXPORT_SYMBOL(edma_set_vid_bitmap);
+EXPORT_SYMBOL(edma_clear_vid_bitmap);
+EXPORT_SYMBOL(edma_set_vlan_mode);
+EXPORT_SYMBOL(edma_set_allow_tagged_mgmt);
+EXPORT_SYMBOL(edma_set_allow_untagged);
+EXPORT_SYMBOL(edma_set_allow_all_tagged_trunk);
+EXPORT_SYMBOL(edma_set_access_vlan_id);
+EXPORT_SYMBOL(edma_set_native_vlan_id);
+EXPORT_SYMBOL(edma_set_mgmt_vlan_id);
+EXPORT_SYMBOL(edma_get_mgmt_vlan_id);
+EXPORT_SYMBOL(edma_set_svlan_id);
+EXPORT_SYMBOL(edma_set_svlan_etherType);
+EXPORT_SYMBOL(edma_get_tx_pkts);
+EXPORT_SYMBOL(edma_get_tx_errors);
+EXPORT_SYMBOL(edma_get_tx_bytes);
+EXPORT_SYMBOL(edma_get_tx_thrpt);
+EXPORT_SYMBOL(edma_get_rx_pkts);
+EXPORT_SYMBOL(edma_get_rx_errors);
+EXPORT_SYMBOL(edma_get_rx_bytes);
+EXPORT_SYMBOL(edma_get_rx_thrpt);
+EXPORT_SYMBOL(edma_set_pbb_da_mac);
+EXPORT_SYMBOL(edma_set_pbb_sa_mac);
+EXPORT_SYMBOL(edma_set_pbb_bvid);
+EXPORT_SYMBOL(edma_set_pbb_isid);
+
+uint64_t edma_get_tx_pkts( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_packets;
+	return value;
+}
+
+uint64_t edma_get_tx_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_errors;
+	return value;
+}
+
+uint64_t edma_get_tx_bytes( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.tx_bytes;
+	return value;
+}
+
+uint64_t edma_get_tx_thrpt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    unsigned long value;
+
+    value = edma_cinfo->kwn_tx_tput_mbps;
+	return value;
+}
+
+uint64_t edma_get_rx_pkts( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_packets;
+	return value;
+}
+
+uint64_t edma_get_rx_errors( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_errors;
+	return value;
+}
+
+uint64_t edma_get_rx_bytes( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+    unsigned long value;
+
+    value = adapter->stats.rx_bytes;
+	return value;
+}
+
+uint64_t edma_get_rx_thrpt( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+    unsigned long value;
+
+    value = edma_cinfo->kwn_rx_tput_mbps;
+	return value;
+}
+
+int edma_set_vid_bitmap( struct net_device *dev, int16_t vid, int16_t flags )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	set_bit(vid, edma_cinfo->vlan_bitmap);
+	printk(":@@@@@@@@@@ set_vid: %d\n",vid);
+	return 0;
+}
+
+int edma_clear_vid_bitmap( struct net_device *dev, int16_t vid )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	if ( vid == 0 ) {
+		bitmap_zero(edma_cinfo->vlan_bitmap, 4096);
+		printk(":@@@@@@@@@@ clear_all_vids: %d\n",vid);
+	}
+	else {
+		clear_bit(vid, edma_cinfo->vlan_bitmap);
+		printk(":@@@@@@@@@@ clear_vid: %d\n",vid);
+	}
+	return 0;
+}
+
+int edma_set_vlan_mode( struct net_device *dev, int8_t vlan_mode )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->vlan_mode = vlan_mode;
+	printk(": @@@@@@@@@ VLAN Mode: %d\n",vlan_mode);
+	return 0;
+}
+
+int edma_set_allow_tagged_mgmt( struct net_device *dev, int8_t allow_tagged_mgmt )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_tagged_mgmt = allow_tagged_mgmt;
+	printk(": @@@@@@@@@ Allow Tagged Mgmt: %d\n",allow_tagged_mgmt );
+	return 0;
+}
+
+int edma_set_allow_untagged( struct net_device *dev, int8_t allow_untagged )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_untagged = allow_untagged;
+	printk(": @@@@@@@@@ Allow Untagged : %d\n",allow_untagged );
+	return 0;
+}
+
+int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->allow_all_tagged_trunk = allow_all;
+	printk(": @@@@@@@@@ Allow All Tagged Trunk : %d\n",allow_all );
+	return 0;
+}
+
+int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->access_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Access VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->native_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Native VlanId : %d\n",vlan_id );
+	return 0;
+}
+
+int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->mgmt_vlan_id = vlan_id;
+	printk(": @@@@@@@@@ Mgmt VlanId : %d\n",vlan_id );
+	return 0;
+}
+int edma_get_mgmt_vlan_id( struct net_device *dev )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	return edma_cinfo->mgmt_vlan_id;
+}
+
+int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->svlan_id = vlan_id;
+	printk(": @@@@@@@@@ SVlanId : %d\n",vlan_id );
+	return 0;
+}
+int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->svlan_etherType = etherType;
+	printk(": @@@@@@@@@ SVLan EtherType : %x\n",etherType );
+	return 0;
+}
+int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int i = 0;
+	memcpy(edma_cinfo->pbb_da_mac, mac, 6);
+	printk("@@@@@@@ PBB B-DA-MAC: ");
+	for ( i = 0; i < 6; i++ ) {
+		printk(": %x",mac[i]);
+	}
+	printk("\n");
+	return 0;
+}
+int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int i = 0;
+	memcpy(edma_cinfo->pbb_sa_mac, mac, 6);
+	printk("@@@@@@@ PBB B-SA-MAC: ");
+	for ( i = 0; i < 6; i++ ) {
+		printk(": %x",mac[i]);
+	}
+	printk("\n");
+	return 0;
+}
+int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->pbb_bvid = vlan_id;
+	printk(": @@@@@@@@@ PBB B VlanID : %d\n",vlan_id );
+	return 0;
+}
+int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id )
+{
+	struct edma_adapter *adapter = netdev_priv(dev);
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	edma_cinfo->pbb_isid = vlan_id;
+	printk(": @@@@@@@@@ PBB B VlanID : %d\n",vlan_id );
+	return 0;
+}
+
 /* edma_skb_priority_offset()
  *	get edma skb priority
  */
@@ -777,19 +1029,175 @@
 #endif
 			edma_receive_checksum(rd, skb);
 
-			/* Process VLAN HW acceleration indication provided by HW */
-			if (adapter->default_vlan_tag != rd->rrd4) {
-				vlan = rd->rrd4;
-				if (likely(rd->rrd7 & EDMA_RRD_CVLAN))
+#if 0
+			printk("RRD Dump\n rrd0:%x rrd1: %x rrd2: %x rrd3: %x rrd4: %x rrd5: %x rrd6: %x rrd7: %x",
+					rd->rrd0, rd->rrd1, rd->rrd2, rd->rrd3, rd->rrd4, rd->rrd5, rd->rrd6, rd->rrd7);
+			printk("Num_rfds: %d, src_port: %d, pkt_size: %d, cvlan_tag: %d svlan_tag: %d protocol: %x\n",
+					num_rfds, rd->rrd1 & EDMA_RRD_SRC_PORT_NUM_MASK,
+					rd->rrd6 & EDMA_RRD_PKT_SIZE_MASK, rd->rrd7 & EDMA_RRD_CVLAN, rd->rrd1 & EDMA_RRD_SVLAN, skb->protocol);
+#endif
+
+			skb->vlan_proto_kwn = 0;
+			skb->vlan_tci_kwn = 0;
+			skb->pbb_bvid = 0;
+			skb->pbb_isid = 0;
+			
+			/* KWN: Vlan Ingress Path */
+			switch( edma_cinfo->vlan_mode ) 
+			{
+				case EDMA_VLAN_MODE_TRANSPARENT:
+					/* Allow Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan != edma_cinfo->mgmt_vlan_id ) {
+							__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+						}
+					} 
+					break;
+				case EDMA_VLAN_MODE_TRUNK:
+					/* Tagged Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } else {
+							if ( test_bit(vlan, edma_cinfo->vlan_bitmap) || edma_cinfo->allow_all_tagged_trunk ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+							} else {
+								/*printk(":(RX): Trunk Mode: Skb vlan(%d) != Trunk Vlan Table: Result: Drop \n", 
+										vlan);*/
+								dev_kfree_skb_any( skb );
+								continue;
+							}
+						}
+					} else { /* UnTagged Traffic */
+						if ( edma_cinfo->allow_untagged ) {
+							if ( edma_cinfo->native_vlan_id > 0 ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->native_vlan_id);
+							} else {  /* Allow UnTagged packets when native vlanid is not set */; }
+						} else {
+							/*printk(": (RX): Trunk Mode: !AllowUntagged:  Skb UnTagged : Result: Drop \n");*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} 
+					break;
+				case EDMA_VLAN_MODE_ACCESS:
+					if( adapter->default_vlan_tag != rd->rrd4 ) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } 
+						else if ( edma_cinfo->access_vlan_id > 0 && 
+								edma_cinfo->access_vlan_id == vlan  ) {
+							__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->access_vlan_id);
+						} else { 
+							/*printk(": (RX): Access Mode: Skb vlan(%d) != Access/Mgmt VlanID(%d/%d) : Result: Drop \n",
+									rd->rrd4, edma_cinfo->access_vlan_id, edma_cinfo->mgmt_vlan_id);*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} else {
+						/*printk(": (RX): Access Mode: Skb vlan(%d) != AccessVlanID(%d) : Result: Drop \n",
+								edma_cinfo->access_vlan_id, rd->rrd4);*/
+						dev_kfree_skb_any( skb );
+						continue;
+					}
+					break;
+				case EDMA_VLAN_MODE_QINQ:
+					/* Tagged Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } else {
+							if ( test_bit(vlan, edma_cinfo->vlan_bitmap) || edma_cinfo->allow_all_tagged_trunk ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+								/* Configure the SVLAN Parameters in skb parameters if enabled */
+								skb->vlan_proto_kwn = edma_cinfo->svlan_etherType;
+								skb->vlan_tci_kwn = edma_cinfo->svlan_id;
+							} else {
+								/*printk(":(RX): Trunk Mode: Skb vlan(%d) != Trunk Vlan Table: Result: Drop \n", 
+								  vlan);*/
+								dev_kfree_skb_any( skb );
+								continue;
+							}
+						}
+					} else { /* UnTagged Traffic */
+						if ( edma_cinfo->allow_untagged ) {
+							if ( edma_cinfo->native_vlan_id > 0 ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->native_vlan_id);
+							} else {  /* Allow UnTagged packets when native vlanid is not set */; }
+						} else {
+							/*printk(": (RX): Trunk Mode: !AllowUntagged:  Skb UnTagged : Result: Drop \n");*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} 
+					break;
+				case EDMA_VLAN_MODE_PBB:
+					/* Tagged Traffic */
+					if (adapter->default_vlan_tag != rd->rrd4) {
+						vlan = rd->rrd4;
+						if ( vlan == edma_cinfo->mgmt_vlan_id ) { ; } else {
+							if ( test_bit(vlan, edma_cinfo->vlan_bitmap) || edma_cinfo->allow_all_tagged_trunk ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
+								/* KWN: 802.1ad */
+								skb->vlan_proto_kwn = edma_cinfo->svlan_etherType;
+								skb->vlan_tci_kwn = edma_cinfo->svlan_id;
+								/* KWN: PBB */
+								memcpy(skb->pbb_da_mac, edma_cinfo->pbb_da_mac, 
+										sizeof(edma_cinfo->pbb_da_mac));
+								memcpy(skb->pbb_sa_mac, edma_cinfo->pbb_sa_mac, 
+										sizeof(edma_cinfo->pbb_sa_mac));
+								skb->pbb_bvid = edma_cinfo->pbb_bvid;
+								skb->pbb_isid = edma_cinfo->pbb_isid;
+							} else {
+								/*printk(":(RX): Trunk Mode: Skb vlan(%d) != Trunk Vlan Table: Result: Drop \n", 
+								  vlan);*/
+								dev_kfree_skb_any( skb );
+								continue;
+							}
+						}
+					} else { /* UnTagged Traffic */
+						if ( edma_cinfo->allow_untagged ) {
+							if ( edma_cinfo->native_vlan_id > 0 ) {
+								__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->native_vlan_id);
+							} else {  /* Allow UnTagged packets when native vlanid is not set */; }
+						} else {
+							/*printk(": (RX): Trunk Mode: !AllowUntagged:  Skb UnTagged : Result: Drop \n");*/
+							dev_kfree_skb_any( skb );
+							continue;
+						}
+					} 
+					break;
+				default:
+					break;
+			}
+#if 0
+			if (likely(rd->rrd7 & EDMA_RRD_CVLAN)) {
 					__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);
-				else if (rd->rrd1 & EDMA_RRD_SVLAN)
+				}
+				else if (rd->rrd1 & EDMA_RRD_SVLAN) {
 					__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021AD), vlan);
-			}
-
+				}
+#endif
 			/* Update rx statistics */
 			adapter->stats.rx_packets++;
 			adapter->stats.rx_bytes += length;
 
+            /* Calculate rx throughput */
+            edma_cinfo->rx_offer_pkt_cnt++;
+            edma_cinfo->rx_offer_pkt_bytes_cnt += length;
+
+            if ( edma_cinfo->kwn_rx_tput_last_jiffies == 0 ) {
+                edma_cinfo->kwn_rx_tput_last_jiffies = jiffies;
+            } else {
+                if ( (jiffies - edma_cinfo->kwn_rx_tput_last_jiffies) >= 1000 )
+                {
+                    edma_cinfo->kwn_rx_tput_mbps = edma_cinfo->rx_offer_pkt_cnt > 0 ?
+                        ( (edma_cinfo->rx_offer_pkt_bytes_cnt * 8)) : 0;
+                    edma_cinfo->kwn_rx_tput_last_jiffies = jiffies;
+                    edma_cinfo->rx_offer_pkt_cnt = 0;
+                    edma_cinfo->rx_offer_pkt_bytes_cnt = 0;
+                    //printk(": RX Tput: %llu\n",edma_cinfo->kwn_rx_tput_mbps);
+                }
+            }
+
 			/* Check if we reached refill threshold */
 			if (cleaned_count == EDMA_RX_BUFFER_WRITE) {
 				ret_count = edma_alloc_rx_buf(edma_cinfo, erdr, cleaned_count, queue_id);
@@ -1324,7 +1732,6 @@
 		word3 |= (1 << EDMA_TX_INS_CVLAN);
 		word3 |= (adapter->default_vlan_tag) << EDMA_TX_CVLAN_TAG_SHIFT;
 	}
-
 	if (packet_is_rstp) {
 		word3 |= dp_bitmap << EDMA_TPD_PORT_BITMAP_SHIFT;
 		word3 |= from_cpu << EDMA_TPD_FROM_CPU_SHIFT;
@@ -1535,6 +1942,40 @@
 	return __EDMA_LINKDOWN;
 }
 
+
+static loff_t pos = 0;
+int sify_filewrite (int input)
+{
+       struct file *file;
+       char up_data [] ="Ethernet is Up\n";  
+       char down_data [] ="Ethernet is Down\n"; 
+       mm_segment_t old_fs;
+
+       old_fs = get_fs();  //Save the current FS segment
+       set_fs(get_ds());
+
+       file = filp_open("/etc/eth_events.txt", O_WRONLY| O_CREAT| O_APPEND | O_SYNC, 0644);
+
+       if(file){
+
+               if (input == 1)
+               {
+                       vfs_write(file, up_data, (sizeof (up_data)), &pos);
+                       pos = pos+(sizeof (up_data));
+               }
+               else
+               {
+                       vfs_write(file, down_data, (sizeof(down_data)), &pos);
+                       pos = pos+(sizeof (down_data));
+
+               }
+
+       }
+       filp_close(file,NULL);
+       set_fs(old_fs); //Reset to save FS
+
+}
+
 /* edma_adjust_link()
  *	check for edma link status
  */
@@ -1551,12 +1992,14 @@
 
 	if (status == __EDMA_LINKUP && adapter->link_state == __EDMA_LINKDOWN) {
 		dev_info(&adapter->pdev->dev, "%s: GMAC Link is up with phy_speed=%d\n", netdev->name, phydev->speed);
+                sify_filewrite(1);
 		adapter->link_state = __EDMA_LINKUP;
 		netif_carrier_on(netdev);
 		if (netif_running(netdev))
 			netif_tx_wake_all_queues(netdev);
 	} else if (status == __EDMA_LINKDOWN && adapter->link_state == __EDMA_LINKUP) {
 		dev_info(&adapter->pdev->dev, "%s: GMAC Link is down\n", netdev->name);
+                sify_filewrite(0);
 		adapter->link_state = __EDMA_LINKDOWN;
 		netif_carrier_off(netdev);
 		netif_tx_stop_all_queues(netdev);
@@ -1590,6 +2033,7 @@
 	unsigned int flags_transmit = 0;
 	bool packet_is_rstp = false;
 	struct netdev_queue *nq = NULL;
+	u16 vlan = 0;
 
 	if (skb_shinfo(skb)->nr_frags) {
 		nr_frags_first = skb_shinfo(skb)->nr_frags;
@@ -1652,12 +2096,162 @@
 		return NETDEV_TX_BUSY;
 	}
 
+	/* KWN: Vlan Egress Path */
+	switch( edma_cinfo->vlan_mode ) 
+	{
+		case EDMA_VLAN_MODE_TRANSPARENT:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0 && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(": Transparent Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+			}
+			break;
+		case EDMA_VLAN_MODE_TRUNK:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(": (TX): Trunk Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			}
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			/* 802.1Q Enabled - Tagged Traffic */
+			if ( vlan_tx_tag_present( skb ) ) {
+				vlan = vlan_tx_tag_get( skb );
+				if( edma_cinfo->allow_untagged && 
+						vlan == edma_cinfo->native_vlan_id ) {
+					skb = skb_vlan_untag( skb );
+					if ( unlikely(!skb) ) { 
+						/*printk(": (TX): Trunk Mode: SKB Untag Failed: Result: Drop\n");*/
+						goto drop;
+					}
+				} else if ( vlan == edma_cinfo->mgmt_vlan_id ) {
+					;
+				} else if ( !edma_cinfo->allow_all_tagged_trunk &&
+						!test_bit(vlan, edma_cinfo->vlan_bitmap) ) {
+					/*printk(": (TX): Trunk Mode: SKB Vlan(%d) != VLan Trunk Table: Result: Drop\n",
+							vlan);*/
+					goto drop1;
+				} 
+			} else { /* UnTagged Traffic */
+				if ( (!edma_cinfo->allow_untagged) ||
+						(edma_cinfo->allow_untagged &&
+						 edma_cinfo->native_vlan_id > 0) ) {
+					/*printk(":(TX): Trunk Mode: SKB UnTagged: Native VlanID(%d) Set: Result: Drop\n",
+					  edma_cinfo->native_vlan_id);*/
+					goto drop1;
+				}
+			}
+			break;
+		case EDMA_VLAN_MODE_ACCESS:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(":(TX): Access Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			} 		
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			/* Tagged Traffic */
+			if ( vlan_tx_tag_present( skb ) ) {
+				vlan = vlan_tx_tag_get( skb );
+				if( edma_cinfo->access_vlan_id > 0 && 
+						vlan == edma_cinfo->access_vlan_id ) {
+					skb = skb_vlan_untag( skb );
+					if ( unlikely(!skb) ) { 
+						/*printk(":(TX): Access Mode: SKB Untag Failed: Result: Drop\n");*/
+						goto drop;
+					}
+				} else if ( vlan == edma_cinfo->mgmt_vlan_id ) {
+					;
+				} else {
+					/*printk(":(TX): Access Mode: Skb Tagged Pkt(%d) != Access VlanId(%d): Result: Drop\n",
+							vlan, edma_cinfo->access_vlan_id);*/
+					goto drop1;
+				}	
+			} else {
+				/*printk(":(TX): Access Mode: UnTagged Packet in Egress Path : Result: Drop\n");*/
+				goto drop1;
+			} 
+			break;
+		case EDMA_VLAN_MODE_QINQ:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(":(TX): Access Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			}
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			/* QinQ Enabled - Tagged Traffic */
+			if ( edma_cinfo->svlan_id > 0 ) {
+				if ( skb->protocol == cpu_to_be16( ETH_P_8021AD ) ||
+						skb->protocol == cpu_to_be16( ETH_P_8021AH ) ) {
+					uint8_t *var;
+					struct vlan_ethhdr *vhdr;
+					var = ( uint8_t *)skb->data;
+					memmove( var + 4, var, 12 );
+					skb_pull( skb, 4 );
+					vhdr = (struct vlan_ethhdr *)skb->data;
+					vlan = ntohs(vhdr->h_vlan_TCI);
+					skb->vlan_tci = 0;
+					if ( !edma_cinfo->allow_all_tagged_trunk &&
+							!test_bit(vlan, edma_cinfo->vlan_bitmap) ) {
+						/*printk(": (SVLAN: TX): Trunk Mode: SKB Vlan(%d) != VLan Trunk" 
+						  "Table: Result: Drop\n",
+						  vlan);*/
+						goto drop1;
+					}
+				} else if ( skb->protocol == cpu_to_be16( ETH_P_8021Q )) {
+					struct vlan_ethhdr *vhdr;
+					vhdr = (struct vlan_ethhdr *)skb->data;
+					vlan = ntohs(vhdr->h_vlan_TCI);
+					skb->vlan_tci = 0;
+					if ( !edma_cinfo->allow_all_tagged_trunk &&
+							!test_bit(vlan, edma_cinfo->vlan_bitmap) ) {
+						/*printk(": (SVLAN: TX): Trunk Mode: SKB Vlan(%d) != VLan Trunk" 
+						  "Table: Result: Drop\n",
+						  vlan);*/
+						goto drop1;
+					}
+				}
+				break;
+			}
+			break;
+		case EDMA_VLAN_MODE_PBB:
+			/* Local Access */
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && edma_cinfo->allow_tagged_mgmt ) {
+				/*printk(":(TX): Access Mode: Mgmt Packet\n");*/
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), edma_cinfo->mgmt_vlan_id);
+				break;
+			}
+			if ( memcmp( net_dev->dev_addr, eth_hdr(skb)->h_source, 6) == 0  && !edma_cinfo->allow_tagged_mgmt ) {
+				break;
+			}
+			break;
+		default:
+			break;
+	}
+
+	/* KWN: Vlan SW Tagging in XMIT Path */
+	if ( vlan_tx_tag_present( skb ) ) {
+		vlan = vlan_tx_tag_get( skb );
+		skb = __vlan_put_tag( skb, skb->vlan_proto, vlan );
+		if (unlikely(!skb)) {
+			goto drop;
+		}
+		skb->vlan_tci = 0;
+	}
+
 	/* Check and mark VLAN tag offload */
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 21))
-	if (vlan_tx_tag_present(skb))
+	if (vlan_tx_tag_present(skb)) 
 #else
-	if (skb_vlan_tag_present(skb))
-#endif
+	if (skb_vlan_tag_present(skb)) 
+#endif 
 		flags_transmit |= EDMA_VLAN_TX_TAG_INSERT_FLAG;
 	else if (adapter->default_vlan_tag)
 		flags_transmit |= EDMA_VLAN_TX_TAG_INSERT_DEFAULT_FLAG;
@@ -1683,6 +2277,30 @@
 	adapter->stats.tx_packets++;
 	adapter->stats.tx_bytes += skb->len;
 
+    edma_cinfo->tx_offer_pkt_cnt++;
+    edma_cinfo->tx_offer_pkt_bytes_cnt += skb->len;
+
+    if ( edma_cinfo->kwn_tx_tput_last_jiffies == 0 ) {
+        edma_cinfo->kwn_tx_tput_last_jiffies = jiffies;
+    } else {
+        if ( (jiffies - edma_cinfo->kwn_tx_tput_last_jiffies) >= 1000 )
+        {
+            edma_cinfo->kwn_tx_tput_mbps = edma_cinfo->tx_offer_pkt_cnt > 0 ?
+                ( (edma_cinfo->tx_offer_pkt_bytes_cnt * 8)) : 0;
+            edma_cinfo->kwn_tx_tput_last_jiffies = jiffies;
+            edma_cinfo->tx_offer_pkt_cnt = 0;
+            edma_cinfo->tx_offer_pkt_bytes_cnt = 0;
+            //printk(": Tx Tput: %llu\n",edma_cinfo->kwn_tx_tput_mbps);
+        }
+    }
+	goto netdev_okay;
+
+drop1:
+	dev_kfree_skb_any(skb);
+drop:
+	adapter->stats.tx_errors++;
+	goto netdev_okay;
+	
 netdev_okay:
 	local_bh_enable();
 	return NETDEV_TX_OK;
diff -urN qca-edma-org/edma.h qca-edma-mod/edma.h
--- qca-edma-org/edma.h	2018-07-09 14:25:58.833210000 +0530
+++ qca-edma-mod/edma.h	2018-11-22 12:42:28.424971222 +0530
@@ -44,6 +44,12 @@
 #include <linux/if_pppox.h>
 #include "ess_edma.h"
 
+#define EDMA_VLAN_MODE_TRANSPARENT	0
+#define EDMA_VLAN_MODE_ACCESS		1
+#define EDMA_VLAN_MODE_TRUNK		2
+#define EDMA_VLAN_MODE_QINQ		3
+#define EDMA_VLAN_MODE_PBB		4
+
 #define EDMA_CPU_CORES_SUPPORTED 4
 #define EDMA_MAX_PORTID_SUPPORTED 5
 #define EDMA_MAX_VLAN_SUPPORTED  EDMA_MAX_PORTID_SUPPORTED
@@ -393,6 +399,29 @@
 	struct edma_per_cpu_queues_info edma_percpu_info[CONFIG_NR_CPUS]; /* per cpu information */
 	spinlock_t stats_lock; /* protect edma stats area for updation */
 	u32 num_cores;
+	/* KWN: Vlan Parameters */
+	unsigned long vlan_bitmap[512];	/* Vlan Trunk Table */
+	int8_t vlan_mode;	/* Vlan Modes: Transparent, Access, Trunk & QinQ */
+	int8_t allow_untagged;	/* Allow UnTagged in Trunk Mode */
+	int16_t access_vlan_id;	/* Tag UnTagged traffic in Access Mode */
+	int16_t native_vlan_id;	/* Tag UnTagged traffic in Trunk Mode */
+	int16_t mgmt_vlan_id;	/* Tag UnTagged traffic in all modes */
+	int8_t allow_all_tagged_trunk; /* Allow all Tagged traffic in Trunk Mode */
+	int16_t svlan_id;	/* SVLAN-ID */
+	uint16_t svlan_etherType;	/* SVLAN: EtherType */
+	uint8_t pbb_da_mac[6];	/* PBB: B-DA-MAC */
+	uint8_t pbb_sa_mac[6];	/* PBB: B-SA-MAC */
+	int16_t pbb_bvid;		/* PBB: B-VLAN-ID */
+	int32_t pbb_isid;		/* PBB: B-I-SID */
+	int8_t allow_tagged_mgmt;	/* Allow Tagged Mgmt */
+	uint64_t tx_offer_pkt_cnt;       /* no of pkts offered to umac for Tx */
+	uint64_t tx_offer_pkt_bytes_cnt; /* no of bytes offered to umac for Tx*/
+	uint64_t kwn_tx_tput_mbps;
+	uint64_t kwn_tx_tput_last_jiffies;
+	uint64_t rx_offer_pkt_cnt;
+	uint64_t rx_offer_pkt_bytes_cnt;
+	uint64_t kwn_rx_tput_mbps;
+	uint64_t kwn_rx_tput_last_jiffies;
 };
 
 /* transimit packet descriptor (tpd) ring */
@@ -473,6 +502,16 @@
 	__be16 proto;
 };
 
+/* KWN: PBB */
+struct kwn_pbb {
+	uint8_t  b_da_mac[6];
+	uint8_t  b_sa_mac[6];
+	uint16_t b_vid;
+	uint16_t tpid;
+	uint32_t i_sid;
+};
+
+
 int edma_alloc_queues_tx(struct edma_common_info *edma_cinfo);
 int edma_alloc_queues_rx(struct edma_common_info *edma_cinfo);
 int edma_open(struct net_device *netdev);
@@ -547,4 +586,29 @@
 void edma_iad_process_flow(struct edma_common_info *edma_cinfo,
 			   struct sk_buff *skb, u8 dir, u8 precedence);
 
+/* KWN: Routines to maintain the VID Information */
+int edma_set_vid_bitmap(struct net_device *dev, int16_t vid, int16_t flags);
+int edma_clear_vid_bitmap(struct net_device *dev, int16_t vid);
+int edma_set_vlan_mode(struct net_device *dev, int8_t vlan_mode);
+int edma_set_allow_tagged_mgmt(struct net_device *dev, int8_t allow_tagged_mgmt);
+int edma_set_allow_untagged(struct net_device *dev, int8_t allow_untagged);
+int edma_set_allow_all_tagged_trunk( struct net_device *dev, int8_t allow_all );
+int edma_set_access_vlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_set_native_vlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_set_mgmt_vlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_get_mgmt_vlan_id( struct net_device *dev );
+int edma_set_svlan_id( struct net_device *dev, int16_t vlan_id );
+int edma_set_svlan_etherType( struct net_device *dev, uint16_t etherType );
+uint64_t edma_get_tx_pkts( struct net_device *dev );
+uint64_t edma_get_tx_errors( struct net_device *dev );
+uint64_t edma_get_tx_bytes( struct net_device *dev );
+uint64_t edma_get_tx_thrpt( struct net_device *dev );
+uint64_t edma_get_rx_pkts( struct net_device *dev );
+uint64_t edma_get_rx_errors( struct net_device *dev );
+uint64_t edma_get_rx_bytes( struct net_device *dev );
+uint64_t edma_get_rx_thrpt( struct net_device *dev );
+int edma_set_pbb_da_mac( struct net_device *dev, uint8_t *mac );
+int edma_set_pbb_sa_mac( struct net_device *dev, uint8_t *mac );
+int edma_set_pbb_bvid( struct net_device *dev, int16_t vlan_id );
+int edma_set_pbb_isid( struct net_device *dev, int32_t vlan_id );
 #endif /* _EDMA_H_ */
