diff -urN net-snmp-5.4.4-org/agent/mibgroup/kwnmib.c net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.c
--- net-snmp-5.4.4-org/agent/mibgroup/kwnmib.c	1970-01-01 05:30:00.000000000 +0530
+++ net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.c	2018-09-09 17:02:33.066783775 +0530
@@ -0,0 +1,1067 @@
+/****************************************************************************
+*                                                                           *
+*  File Name:           kwnmib.c                                           *
+*  Used By:                                                                 *
+*                                                                           *
+*  Operating System:                                                        *
+*  Purpose:                                                                 *
+*                                                                           *
+*  Comments:                                                                *
+*                                                                           *
+*  Author:              Srilatha                                            *
+*                                                                           *
+*  Creation Date:       09/02/03                                            *
+*                                                                           *
+*   Ver    Date   Inits Modification                                        *
+*  ----- -------- ----- ------------                                        *
+****************************************************************************/
+/****************************************************************************
+*                               Includes                                    *
+****************************************************************************/
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "kwnmib.h"
+
+/****************************************************************************
+*                                Defines                                    *
+****************************************************************************/
+
+#ifndef UCHAR
+  typedef unsigned char UCHAR;
+#endif
+
+  char            resbuf[256];
+  long            resval;
+  uint32_t        resaddr;
+  uint32_t        resaddr_hl;
+  char            *ptr;
+  WriteMethod     wlanwriteSystem;
+  WriteMethod     nwkwriteSystem;
+  WriteMethod     radiuswriteSystem;
+  WriteMethod     vlanwriteSystem;
+  WriteMethod     ethernetwriteSystem;
+  WriteMethod     dhcpwriteSystem;
+/****************************************************************************
+*                            External Functions                             *
+****************************************************************************/
+
+/****************************************************************************
+*   kwnmib_variables_oid:                                                  *
+*       this is the top level oid that we want to register under.  This     *
+*       is essentially a prefix, with the suffix appearing in the           *
+*       variable below.                                                     *
+****************************************************************************/
+oid kwnmib_variables_oid[] = { 1,3,6,1,4,1,52617 };
+
+/****************************************************************************
+*   variable4 kwnmib_variables:                                            *
+*     this variable defines function callbacks and type return information  *
+*     for the kwnmib mib section                                           *
+****************************************************************************/
+struct variable7 kwnmib_variables[] = {
+/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
+  /* Wireless MIBS */
+  { WLANRADIOINDEX, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,1 } },
+  { WLANRADIOMODE, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,2 } },
+  { WLANSSID   , ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,3 } },
+  { WLANCOUNTRY, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,4 } },
+  { WLANOPMODE, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,5 } },
+  { WLANBANDWIDTH, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,6 } },
+  { WLANCHANNEL, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,7 } },
+  { WLANRATE, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,8 } },
+  { WLANTXPOWER, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,9 } },
+  { WLANAMSDU, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,10 } },
+  { WLANUPLINKLIMIT, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,11 } },
+  { WLANDOWNLINKLIMIT, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,12 } },
+  { WLANHIDEESSID, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,13 } },
+  { WLANCUSTOMERNAME, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,14 } },
+  { WLANLINKID, ASN_INTEGER , RWRITE, var_WlanTable, 5, { 1,1,1,1,15 } },
+  { WLANSECENC, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,16 } },
+  { WLANSECKEY, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,17 } },
+  { WLANMACFILTER, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,18 } },
+  { WLANMACLIST, ASN_OCTET_STR , RWRITE, var_WlanTable, 5, { 1,1,1,1,19 } },
+  /* Network MIBS */
+  { NWKADRSTYPE, ASN_OCTET_STR , RWRITE, var_NwkIPTable, 3, { 1,2,1 } },
+  { NWKIPADRS, ASN_IPADDRESS , RWRITE, var_NwkIPTable, 3, { 1,2,2 } },
+  { NWKMASK, ASN_IPADDRESS , RWRITE, var_NwkIPTable, 3, { 1,2,3 } },
+  { NWKGATEWAY, ASN_IPADDRESS , RWRITE, var_NwkIPTable, 3, { 1,2,4 } },
+  { NWKDNSIP, ASN_IPADDRESS , RWRITE, var_NwkIPTable, 3, { 1,2,5 } },
+  /* RADIUS MIBS */
+  { RADIUSSTATUS, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,1 } },
+  { RADIUSPRISERVER, ASN_IPADDRESS , RWRITE, var_RadiusTable, 3, { 1,3,2 } },
+  { RADIUSPRIPORT, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,3 } },
+  { RADIUSPRISECRET, ASN_OCTET_STR , RWRITE, var_RadiusTable, 3, { 1,3,4 } },
+  { RADIUSSECSERVER, ASN_IPADDRESS , RWRITE, var_RadiusTable, 3, { 1,3,5 } },
+  { RADIUSSECPORT, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,6 } },
+  { RADIUSSECSECRET, ASN_OCTET_STR , RWRITE, var_RadiusTable, 3, { 1,3,7 } },
+  { RADIUSREAUTHTIME, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,8 } },
+  { RADIUSRETRYTIME, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,9 } },
+  { RADIUSRETRYCOUNT, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,10 } },
+  { RADIUSRETRYCOUNTPERIOD, ASN_INTEGER , RWRITE, var_RadiusTable, 3, { 1,3,11 } },
+  /* VLAN MIBS */
+  { VLANSTATUS, ASN_INTEGER , RWRITE, var_VlanTable, 3, { 1,4,1 } },
+  { VLANMODE, ASN_INTEGER , RWRITE, var_VlanTable, 3, { 1,4,2 } },
+  { VLANMGMTID, ASN_INTEGER , RWRITE, var_VlanTable, 3, { 1,4,3 } },
+  { VLANACCESSID, ASN_INTEGER , RWRITE, var_VlanTable, 3, { 1,4,4 } },
+  { VLANTRUNKOPTION, ASN_INTEGER , RWRITE, var_VlanTable, 3, { 1,4,5 } },
+  { VLANTRUNKID, ASN_OCTET_STR , RWRITE, var_VlanTable, 3, { 1,4,6 } },
+  { VLANSVLANID, ASN_INTEGER , RWRITE, var_VlanTable, 3, { 1,4,7 } },
+  { VLANSVLANETHERTYPE, ASN_OCTET_STR , RWRITE, var_VlanTable, 3, { 1,4,8 } },
+  /* Ethernet MIBS */
+  { ETHERNETSPEED, ASN_INTEGER , RWRITE, var_EthernetTable, 3, { 1,5,1 } },
+  /* DHCP MIBS */
+  { DHCPSERVER, ASN_INTEGER , RWRITE, var_DhcpTable, 3, { 1,6,1 } },
+  { DHCPSTART, ASN_INTEGER , RWRITE, var_DhcpTable, 3, { 1,6,2 } },
+  { DHCPLIMIT, ASN_INTEGER , RWRITE, var_DhcpTable, 3, { 1,6,3 } },
+  { DHCPLEASETIME, ASN_INTEGER , RWRITE, var_DhcpTable, 3, { 1,6,4 } },
+};
+// ( L = length of the oidsuffix )
+
+/****************************************************************************
+*                                                                           *
+*         init_kwnmib() - perform any required initialization         *
+*                                                                           *
+****************************************************************************/
+void init_kwnmib ( void ) {
+
+  /* register ourselves with the agent to handle our mib tree */
+  REGISTER_MIB("kwnmib", kwnmib_variables, variable7,
+               kwnmib_variables_oid);
+
+}
+
+void shutdown_kwnmib ( void ) {
+}
+
+void kwn_sys_cmd( const char* cmd, uint8_t* cmd_buf )
+{
+    FILE *fp = NULL;
+    uint8_t  a[33]={0};
+    uint8_t  *token;
+    uint16_t len;
+
+    fp = popen(cmd,"r");
+    if( fp == NULL )
+        return;
+    memset(a, '\0', sizeof(a));
+    while( fgets(a, sizeof(a), fp) != NULL)
+    {
+        /*printf("%s",a);*/
+    }
+    pclose(fp);
+
+    if( a[0] == '\0' ) {
+        memcpy(cmd_buf, "-NA-", sizeof(cmd_buf));
+        return;
+    }
+    token = strtok(a,"\n");
+    len = strlen(token);
+    memcpy(cmd_buf,token,len);
+    return;
+}
+
+void kwn_conv_str_to_ip( int8_t* conv_ip, uint32_t* ip_addr )
+{
+    uint32_t val;
+    int8_t  *tok,*ptr;
+
+    tok=strtok(conv_ip,".");
+
+    while( tok != NULL)
+    {
+        val=strtoul(tok,&ptr,0);
+        *ip_addr=(*ip_addr << 8) + val;
+        tok=strtok(NULL,".");
+    }
+    return;
+}
+
+void kwn_get_value( int type, char* cmd, size_t *var_len )
+{
+    kwn_sys_cmd(cmd, &resbuf[0]);
+    switch( type )
+    {
+        case KWN_TYPE_INTEGER32:
+            if( !memcmp( resbuf, "-NA-", 4) )
+                resval = -1;
+            else
+                resval = strtol(resbuf, &ptr, 10);
+            *var_len = sizeof ( long );
+            break;
+        case KWN_TYPE_DISPLAY_STRING:
+            resbuf[ sizeof(resbuf)-1 ] = 0;
+            *var_len = strlen(resbuf);
+            break;
+        case KWN_TYPE_IP_ADDRESS:
+            resbuf[ sizeof(resbuf)-1 ] = 0;
+            kwn_conv_str_to_ip(&resbuf[0], &resaddr);
+            resaddr_hl = ntohl( resaddr );
+            *var_len = sizeof( in_addr_t );
+            break;
+    }
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_WlanTable() -                                                      *
+ *                                                                          *
+ ****************************************************************************/
+    unsigned char *
+var_WlanTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+    int ind;
+
+    ind = (int)name[12];
+    if( ind < 1 || ind > 2 )
+        return NULL;
+    ind = ind - 1;
+
+    memset(resbuf,'\0',sizeof(resbuf));
+    resval = 0;
+    ptr = NULL;
+    *length = vp->namelen + 1;
+    switch ( vp->magic ) {
+        case WLANRADIOMODE:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].mode",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANSSID:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].ssid",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANCOUNTRY:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.country",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return ( UCHAR * ) &resval;
+        case WLANOPMODE:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.hwmode",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANBANDWIDTH:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.htmode",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANCHANNEL:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.channel",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) &resbuf;
+        case WLANRATE:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.rate",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return ( UCHAR *) &resbuf;
+        case WLANTXPOWER:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.txpower",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case WLANAMSDU:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].kwnamsdu",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (UCHAR *) &resval;
+        case WLANUPLINKLIMIT:
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].ullmt",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case WLANDOWNLINKLIMIT:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].dllmt",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case WLANHIDEESSID:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].hidden",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case WLANCUSTOMERNAME:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.customername",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANLINKID:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.wifi%d.linkid",ind);
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case WLANSECENC:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].encryption",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANSECKEY:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].key",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANMACFILTER:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].macfilter",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case WLANMACLIST:
+            *write_method = wlanwriteSystem;
+            sprintf(cmd,"uci get wireless.@wifi-iface[%d].maclist",ind);
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_NwkIPTable() -                                                    *
+ *                                                                           *
+ ****************************************************************************/
+    unsigned char *
+var_NwkIPTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact,var_len,write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset(resbuf,'\0',sizeof(resbuf));
+    resval = 0;
+    resaddr = 0;
+    resaddr_hl = 0;
+    ptr = NULL;
+    *length = vp->namelen + 1;
+    switch ( vp->magic ) {
+        case NWKADRSTYPE:
+            *write_method = nwkwriteSystem;
+            sprintf(cmd,"uci get network.lan.proto");
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case NWKIPADRS:
+            *write_method = nwkwriteSystem;
+            sprintf(cmd,"uci get network.lan.ipaddr");
+            kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len );
+            return (u_char *) &resaddr_hl;
+        case NWKMASK:
+            *write_method = nwkwriteSystem;
+            sprintf(cmd,"uci get network.lan.netmask");
+            kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len );
+            return (u_char *) &resaddr_hl;
+        case NWKGATEWAY:
+            *write_method = nwkwriteSystem;
+            sprintf(cmd,"uci get network.lan.gateway");
+            kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len );
+            return (u_char *) &resaddr_hl;
+        case NWKDNSIP:
+            *write_method = nwkwriteSystem;
+            sprintf(cmd,"uci get network.lan.dns");
+            kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len );
+            return (u_char *) &resaddr_hl;
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_RadiusTable() -                                                    *
+ *                                                                           *
+ ****************************************************************************/
+    unsigned char *
+var_RadiusTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact,var_len,write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset(resbuf,'\0',sizeof(resbuf));
+    resval = 0;
+    resaddr = 0;
+    ptr = NULL;
+    *length = vp->namelen + 1;
+
+    switch ( vp->magic ) {
+        case RADIUSSTATUS:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.enableRadAuth");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case RADIUSPRISERVER:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.primaryServer");
+            kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len );
+            return (u_char *) &resaddr_hl;
+        case RADIUSPRIPORT:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.primaryPort");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case RADIUSPRISECRET:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.primarySecret");
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case RADIUSSECSERVER:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.secondaryServer");
+            kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len );
+            return (u_char *) &resaddr_hl;
+        case RADIUSSECPORT:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.secondaryPort");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case RADIUSSECSECRET:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.secondarySecret");
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case RADIUSREAUTHTIME:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.reauthTime");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case RADIUSRETRYTIME:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.retryTime");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case RADIUSRETRYCOUNT:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.requestRetries");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case RADIUSRETRYCOUNTPERIOD:
+            *write_method = radiuswriteSystem;
+            sprintf(cmd,"uci get wrt-radauth.sys.requestTimeout");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_VlanTable() -                                                    *
+ *                                                                           *
+ ****************************************************************************/
+    unsigned char *
+var_VlanTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact,var_len,write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset(resbuf,'\0',sizeof(resbuf));
+    resval = 0;
+    ptr = NULL;
+    *length = vp->namelen + 1;
+
+    switch ( vp->magic ) {
+        case VLANSTATUS:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.status");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case VLANMODE:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.mode");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case VLANMGMTID:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.mgmtvlan");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case VLANACCESSID:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.accessvlan");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case VLANTRUNKOPTION:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.trunkoption");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case VLANTRUNKID:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.trunkvlan");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        case VLANSVLANID:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.svlan");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case VLANSVLANETHERTYPE:
+            *write_method = vlanwriteSystem;
+            sprintf(cmd,"uci get vlan.vlan.svlanethertype");
+            kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len );
+            return (u_char *) resbuf;
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_EthernetTable() -                                                    *
+ *                                                                           *
+ ****************************************************************************/
+    unsigned char *
+var_EthernetTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact,var_len,write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset(resbuf,'\0',sizeof(resbuf));
+    resval = 0;
+    ptr = NULL;
+    *length = vp->namelen + 1;
+
+    switch ( vp->magic ) {
+        case ETHERNETSPEED:
+            *write_method = ethernetwriteSystem;
+            sprintf(cmd,"uci get ethernet.ethernet.mode");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_DhcpTable() -                                                    *
+ *                                                                           *
+ ****************************************************************************/
+    unsigned char *
+var_DhcpTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact,var_len,write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset(resbuf,'\0',sizeof(resbuf));
+    resval = 0;
+    ptr = NULL;
+    *length = vp->namelen + 1;
+
+    switch ( vp->magic ) {
+        case DHCPSERVER:
+            *write_method = dhcpwriteSystem;
+            sprintf(cmd,"uci get dhcp.lan.start");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            sprintf(cmd,"echo %d >> /tmp/sify.txt",resval);
+            system(cmd);
+            if( resval == -1 )
+                resval = 0;
+            else
+                resval = 1;
+            return (u_char *) &resval;
+        case DHCPSTART:
+            *write_method = dhcpwriteSystem;
+            sprintf(cmd,"uci get dhcp.lan.start");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case DHCPLIMIT:
+            *write_method = dhcpwriteSystem;
+            sprintf(cmd,"uci get dhcp.lan.limit");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        case DHCPLEASETIME:
+            *write_method = dhcpwriteSystem;
+            sprintf(cmd,"uci get dhcp.lan.leasetime");
+            kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len );
+            return (u_char *) &resval;
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+
+int
+wlanwriteSystem(int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len)
+{
+    char cmd[100];
+    int ind;
+
+    var_val[var_val_len] = '\0';
+    ind = (int) name[12];
+    if( ind < 1 || ind > 2 )
+        return NULL;
+    ind = ind - 1;
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ((char) name[11]) {
+                    case WLANRADIOMODE:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].mode='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANSSID:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].ssid='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANCOUNTRY:
+                        sprintf(cmd,"uci set wireless.wifi%d.country='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANOPMODE:
+                        sprintf(cmd,"uci set wireless.wifi%d.hwmode='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANBANDWIDTH:
+                        sprintf(cmd,"uci set wireless.wifi%d.htmode='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANCHANNEL:
+                        sprintf(cmd,"uci set wireless.wifi%d.channel='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANRATE:
+                        sprintf(cmd,"uci set wireless.wifi%d.rate='%s'",ind,var_val);
+                        system(cmd);
+                        /* Updating Rate dynamically for 5GHz Radio */
+                        if( ind == 1 ) {
+                            system("/usr/sbin/rate.sh");
+                        }
+                        break;
+                    case WLANTXPOWER:
+                        sprintf(cmd,"uci set wireless.wifi%d.txpower='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANAMSDU:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].kwnamsdu='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANUPLINKLIMIT:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].ullmt='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANDOWNLINKLIMIT:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].dllmt='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANHIDEESSID:
+                        {
+                            int val = (int)var_val;
+                            if( val == 0 ) {
+                                sprintf(cmd,"uci delete wireless.@wifi-iface[%d].hidden",ind);
+                                system(cmd);
+                            }
+                            else {
+                                sprintf(cmd,"uci set wireless.@wifi-iface[%d].hidden='%s'",ind,var_val);
+                                system(cmd);
+                            }
+                        }
+                        break;
+                    case WLANCUSTOMERNAME:
+                        sprintf(cmd,"uci set wireless.wifi%d.customername='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANLINKID:
+                        sprintf(cmd,"uci set wireless.wifi%d.linkid='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANSECENC:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].encryption='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANSECKEY:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].key='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANMACFILTER:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].macfilter='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    case WLANMACLIST:
+                        sprintf(cmd,"uci set wireless.@wifi-iface[%d].maclist='%s'",ind,var_val);
+                        system(cmd);
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
+                    SNMP_CALLBACK_STORE_DATA, NULL);
+            snmp_clean_persistent(netsnmp_ds_get_string
+                    (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+nwkwriteSystem(int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len)
+{
+    char cmd[100];
+
+    var_val[var_val_len] = '\0';
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ((char) name[9]) {
+                    case NWKADRSTYPE:
+                        sprintf(cmd,"uci set network.lan.proto='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case NWKIPADRS:
+                        sprintf(cmd,"uci set network.lan.ipaddr='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case NWKMASK:
+                        sprintf(cmd,"uci set network.lan.netmask='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case NWKGATEWAY:
+                        sprintf(cmd,"uci set network.lan.gateway='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case NWKDNSIP:
+                        sprintf(cmd,"uci set network.lan.dns='%s'",var_val);
+                        system(cmd);
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
+                    SNMP_CALLBACK_STORE_DATA, NULL);
+            snmp_clean_persistent(netsnmp_ds_get_string
+                    (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+radiuswriteSystem(int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len)
+{
+    char cmd[100];
+
+    var_val[var_val_len] = '\0';
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ((char) name[9]) {
+                    case RADIUSSTATUS:
+                        sprintf(cmd,"uci set wrt-radauth.sys.enableRadAuth='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSPRISERVER:
+                        sprintf(cmd,"uci set wrt-radauth.sys.primaryServer='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSPRIPORT:
+                        sprintf(cmd,"uci set wrt-radauth.sys.primaryPort='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSPRISECRET:
+                        sprintf(cmd,"uci set wrt-radauth.sys.primarySecret='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSSECSERVER:
+                        sprintf(cmd,"uci set wrt-radauth.sys.secondaryServer='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSSECPORT:
+                        sprintf(cmd,"uci set wrt-radauth.sys.secondaryPort='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSSECSECRET:
+                        sprintf(cmd,"uci set wrt-radauth.sys.secondarySecret='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSREAUTHTIME:
+                        sprintf(cmd,"uci set wrt-radauth.sys.reauthTime='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSRETRYTIME:
+                        sprintf(cmd,"uci set wrt-radauth.sys.retryTime='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSRETRYCOUNT:
+                        sprintf(cmd,"uci set wrt-radauth.sys.requestRetries='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case RADIUSRETRYCOUNTPERIOD:
+                        sprintf(cmd,"uci set wrt-radauth.sys.requestTimeout='%s'",var_val);
+                        system(cmd);
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
+                    SNMP_CALLBACK_STORE_DATA, NULL);
+            snmp_clean_persistent(netsnmp_ds_get_string
+                    (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+vlanwriteSystem(int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len)
+{
+    char cmd[100];
+
+    var_val[var_val_len] = '\0';
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ((char) name[9]) {
+                    case VLANSTATUS:
+                        sprintf(cmd,"uci set vlan.vlan.status='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANMODE:
+                        sprintf(cmd,"uci set vlan.vlan.mode='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANMGMTID:
+                        sprintf(cmd,"uci set vlan.vlan.mgmtvlan='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANACCESSID:
+                        sprintf(cmd,"uci set vlan.vlan.accessvlan='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANTRUNKOPTION:
+                        sprintf(cmd,"uci set vlan.vlan.trunkoption='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANTRUNKID:
+                        sprintf(cmd,"uci set vlan.vlan.trunkvlan='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANSVLANID:
+                        sprintf(cmd,"uci set vlan.vlan.svlan='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case VLANSVLANETHERTYPE:
+                        sprintf(cmd,"uci set vlan.vlan.svlanethertype='%s'",var_val);
+                        system(cmd);
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
+                    SNMP_CALLBACK_STORE_DATA, NULL);
+            snmp_clean_persistent(netsnmp_ds_get_string
+                    (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+ethernetwriteSystem(int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len)
+{
+    char cmd[100];
+
+    var_val[var_val_len] = '\0';
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ((char) name[9]) {
+                    case ETHERNETSPEED:
+                        sprintf(cmd,"uci set ethernet.ethernet.mode='%s'",var_val);
+                        system(cmd);
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
+                    SNMP_CALLBACK_STORE_DATA, NULL);
+            snmp_clean_persistent(netsnmp_ds_get_string
+                    (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+dhcpwriteSystem(int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len)
+{
+    char cmd[100];
+
+    var_val[var_val_len] = '\0';
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ((char) name[9]) {
+                    case DHCPSERVER:
+                        sprintf(cmd,"uci set dhcp.lan.start='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case DHCPSTART:
+                        sprintf(cmd,"uci set dhcp.lan.start='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case DHCPLIMIT:
+                        sprintf(cmd,"uci set dhcp.lan.limit='%s'",var_val);
+                        system(cmd);
+                        break;
+                    case DHCPLEASETIME:
+                        sprintf(cmd,"uci set dhcp.lan.leasetime='%s'",var_val);
+                        system(cmd);
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
+                    SNMP_CALLBACK_STORE_DATA, NULL);
+            snmp_clean_persistent(netsnmp_ds_get_string
+                    (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -urN net-snmp-5.4.4-org/agent/mibgroup/kwnmib.h net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.h
--- net-snmp-5.4.4-org/agent/mibgroup/kwnmib.h	1970-01-01 05:30:00.000000000 +0530
+++ net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.h	2018-09-09 11:54:12.075115933 +0530
@@ -0,0 +1,94 @@
+/****************************************************************************
+*                                                                           *
+*  File Name:           kwnmib.h                                      *
+*  Used By:                                                                 *
+*                                                                           *
+*  Operating System:                                                        *
+*  Purpose:                                                                 *
+*                                                                           *
+*  Comments:                                                                *
+*                                                                           *
+*  Author:              Srilatha                                            *
+*                                                                           *
+*                                                                           *
+****************************************************************************/
+#ifndef _MIBGROUP_KWNMIB_H
+#define _MIBGROUP_KWNMIB_H
+
+/****************************************************************************
+*                               Includes                                    *
+****************************************************************************/
+
+config_require(util_funcs)
+
+/* function prototypes */
+
+void   init_kwnmib ( void );
+FindVarMethod var_WlanTable;
+FindVarMethod var_NwkIPTable;
+FindVarMethod var_RadiusTable;
+FindVarMethod var_VlanTable;
+FindVarMethod var_EthernetTable;
+FindVarMethod var_DhcpTable;
+
+enum KWN_TYPE {
+    KWN_TYPE_INTEGER32 = 1,
+    KWN_TYPE_DISPLAY_STRING = 2,
+    KWN_TYPE_IP_ADDRESS = 3
+};
+
+/* Wireless Parameters */
+#define WLANRADIOINDEX                    1
+#define WLANRADIOMODE                     2
+#define WLANSSID                          3
+#define WLANCOUNTRY                       4
+#define WLANOPMODE                        5
+#define WLANBANDWIDTH                     6
+#define WLANCHANNEL                       7
+#define WLANRATE                          8
+#define WLANTXPOWER                       9
+#define WLANAMSDU                        10
+#define WLANUPLINKLIMIT                  11
+#define WLANDOWNLINKLIMIT                12
+#define WLANHIDEESSID                    13
+#define WLANCUSTOMERNAME                 14
+#define WLANLINKID                       15
+#define WLANSECENC                       16
+#define WLANSECKEY                       17
+#define WLANMACFILTER                    18
+#define WLANMACLIST                      19
+/* Network Parameters */
+#define NWKADRSTYPE                      20
+#define NWKIPADRS                        21
+#define NWKMASK                          22
+#define NWKGATEWAY                       23
+#define NWKDNSIP                         24
+/* RADIUS Parameters */
+#define RADIUSSTATUS                     25
+#define RADIUSPRISERVER                  26
+#define RADIUSPRIPORT                    27
+#define RADIUSPRISECRET                  28
+#define RADIUSSECSERVER                  29
+#define RADIUSSECPORT                    30
+#define RADIUSSECSECRET                  31
+#define RADIUSREAUTHTIME                 32
+#define RADIUSRETRYTIME                  33
+#define RADIUSRETRYCOUNT                 34
+#define RADIUSRETRYCOUNTPERIOD           35
+/* VLAN Parameters */
+#define VLANSTATUS                       36
+#define VLANMODE                         37
+#define VLANMGMTID                       38
+#define VLANACCESSID                     39
+#define VLANTRUNKOPTION                  40
+#define VLANTRUNKID                      41
+#define VLANSVLANID                      42
+#define VLANSVLANETHERTYPE               43
+/* Ethernet Parameters */
+#define ETHERNETSPEED                    44
+/* DHCP Parameters */
+#define DHCPSERVER                       45
+#define DHCPSTART                        46
+#define DHCPLIMIT                        47
+#define DHCPLEASETIME                    48
+#endif /* _MIBGROUP_KWNMIB_H */
