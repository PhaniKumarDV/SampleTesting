diff -urN net-snmp-5.4.4-org/agent/mibgroup/kwnmib.c net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.c
--- net-snmp-5.4.4-org/agent/mibgroup/kwnmib.c	1970-01-01 05:30:00.000000000 +0530
+++ net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.c	2019-02-10 15:57:49.400405682 +0530
@@ -0,0 +1,5448 @@
+/****************************************************************************
+*                                                                           *
+*  File Name:           kwnmib.c                                           *
+*  Used By:                                                                 *
+*                                                                           *
+*  Operating System:                                                        *
+*  Purpose:                                                                 *
+*                                                                           *
+*  Comments:                                                                *
+*                                                                           *
+*  Author:              Srilatha                                            *
+*                                                                           *
+*  Creation Date:       09/02/03                                            *
+*                                                                           *
+*   Ver    Date   Inits Modification                                        *
+*  ----- -------- ----- ------------                                        *
+****************************************************************************/
+/****************************************************************************
+*                               Includes                                    *
+****************************************************************************/
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <linux/types.h>
+#include <linux/if.h>
+#include <linux/wireless.h>
+#include <linux/if_arp.h>
+#include <string.h>
+
+#include <linux/ioctl.h>
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "kwnmib.h"
+#include <endian.h>
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define _BYTE_ORDER _BIG_ENDIAN
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
+#define _BYTE_ORDER _LITTLE_ENDIAN
+#else
+#error "__BYTE_ORDER undefined"
+#endif
+#define EXTERNAL_USE_ONLY
+
+#ifndef __packed
+#define __packed    __attribute__((__packed__))
+#endif
+#include "_ieee80211.h"
+#include "ieee80211_defines.h"
+#include "ieee80211.h"
+#include "ieee80211_ioctl.h"
+
+kwn_snmp_array kwn_wireless_opmode = { 5, { { 1, "11g" }, { 2, "11ng" }, { 3, "11a" }, { 4, "11na" }, { 5, "11ac" } } };
+kwn_snmp_array kwn_wireless_bandwidth = { 6, { { 1, "HT5" }, { 2, "HT10" }, { 3, "HT20" }, { 4, "HT40+" }, { 5, "HT40-" }, { 6, "HT80" } } };
+
+/****************************************************************************
+ *                                Global Variables                          *
+ ****************************************************************************/
+
+  kwn_wireless_stats kwn_assoc_list;
+  char               res_str[ KWN_UCI_CMD_OUTPUT_LEN_MAX ];
+  long               res_val;
+  uint32_t           res_ip;
+  WriteMethod        wlanwriteMethod;
+  WriteMethod        linkprofilewriteMethod;
+  WriteMethod        nwkwriteMethod;
+  WriteMethod        radiuswriteMethod;
+  WriteMethod        vlanwriteMethod;
+  WriteMethod        ethernetwriteMethod;
+  WriteMethod        dhcpwriteMethod;
+  WriteMethod        filterwriteMethod;
+  WriteMethod        systemmgmtwriteMethod;
+  WriteMethod        systeminfowriteMethod;
+  WriteMethod        systemtftpwriteMethod;
+  WriteMethod        systemntpwriteMethod;
+  WriteMethod        systemgpswriteMethod;
+  WriteMethod        systemdyinggaspwriteMethod;
+  WriteMethod        systemledswriteMethod;
+  WriteMethod        systemlogwriteMethod;
+  WriteMethod        systemhttpwriteMethod;
+  WriteMethod        systemtelnetsshwriteMethod;
+  WriteMethod        systemsnmpwriteMethod;
+  WriteMethod        assocwriteMethod;
+
+/****************************************************************************
+*   kwnmib_variables_oid:                                                  *
+*       this is the top level oid that we want to register under.  This     *
+*       is essentially a prefix, with the suffix appearing in the           *
+*       variable below.                                                     *
+****************************************************************************/
+oid kwnmib_variables_oid[] = { 1, 3, 6, 1, 4, 1, KWN_PRIVATE_MIB_OID };
+
+/****************************************************************************
+*   variable kwnmib_variables:                                            *
+*     this variable defines function callbacks and type return information  *
+*     for the kwnmib mib section                                           *
+****************************************************************************/
+struct variable7 kwnmib_variables[] = {
+/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
+  /* Wireless MIBS */
+  { 1    , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_INDEX } },
+  { 2    , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_RADIOMODE } },
+  { 3    , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SSID } },
+  { 4    , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_COUNTRY } },
+  { 5    , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_OPMODE } },
+  { 6    , ASN_OCTET_STR  , RONLY , var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SUPPORTED_BANDWIDTHS } },
+  { 7    , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_BANDWIDTH } },
+  { 8    , ASN_OCTET_STR  , RONLY , var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SUPPORTED_CHANNELS } },
+  { 9    , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_CHANNEL } },
+  { 10   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_AMSDU } },
+  { 11   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_UPLINK_LIMIT } },
+  { 12   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_DOWNLINK_LIMIT } },
+  { 13   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_HIDE_ESSID } },
+  { 14   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_CUSTOMER_NAME } },
+  { 15   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_LINKID } },
+  { 16   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SECURITY_ENC } },
+  { 17   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SECURITY_KEY } },
+  { 18   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_MACFILTER } },
+  { 19   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_MACLIST } },
+  { 20   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_DISTANCE } },
+  { 21   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SHORTGI } },
+  { 22   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_RXCHAINMASK } },
+  { 23   , ASN_INTEGER    , RONLY , var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_ACTIVE_CHANNEL } },
+  { 24   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_ANTENNA_GAIN } },
+  { 25   , ASN_INTEGER    , RONLY , var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_ACTIVE_FREQUENCY } },
+  { 26   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_TRAFFIC_SHAPING } },
+  { 27   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_AMPDU } },
+  { 28   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_WIRELESS_INACTIVITY_TIMER } },
+  { 29   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_LINK_INACTIVITY_TIMER } },
+  { 30   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_MAXIMUM_EIRP } },
+  { 31   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_RATE } },
+  { 32   , ASN_OCTET_STR  , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_DISABLE_LEGACY } },
+  { 33   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_RADIO_STATUS } },
+  { 34   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_SU_SERVICE } },
+  { 35   , ASN_INTEGER    , RWRITE, var_WlanTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_WLANTABLE, KWN_WLANENTRY, KWN_WLAN_LINKTYPE } },
+  /* Link Profile MIBS */
+  { 36   , ASN_INTEGER    , RONLY , var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_INDEX } },
+  { 37   , ASN_INTEGER    , RONLY , var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_SECINDEX } },
+  { 38   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSSTATUS } },
+  { 39   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_SPATIALSTREAM } },
+  { 40   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSMINRATE } },
+  { 41   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSMAXRATE } },
+  { 42   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSINCTIMER } },
+  { 43   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSDECTIMER } },
+  { 44   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_TXRATE } },
+  { 45   , ASN_OCTET_STR  , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_SUPPORTEDRATES } },
+  { 46   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_ATPCSTATUS } },
+  { 47   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_POWER } },
+  { 48   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_TXCHAINMASK } },
+  { 49   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSRATEINCRTHRLD } },
+  { 50   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSRATEINCRTXTHRLD } },
+  { 51   , ASN_INTEGER    , RWRITE, var_LinkProfileTable, 6, { KWN_SMAC, KWN_CONFIGURATION, KWN_WIRELESS, KWN_LINKPROFILETABLE, KWN_LINKPROFILEENTRY, KWN_LINKPROFILE_DDRSRATEDECRTXTHRLD } },
+  /* Network MIBS */
+  { 52   , ASN_OCTET_STR  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_ADRSTYPE } },
+  { 53   , ASN_IPADDRESS  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_IP } },
+  { 54   , ASN_IPADDRESS  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_MASK } },
+  { 55   , ASN_IPADDRESS  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_GATEWAY } },
+  { 56   , ASN_OCTET_STR  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_DNS } },
+  { 57   , ASN_INTEGER    , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_CLEARSTATS } },
+  { 58   , ASN_INTEGER    , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_NETWORKMODE } },
+  { 59   , ASN_INTEGER    , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_NATSTATUS } },
+  { 60   , ASN_IPADDRESS  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_WIRELESS_IP } },
+  { 61   , ASN_IPADDRESS  , RWRITE, var_NwkIPTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_NETWORK, KWN_NWK_WIRELESS_MASK } },
+  /* RADIUS MIBS */
+  { 62   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_STATUS } },
+  { 63   , ASN_IPADDRESS  , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_PRISERVER } },
+  { 64   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_PRIPORT } },
+  { 65   , ASN_OCTET_STR  , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_PRISECRET } },
+  { 66   , ASN_IPADDRESS  , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_SECSERVER } },
+  { 67   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_SECPORT } },
+  { 68   , ASN_OCTET_STR  , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_SECSECRET } },
+  { 69   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_REAUTHTIME } },
+  { 70   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_RETRYTIME } },
+  { 71   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_RETRYCOUNT } },
+  { 72   , ASN_INTEGER    , RWRITE, var_RadiusTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_RADIUS, KWN_RADIUS_RETRYCOUNTPERIOD } },
+  /* VLAN MIBS */
+  { 73   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_STATUS } },
+  { 74   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_MODE } },
+  { 75   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_MGMTID } },
+  { 76   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_ACCESSID } },
+  { 77   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_TRUNKOPTION } },
+  { 78   , ASN_OCTET_STR  , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_TRUNKID } },
+  { 79   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_SVLAN } },
+  { 80   , ASN_OCTET_STR  , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_SVLAN_ETHERTYPE } },
+  { 81   , ASN_OCTET_STR  , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_BDA } },
+  { 82   , ASN_OCTET_STR  , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_BSA } },
+  { 83   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_BVID } },
+  { 84   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_BISID } },
+  { 85   , ASN_INTEGER    , RWRITE, var_VlanTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_VLAN, KWN_VLAN_ALLOW_TAG_MGMT } },
+  /* Ethernet MIBS */
+  { 86   , ASN_INTEGER    , RWRITE, var_EthernetTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_ETHERNET, KWN_ETHERNET_MODE } },
+  { 87   , ASN_INTEGER    , RWRITE, var_EthernetTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_ETHERNET, KWN_ETHERNET_INACTIVITY } },
+  { 88   , ASN_INTEGER    , RWRITE, var_EthernetTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_ETHERNET, KWN_ETHERNET_MTU } },
+  { 89   , ASN_INTEGER    , RONLY , var_EthernetTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_ETHERNET, KWN_ETHERNET_CABLE_LENGTH } },
+  /* DHCP MIBS */
+  { 90   , ASN_INTEGER    , RWRITE, var_DhcpTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_DHCP, KWN_DHCP_SERVER } },
+  { 91   , ASN_IPADDRESS  , RWRITE, var_DhcpTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_DHCP, KWN_DHCP_START_IP } },
+  { 92   , ASN_IPADDRESS  , RWRITE, var_DhcpTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_DHCP, KWN_DHCP_END_IP } },
+  { 93   , ASN_INTEGER    , RWRITE, var_DhcpTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_DHCP, KWN_DHCP_LEASE_TIME } },
+  /* Filtering MIBS */
+  { 94   , ASN_INTEGER    , RWRITE, var_FilterTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_FILTER, KWN_FILTER_STATUS } },
+  { 95   , ASN_INTEGER    , RWRITE, var_FilterTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_FILTER, KWN_FILTER_L2MCAST } },
+  { 96   , ASN_INTEGER    , RWRITE, var_FilterTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_FILTER, KWN_FILTER_L3MCAST } },
+  { 97   , ASN_INTEGER    , RWRITE, var_FilterTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_FILTER, KWN_FILTER_L2BCAST } },
+  { 98   , ASN_INTEGER    , RWRITE, var_FilterTable, 4, { KWN_SMAC, KWN_CONFIGURATION, KWN_FILTER, KWN_FILTER_L3BCAST } },
+  /* System Management MIBS */
+  { 99   , ASN_INTEGER    , RWRITE, var_SystemMgmtTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_MGMT, KWN_SYSTEM_MGMT_APPLY } },
+  { 100  , ASN_INTEGER    , RWRITE, var_SystemMgmtTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_MGMT, KWN_SYSTEM_MGMT_RESET } },
+  { 101  , ASN_INTEGER    , RWRITE, var_SystemMgmtTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_MGMT, KWN_SYSTEM_MGMT_REBOOT } },
+  { 102  , ASN_INTEGER    , RWRITE, var_SystemMgmtTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_MGMT, KWN_SYSTEM_MGMT_DYNAMIC_APPLY } },
+  { 103  , ASN_INTEGER    , RWRITE, var_SystemMgmtTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_MGMT, KWN_SYSTEM_MGMT_RESET_RETAINIP } },
+  /* System Information MIBS */
+  { 104  , ASN_OCTET_STR  , RWRITE, var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_NAME } },
+  { 105  , ASN_OCTET_STR  , RWRITE, var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_LOCATION } },
+  { 106  , ASN_OCTET_STR  , RWRITE, var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_CONTACT } },
+  { 107  , ASN_OCTET_STR  , RONLY , var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_DESCRIPTION } },
+  { 108  , ASN_OCTET_STR  , RONLY , var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_GEO_LATITUDE } },
+  { 109  , ASN_OCTET_STR  , RONLY , var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_GEO_LONGITUDE } },
+  { 110  , ASN_OCTET_STR  , RONLY , var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_TEMPERATURE } },
+  { 111  , ASN_OCTET_STR  , RWRITE, var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_EMAIL } },
+  { 112  , ASN_OCTET_STR  , RWRITE, var_SystemInfoTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INFO, KWN_SYSTEM_INFO_BASESTATIONID } },
+  /* System Inventory MIBS */
+  { 113  , ASN_OCTET_STR  , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_SERIALNO } },
+  { 114  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_MODEL } },
+  { 115  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_RELNUM } },
+  { 116  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_MAJNUM } },
+  { 117  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_MINNUM } },
+  { 118  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_PRODUCTID } },
+  { 119  , ASN_OCTET_STR  , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_BUILDNO } },
+  { 120  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_MAXSU } },
+  { 121  , ASN_OCTET_STR  , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_HARDWAREVERSION } },
+  { 122  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_ANTENNAGAIN1 } },
+  { 123  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_ANTENNAGAIN2 } },
+  { 124  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_ANTENNATYPE1 } },
+  { 125  , ASN_INTEGER    , RONLY , var_SystemInvTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_INV, KWN_SYSTEM_INV_ANTENNATYPE2 } },
+  /* System Tftp MIBS */
+  { 126  , ASN_OCTET_STR  , RWRITE, var_SystemTftpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TFTP, KWN_SYSTEM_TFTP_FILENAME } },
+  { 127  , ASN_INTEGER    , RWRITE, var_SystemTftpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TFTP, KWN_SYSTEM_TFTP_FILETYPE } },
+  { 128  , ASN_IPADDRESS  , RWRITE, var_SystemTftpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TFTP, KWN_SYSTEM_TFTP_SERVERIP } },
+  { 129  , ASN_INTEGER    , RONLY , var_SystemTftpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TFTP, KWN_SYSTEM_TFTP_OPSTATUS } },
+  { 130  , ASN_INTEGER    , RWRITE, var_SystemTftpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TFTP, KWN_SYSTEM_TFTP_OPTYPE } },
+  { 131  , ASN_INTEGER    , RWRITE, var_SystemTftpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TFTP, KWN_SYSTEM_TFTP_KEEPSET } },
+  /* System NTP MIBS */
+  { 132  , ASN_INTEGER    , RWRITE, var_SystemNtpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_NTP, KWN_SYSTEM_NTP_STATUS } },
+  { 133  , ASN_IPADDRESS  , RWRITE, var_SystemNtpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_NTP, KWN_SYSTEM_NTP_SERVERIP } },
+  { 134  , ASN_OCTET_STR  , RWRITE, var_SystemNtpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_NTP, KWN_SYSTEM_NTP_TIMEZONE } },
+  { 135  , ASN_OCTET_STR  , RONLY , var_SystemNtpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_NTP, KWN_SYSTEM_NTP_LOCALTIME } },
+  /* System GPS MIBS */
+  { 136  , ASN_INTEGER    , RWRITE, var_SystemGpsTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_GPS, KWN_SYSTEM_GPSSTATUS } },
+  { 137  , ASN_INTEGER    , RWRITE, var_SystemGpsTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_GPS, KWN_SYSTEM_GPSINTERVAL } },
+  /* System DYING GASP MIBS */
+  { 138  , ASN_INTEGER    , RWRITE, var_SystemDyingGaspTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_DYING_GASP, KWN_SYSTEM_DYINGGASPSTATUS } },
+  { 139  , ASN_INTEGER    , RWRITE, var_SystemDyingGaspTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_DYING_GASP, KWN_SYSTEM_DYINGGASPACK } },
+  /* System LEDS MIBS */
+  { 140  , ASN_INTEGER    , RWRITE, var_SystemLedsTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_LEDS, KWN_SYSTEM_LEDSSTATUS } },
+  /* System Logging MIBS */
+  { 141  , ASN_IPADDRESS  , RWRITE, var_SystemLoggingTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_LOG, KWN_SYSTEM_SYSLOGSERVERIP } },
+  { 142  , ASN_INTEGER    , RWRITE, var_SystemLoggingTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_LOG, KWN_SYSTEM_SYSLOGSERVERPORT } },
+  { 143  , ASN_INTEGER    , RWRITE, var_SystemLoggingTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_LOG, KWN_SYSTEM_TEMPLOGSTATUS } },
+  { 144  , ASN_INTEGER    , RWRITE, var_SystemLoggingTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_LOG, KWN_SYSTEM_TEMPLOGINTERVAL } },
+  /* System HTTP MIBS */
+  { 145  , ASN_OCTET_STR  , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_ADMINPASS } },
+  { 146  , ASN_OCTET_STR  , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_USERPASS } },
+  { 147  , ASN_OCTET_STR  , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_SUPERUSERPASS } },
+  { 148  , ASN_INTEGER    , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_HTTPSTATUS } },
+  { 149  , ASN_INTEGER    , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_HTTPPORT } },
+  { 150  , ASN_INTEGER    , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_HTTPSSTATUS } },
+  { 151  , ASN_INTEGER    , RWRITE, var_SystemHttpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_HTTP, KWN_SYSTEM_HTTP_HTTPSPORT } },
+  /* System Telnet / SSH MIBS */
+  { 152  , ASN_INTEGER    , RWRITE, var_SystemTelnetSSHTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TELNETSSH, KWN_SYSTEM_TELNETSSH_TELNETSTATUS } },
+  { 153  , ASN_INTEGER    , RWRITE, var_SystemTelnetSSHTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TELNETSSH, KWN_SYSTEM_TELNETSSH_TELNETPORT } },
+  { 154  , ASN_INTEGER    , RWRITE, var_SystemTelnetSSHTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TELNETSSH, KWN_SYSTEM_TELNETSSH_TELNETSESSIONS } },
+  { 155  , ASN_INTEGER    , RWRITE, var_SystemTelnetSSHTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TELNETSSH, KWN_SYSTEM_TELNETSSH_SSHSTATUS} },
+  { 156  , ASN_INTEGER    , RWRITE, var_SystemTelnetSSHTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TELNETSSH, KWN_SYSTEM_TELNETSSH_SSHPORT } },
+  { 157  , ASN_INTEGER    , RWRITE, var_SystemTelnetSSHTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_TELNETSSH, KWN_SYSTEM_TELNETSSH_SSHSESSIONS } },
+  /* System SNMP MIBS */
+  { 158  , ASN_OCTET_STR  , RWRITE, var_SystemSnmpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_SNMP, KWN_SYSTEM_SNMP_STATUS } },
+  { 159  , ASN_OCTET_STR  , RWRITE, var_SystemSnmpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_SNMP, KWN_SYSTEM_SNMP_VERSION } },
+  { 160  , ASN_OCTET_STR  , RWRITE, var_SystemSnmpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_SNMP, KWN_SYSTEM_SNMP_READPWD } },
+  { 161  , ASN_IPADDRESS  , RWRITE, var_SystemSnmpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_SNMP, KWN_SYSTEM_SNMP_TRAPHOSTIPADDRESS } },
+  { 162  , ASN_OCTET_STR  , RWRITE, var_SystemSnmpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_SNMP, KWN_SYSTEM_SNMP_TRAPHOSTPASS } },
+  { 163  , ASN_OCTET_STR  , RWRITE, var_SystemSnmpTable, 4, { KWN_SMAC, KWN_MANAGEMENT, KWN_SYSTEM_SNMP, KWN_SYSTEM_SNMP_READWRITEPWD } },
+  /* Wireless Stats MIBS */
+  { 164  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_RADIO_INDEX } },
+  { 165  , ASN_OCTET_STR  , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MACADDRESS } },
+  { 166  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_REMOTEPARTNERS } },
+  { 167  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_DATA_TXTOTALPACKETS } },
+  { 168  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_DATA_RXTOTALPACKETS } },
+  { 169  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_DATA_TXMULTICASTPACKETS } },
+  { 170  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_DATA_RXMULTICASTPACKETS } },
+  { 171  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_DATA_TXUNICASTPACKETS } },
+  { 172  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_DATA_RXUNICASTPACKETS } },
+  { 173  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_TXPACKETS } },
+  { 174  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_RXPACKETS } },
+  { 175  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_TXBEACONS } },
+  { 176  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_RXBEACONS } },
+  { 177  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_AUTHREQSENT } },
+  { 178  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_AUTHREQRECV } },
+  { 179  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_AUTHCNF } },
+  { 180  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_AUTHREJ } },
+  { 181  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_DEAUTHREQSENT } },
+  { 182  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_DEAUTHREQRECV } },
+  { 183  , ASN_OCTET_STR  , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_AUTHRESLAST } },
+  { 184  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_ASSOCREQSENT } },
+  { 185  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_ASSOCREQRECV } },
+  { 186  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_ASSOCCNF } },
+  { 187  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_ASSOCREJ } },
+  { 188  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_DEASSOCREQSENT } },
+  { 189  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_DEASSOCREQRECV } },
+  { 190  , ASN_OCTET_STR  , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MGMT_ASSOCRESLAST } },
+  { 191  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_MPDU_ERRORS } },
+  { 192  , ASN_INTEGER    , RONLY , var_WirelessStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_WIRELESSSTATS, KWN_WIRELESSSTATSENTRY, KWN_WIRELESSSTATS_PHY_ERRORS } },
+  /* Ethernet Stats MIBS */
+  { 193  , ASN_INTEGER    , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_INDEX } },
+  { 194  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_STATUS } },
+  { 195  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_MACADDRESS } },
+  { 196  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_SPEED } },
+  { 197  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_DUPLEX } },
+  { 198  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TXTOTALPACKETS } },
+  { 199  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RXTOTALPACKETS } },
+  { 200  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TXTOTALBYTES } },
+  { 201  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RXTOTALBYTES } },
+  { 202  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TXERRORS } },
+  { 203  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RXERRORS } },
+  { 204  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_L2MCASTDROPCNT } },
+  { 205  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_L2MCASTDROPCNT } },
+  { 206  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_L3MCASTDROPCNT } },
+  { 207  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_L3MCASTDROPCNT } },
+  { 208  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_L2BCASTDROPCNT } },
+  { 209  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_L2BCASTDROPCNT } },
+  { 210  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_L3BCASTDROPCNT } },
+  { 211  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_L3BCASTDROPCNT } },
+  { 212  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_DROPPED } },
+  { 213  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_DROPPED } },
+  { 214  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_MULTICAST } },
+  { 215  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_MULTICAST } },
+  { 216  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_TX_UNICAST } },
+  { 217  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_UNICAST } },
+  { 218  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_CRC_ERRORS } },
+  { 219  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_OVERSIZE_ERRORS } },
+  { 220  , ASN_OCTET_STR  , RONLY , var_EthernetStatsTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ETHERNETSTATS, KWN_ETHERNETSTATSENTRY, KWN_ETHSTATS_RX_OVERRUN_ERRORS } },
+  /* Assoc MIBS */
+  { 221  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_RADIO_INDEX } },
+  { 222  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_SEC_INDEX } },
+  { 223  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_MAC } },
+  { 224  , ASN_IPADDRESS  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_IP } },
+  { 225  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_LAT } },
+  { 226  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_LONG } },
+  { 227  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_LAT } },
+  { 228  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_LONG } },
+  { 229  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_RX_RATE } },
+  { 230  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_TX_RATE } },
+  { 231  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_RX_TPUT } },
+  { 232  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_TX_TPUT } },
+  { 233  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_SNR_A1 } },
+  { 234  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_SNR_A2 } },
+  { 235  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_SNR_A1 } },
+  { 236  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_SNR_A2 } },
+  { 237  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_PHY_ERR } },
+  { 238  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_PHY_ERR } },
+  { 239  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_MPDU_ERR } },
+  { 240  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_MPDU_ERR } },
+  { 241  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_RETRIES } },
+  { 242  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_RETRIES } },
+  { 243  , ASN_INTEGER    , RWRITE, var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LINKTEST_DUR } },
+  { 244  , ASN_INTEGER    , RWRITE, var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LINKTEST_DIR } },
+  { 245  , ASN_INTEGER    , RWRITE, var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LINKTEST_START_STOP } },
+  { 246  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_NOISE_FLOOR } },
+  { 247  , ASN_INTEGER    , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_NOISE_FLOOR } },
+  { 248  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_CUSTOMERNAME } },
+  { 249  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_CUSTOMERNAME } },
+  { 250  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_LOCAL_LINKID } },
+  { 251  , ASN_OCTET_STR  , RONLY , var_AssocTable, 5, { KWN_SMAC, KWN_MONITOR, KWN_ASSOCLIST, KWN_ASSOCENTRY, KWN_ASSOC_REMOTE_LINKID } },
+};
+
+/****************************************************************************
+*                                                                           *
+*         init_kwnmib() - perform any required initialization              *
+*                                                                           *
+****************************************************************************/
+void init_kwnmib ( void ) 
+{
+  /* register ourselves with the agent to handle our mib tree */
+  REGISTER_MIB( "kwnmib", kwnmib_variables, variable7, kwnmib_variables_oid );
+}
+
+void shutdown_kwnmib ( void ) 
+{
+}
+
+/****************************************************************************
+*                                                                           *
+*         kwn_sys_cmd() - Get System command output                         *
+*                                                                           *
+****************************************************************************/
+void kwn_sys_cmd( const char* cmd, uint8_t* buf )
+{
+    FILE *fp = NULL;
+    uint8_t  a[ KWN_UCI_CMD_OUTPUT_LEN_MAX ] = { 0 };
+    uint8_t  *token;
+    uint16_t len;
+
+    fp = popen( cmd, "r" );
+    if( fp == NULL )
+        return;
+    memset( a, '\0', sizeof(a) );
+    while( fgets( a, sizeof(a), fp ) != NULL )
+    {
+        /*printf("%s",a);*/
+    }
+    pclose( fp );
+
+    if( a[0] == '\0' ) {
+        memcpy( buf, "-NA-", sizeof( buf ) );
+        return;
+    }
+    token = strtok( a, "\n" );
+    len = strlen( token );
+    memcpy( buf, token, len );
+    return;
+}
+
+/****************************************************************************
+*                                                                           *
+*         kwn_conv_str_to_ip() - Convert string to Uint32 IP                *
+*                                                                           *
+****************************************************************************/
+void kwn_conv_str_to_ip( int8_t* conv_ip, uint32_t* ip_addr )
+{
+    uint32_t val;
+    int8_t  *tok, *ptr;
+
+    tok = strtok( conv_ip, "." );
+
+    while( tok != NULL )
+    {
+        val = strtoul( tok, &ptr, 0 );
+        *ip_addr = ( *ip_addr << 8 ) + val;
+        tok = strtok( NULL, "." );
+    }
+    return;
+}
+
+/****************************************************************************
+*                                                                           *
+*         kwn_conv_uint32_to_ip() - Convert Uint32 IP to string             *
+*                                                                           *
+****************************************************************************/
+void kwn_conv_uint32_to_ip( u_char *val, size_t len, uint8_t* byte )
+{
+    char cmd[ 100 ];
+    char buf1[ 30 ];
+    char buf2[ 30 ];
+    u_long ip;
+
+    memcpy( buf1, val, (len > 8) ? 8 : len );
+    ip = *( (u_long *) buf1 );
+    buf2[ 0 ] = ( ip & 0xFF );
+    buf2[ 1 ] = ( (ip >>  8) & 0xFF );
+    buf2[ 2 ] = ( (ip >> 16) & 0xFF );
+    buf2[ 3 ] = ( (ip >> 24) & 0xFF );
+
+    sprintf( byte, "%d.%d.%d.%d", buf2[0], buf2[1], buf2[2], buf2[3] );
+    return;
+}
+
+/****************************************************************************
+*                                                                           *
+*         kwn_get_value() - Get value based on type                         *
+*                                                                           *
+****************************************************************************/
+void kwn_get_value( int type, char* cmd, size_t *var_len, kwn_snmp_array *arr )
+{
+    uint32_t resaddr = 0;
+    char *ptr;
+    int i;
+
+    kwn_sys_cmd( cmd, &res_str[0] );
+    switch( type )
+    {
+        case KWN_TYPE_INTEGER32:
+            if( !memcmp( res_str, "-NA-", 4 ) )
+                res_val = -1;
+            else
+            {
+                if( arr != NULL )
+                {
+                    for ( i = 0; i < (arr->len); i++ )
+                    {
+                         if( strncmp( res_str, arr->array[i].str, strlen(res_str) ) == 0 )
+                         {
+                            res_val = arr->array[i].value;
+                            break;
+                         }
+                    }
+                }
+                else
+                {
+                    res_val = strtol( res_str, &ptr, KWN_UCI_STR_ENUM_LEN );
+                }
+            }
+            *var_len = sizeof ( long );
+            break;
+        case KWN_TYPE_DISPLAY_STRING:
+            res_str[ strlen( res_str ) ] = '\0';
+            *var_len = strlen( res_str );
+            break;
+        case KWN_TYPE_IP_ADDRESS:
+            res_str[ strlen( res_str ) ] = '\0';
+            kwn_conv_str_to_ip( &res_str[0], &resaddr );
+            res_ip = ntohl( resaddr );
+            *var_len = sizeof( in_addr_t );
+            break;
+    }
+}
+
+/****************************************************************************
+*                                                                           *
+*          kwn_enum_str_set() - Set value based on input value              *
+*                                                                           *
+****************************************************************************/
+void kwn_enum_str_set ( long long_val, kwn_snmp_array *arr, char *string_val )
+{
+    int i;
+    int len;
+
+    for ( i = 0 ; i < (arr->len); i++ )
+    {
+        if ( long_val == arr->array[i].value )
+        {
+            memcpy ( string_val, arr->array[i].str, strlen( arr->array[i].str ) );
+            len = strlen( arr->array[i].str );
+            string_val [ len ] = '\0';
+            break;
+        }
+    }
+}
+
+/****************************************************************************
+*                                                                           *
+*          kwn_rm_str_space() - function to remove trailing spaces          *
+*                                                                           *
+****************************************************************************/
+void kwn_rm_str_space( size_t *var_len ) 
+{ 
+    // To keep track of non-space character count 
+    int count = 0,i; 
+
+    /* Traverse the given string. If current character is not space, 
+     * then place it at index 'count++' 
+     * */
+    for ( i = 0; res_str[i]; i++) 
+    {
+        if (res_str[i] != ' ') 
+            res_str[count++] = res_str[i];
+    }//here count is incremented 
+    res_str[count] = '\0'; 
+    *var_len = strlen( res_str );
+    return;
+} 
+
+/****************************************************************************
+*                                                                           *
+*  kwn_dhcp_inet_handle() - function to get inet address during dhcp case   *
+*                                                                           *
+****************************************************************************/
+void kwn_dhcp_inet_handle( const char* cmd )
+{
+    FILE *fp;
+    char *tok, *p;
+    short int len;
+    char ip[20];
+    char a[100];
+    int i = 0;
+    uint32_t resaddr = 0;
+
+    memset( a, '\0', sizeof( a ) );
+    memset( ip, '\0', sizeof( ip ) );
+    strcpy(ip,"0.0.0.0");
+
+    fp = popen( cmd, "r" );
+    while( fgets( a, sizeof( a ), fp ) != NULL )
+    {
+        /*printf("%s\n", a);*/
+        if( i == 1 )
+            break;
+        i++;
+    }
+    pclose( fp );
+
+    p = strstr(a,"Bcast");
+
+    if( p == NULL )
+    {
+        printf("No occurance of inet\n");
+    }
+    else
+    {
+        tok = strtok(a,"inet addr:");
+        len = strlen( tok );
+        memcpy( ip, tok, len );
+    }
+    len = strlen( ip );
+    ip[len] = '\0';
+    kwn_conv_str_to_ip( &ip[0], &resaddr );
+    res_ip = ntohl( resaddr );
+    return;
+}
+
+/****************************************************************************
+*                                                                           *
+*  kwn_dhcp_mask_handle() - function to get inet address during dhcp case   *
+*                                                                           *
+****************************************************************************/
+void kwn_dhcp_mask_handle(  const char* cmd )
+{
+    FILE *fp;
+    char *tok, *p;
+    short int len;
+    char ip[20];
+    char a[100];
+    int i = 0;
+    uint32_t resaddr = 0;
+
+    memset( a, '\0', sizeof( a ) );
+    memset( ip, '\0', sizeof( ip ) );
+    strcpy(ip,"0.0.0.0");
+
+    fp = popen( cmd, "r" );
+    while( fgets( a, sizeof( a ), fp ) != NULL )
+    {
+        /*printf("%s\n", a);*/
+        if( i == 1 )
+            break;
+        i++;
+    }
+    pclose( fp );
+
+    p = strstr(a,"Bcast");
+
+    if( p == NULL )
+    {
+        printf("No occurance of inet\n");
+    }
+    else
+    {
+        tok = strtok(a,": \n");
+        while( tok != NULL)
+        {
+            memset( ip, '\0', sizeof( ip ) );
+            len = strlen(tok);
+            memcpy(ip,tok,len);
+            tok = strtok(NULL, ": \n");
+        }
+    }
+    len = strlen( ip );
+    ip[len] = '\0';
+    kwn_conv_str_to_ip( &ip[0], &resaddr );
+    res_ip = ntohl( resaddr );
+    return;
+}
+
+/**********************************************************************************
+*                                                                                 *
+*  kwn_dhcp_gateway_handle() - function to get gateway address during dhcp case   *
+*                                                                                 *
+***********************************************************************************/
+void kwn_dhcp_gateway_handle(  const char* cmd )
+{
+    FILE *fp;
+    char *tok, *p;
+    short int len;
+    char gip[20];
+    char a[100];
+    int i = 0, j = 0;
+    uint32_t resaddr = 0;
+
+    memset( a, '\0', sizeof( a ) );
+    memset( gip, '\0', sizeof( gip ) );
+    strcpy(gip,"0.0.0.0");
+
+    fp = popen( cmd, "r" );
+    while( fgets( a, sizeof( a ), fp ) != NULL )
+    {
+        /*printf("%s\n", a);*/
+        if( i == 1 )
+            break;
+        i++;
+    }
+    pclose( fp );
+
+    p = strstr(a,"default");
+
+    if( p == NULL )
+    {
+        printf("No occurance of default in ip route\n");
+    }
+    else
+    {
+        tok = strtok(a," ");
+
+        while( tok != NULL)
+        {
+            printf( " %s\n", tok );
+            if( j == 2 )
+            {
+                memset( gip, '\0', sizeof( gip ) );
+                len = strlen(tok);
+                memcpy(gip,tok,len);
+                break;
+            }
+            j++;
+            tok = strtok(NULL, " ");
+        }
+    }
+    printf("%s",gip);
+    len = strlen( gip );
+    gip[len] = '\0';
+    kwn_conv_str_to_ip( &gip[0], &resaddr );
+    res_ip = ntohl( resaddr );
+    return;
+}
+
+void kwn_bw_change()
+{
+    char cmd[50];
+    long ullmt, dllmt;
+    
+    /* Get Bandwidth */
+    memset(cmd, '\0', sizeof(cmd));
+    memset( res_str, '\0', sizeof( res_str ) );
+    sprintf(cmd,"uci get wireless.wifi1.htmode");
+    kwn_sys_cmd( cmd, &res_str[0] );
+    
+    if( !strcmp( res_str, "HT20" )  ) {
+        ullmt = 192000;
+        dllmt = 192000;
+    }
+    else if( !strcmp( res_str, "HT40+" ) || !strcmp( res_str, "HT40-") ) {
+        ullmt = 400000;
+        dllmt = 400000;
+    }
+    else if( !strcmp( res_str, "HT80" )  ) {
+        ullmt = 867000;
+        dllmt = 867000;
+    }
+    else {
+        ullmt = 73000;
+        dllmt = 73000;
+    }
+    sprintf( cmd, "uci set wireless.@wifi-iface[1].ullmt='%d'", ullmt );
+    system( cmd );
+    sprintf( cmd, "uci set wireless.@wifi-iface[1].dllmt='%d'", dllmt );
+    system( cmd );
+}
+
+void kwn_reset_channel()
+{
+#define RUSSIA   5011
+#define INDIA_UL 5016
+#define INDIA_L  5017
+#define INDIA    5018
+#define INDIA_5  5019
+
+    char cmd[50];
+    int def_chan = 165;
+    int coun;
+    
+    /* Get country */
+    memset(cmd, '\0', sizeof(cmd));
+    memset( res_str, '\0', sizeof( res_str ) );
+    sprintf(cmd,"uci get wireless.wifi1.country");
+    kwn_sys_cmd( cmd, &res_str[0] );
+    coun = atoi( res_str );
+
+    /* Get Radiomode */
+    memset(cmd, '\0', sizeof(cmd));
+    memset( res_str, '\0', sizeof( res_str ) );
+    sprintf(cmd,"uci get wireless.@wifi-iface[1].mode");
+    kwn_sys_cmd( cmd, &res_str[0] );
+
+    if( !strcmp( res_str, "sta" )  ) {
+        system("uci set wireless.wifi1.channel='auto'");
+        return;
+    }
+    switch( coun )
+    {
+        case RUSSIA:
+            def_chan = 100; /* 200 to 183 */
+            break;
+        case INDIA_UL:
+            def_chan = 170; /* 165 to 175 */
+            break;
+        case INDIA_L:
+            def_chan = 160; /* 145 to 175 */
+            break;
+        case INDIA:
+            def_chan = 120; /* 22 to 183 */
+            break;
+        case INDIA_5:
+            def_chan = 120; /* 22 to 183 */
+            break;
+        default:
+            break;
+    }
+    memset( cmd, '\0', sizeof( cmd ) );
+    sprintf( cmd, "uci set wireless.wifi1.channel='%d'",def_chan );
+    system( cmd );
+}
+
+void kwn_reset_datarate( long stream )
+{
+    uint8_t cmd[100];
+    uint8_t min_srate = 0, max_srate = 9, min_drate = 10, max_drate = 19;
+    uint8_t srate = 3, drate = 13;
+
+    memset(cmd, '\0', sizeof(cmd));
+    memset( res_str, '\0', sizeof( res_str ) );
+    sprintf(cmd,"uci get wireless.wifi1.hwmode");
+    kwn_sys_cmd( cmd, &res_str[0] );
+    if( !strcmp( res_str, "11a" )  ) {
+        drate = 3;
+        stream = 1;
+        min_srate = 0;
+        max_srate = 7;
+        min_drate = 0;
+        max_drate = 7;
+    }
+    if( !strcmp( res_str, "11na" ) ) {
+        drate = 11;
+        min_srate = 0;
+        max_srate = 7;
+        min_drate = 8;
+        max_drate = 15;
+    }
+    sprintf(cmd,"uci set wireless.wifi1.spatialstream='%d'",stream);
+    system(cmd);
+    if( stream == 1 ) {
+        sprintf(cmd,"uci set wireless.wifi1.ddrsrate='%d'",srate);
+        system(cmd);
+        sprintf(cmd,"uci set wireless.wifi1.ddrsminrate='%d'",min_srate);
+        system(cmd);
+        sprintf(cmd,"uci set wireless.wifi1.ddrsmaxrate='%d'",max_srate);
+        system(cmd);
+    }
+    else if( stream == 2 ) {
+        sprintf(cmd,"uci set wireless.wifi1.ddrsrate='%d'",drate);
+        system(cmd);
+        sprintf(cmd,"uci set wireless.wifi1.ddrsminrate='%d'",min_drate);
+        system(cmd);
+        sprintf(cmd,"uci set wireless.wifi1.ddrsmaxrate='%d'",max_drate);
+        system(cmd);
+    }
+    else {
+        sprintf(cmd,"uci set wireless.wifi1.ddrsrate='3'");
+        system(cmd);
+        sprintf(cmd,"uci set wireless.wifi1.ddrsminrate='%d'",min_srate);
+        system(cmd);
+        sprintf(cmd,"uci set wireless.wifi1.ddrsmaxrate='%d'",max_drate);
+        system(cmd);
+    }
+}
+
+void kwn_reset_tx_params()
+{
+    long stream = 3; /* Auto */
+
+    system("uci set wireless.wifi1.ddrsstatus='1'");
+    kwn_reset_datarate( stream );
+}
+
+void kwn_reset_nwkmode_params()
+{
+    char cmd[100];
+    uint8_t cmd_buf[10];
+    uint8_t rad_mode[10];
+    uint8_t eth_ip[20],eth_msk[20],eth_gip[20],eth_addtype[10];
+
+    /* Get Radio Mode */
+    memset(cmd, '\0', sizeof(cmd));
+    memset(rad_mode, '\0', sizeof(rad_mode));
+    sprintf(cmd,"uci get wireless.@wifi-iface[1].mode");
+    kwn_sys_cmd( &cmd[0], &rad_mode[0] );
+
+    memset(cmd, '\0', sizeof(cmd));
+    memset(cmd_buf, '\0', sizeof(cmd_buf));
+    sprintf(cmd,"uci get network.param.networkmode");
+    kwn_sys_cmd( &cmd[0], &cmd_buf[0] );
+
+    if( ( strcmp(rad_mode,"sta") == 0 ) && ( strcmp(cmd_buf,"2") == 0 ) ) {
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_addtype, '\0', sizeof(eth_addtype));
+        sprintf(cmd,"uci get network.lan.proto");
+        kwn_sys_cmd( &cmd[0], &eth_addtype[0] );
+
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_ip, '\0', sizeof(eth_ip));
+        sprintf(cmd,"uci get network.lan.ipaddr");
+        kwn_sys_cmd( &cmd[0], &eth_ip[0] );
+
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_msk, '\0', sizeof(eth_msk));
+        sprintf(cmd,"uci get network.lan.netmask");
+        kwn_sys_cmd( &cmd[0], &eth_msk[0] );
+
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_gip, '\0', sizeof(eth_gip));
+        sprintf(cmd,"uci get network.lan.gateway");
+        kwn_sys_cmd( &cmd[0], &eth_gip[0] );
+
+        sprintf(cmd,"uci set network.lan.proto='static'");
+        system(cmd);
+        sprintf(cmd,"uci set network.lan.ipaddr='192.168.3.1'");
+        system(cmd);
+        sprintf(cmd,"uci set network.lan.netmask='255.255.255.0'");
+        system(cmd);
+        sprintf(cmd,"uci set network.lan.gateway='192.168.3.1'");
+        system(cmd);
+        sprintf(cmd,"uci set network.kweth.ipaddr='%s'",eth_ip);
+        system(cmd);
+        sprintf(cmd,"uci set network.kweth.netmask='%s'",eth_msk);
+        system(cmd);
+        sprintf(cmd,"uci set network.kweth.gateway='%s'",eth_gip);
+
+        system(cmd);
+    }
+    else {
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_addtype, '\0', sizeof(eth_addtype));
+        sprintf(cmd,"uci get network.kweth.proto");
+        kwn_sys_cmd( &cmd[0], &eth_addtype[0] );
+
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_ip, '\0', sizeof(eth_ip));
+        sprintf(cmd,"uci get network.kweth.ipaddr");
+        kwn_sys_cmd( &cmd[0], &eth_ip[0] );
+
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_msk, '\0', sizeof(eth_msk));
+        sprintf(cmd,"uci get network.kweth.netmask");
+        kwn_sys_cmd( &cmd[0], &eth_msk[0] );
+
+        memset(cmd, '\0', sizeof(cmd));
+        memset(eth_gip, '\0', sizeof(eth_gip));
+        sprintf(cmd,"uci get network.kweth.gateway");
+        kwn_sys_cmd( &cmd[0], &eth_gip[0] );
+
+        sprintf(cmd,"uci set network.lan.proto='%s'",eth_addtype);
+        system(cmd);
+        sprintf(cmd,"uci set network.lan.ipaddr='%s'",eth_ip);
+        system(cmd);
+        sprintf(cmd,"uci set network.lan.netmask='%s'",eth_msk);
+        system(cmd);
+        sprintf(cmd,"uci set network.lan.gateway='%s'",eth_gip);
+        system(cmd);
+    }
+}
+
+void kwn_radiomode_change()
+{
+    char cmd[100];
+    uint8_t cmd_buf[10];
+    uint8_t rad_mode[10];
+
+    /* Get Radio Mode */
+    memset(cmd, '\0', sizeof(cmd));
+    memset(rad_mode, '\0', sizeof(rad_mode));
+    sprintf(cmd,"uci get wireless.@wifi-iface[1].mode");
+    kwn_sys_cmd( &cmd[0], &rad_mode[0] );
+
+    /* Get Network Mode */
+    memset(cmd, '\0', sizeof(cmd));
+    memset(cmd_buf, '\0', sizeof(cmd_buf));
+    sprintf(cmd,"uci get network.param.networkmode");
+    kwn_sys_cmd( &cmd[0], &cmd_buf[0] );
+
+    if( ( strcmp(rad_mode,"ap") == 0 ) && ( strcmp(cmd_buf,"2") == 0 ) ) {
+        memset(cmd, '\0', sizeof(cmd));
+        sprintf(cmd,"uci set network.param.networkmode='1'");
+        system( cmd );
+        kwn_reset_nwkmode_params();
+    }
+    kwn_reset_channel();
+    /* Reset Vlan */
+    system("uci set vlan.vlan.status='1'");
+    system("uci set vlan.vlan.mode='0'");
+}
+
+void get_active_frequency( int ind, uint16_t *freq, uint8_t *chan )
+{
+    int sk_fd = -1;
+    struct iwreq iwr;
+    void *buf;
+    char ifname[5];
+    int len, i;
+    kwn_freqlist kwn_freq_list;
+
+    sprintf( ifname, "ath%d", ind );
+    (void) strncpy( iwr.ifr_name, ifname, sizeof( iwr.ifr_name ) );
+
+    iwr.u.data.pointer = ( void *) buf;
+    iwr.u.data.length = sizeof( uint16_t );
+    iwr.u.data.flags = 0;
+    sk_fd = socket( AF_INET, SOCK_DGRAM, 0 );
+
+    len = sizeof( uint16_t );
+    if( sk_fd < 0 ) {
+        sk_fd = -1;
+        return;
+    }
+    if( ioctl( sk_fd, SIOCGIWFREQ, &iwr ) < 0 )
+    {
+        close( sk_fd );
+        return;
+    }
+    else
+    {
+        *freq = (uint16_t)(iwr.u.freq.m / 100000 );
+    }
+    close( sk_fd );
+    get_supported_channels( ind, &kwn_freq_list );
+    for( i = 0; i< kwn_freq_list.num_chans; i++ )
+    {
+        if( kwn_freq_list.array[i].mhz == *freq )
+        {
+            *chan = kwn_freq_list.array[i].channel;
+            return;
+        }
+    }
+    return;
+}
+
+int get_supported_channels( int ind, kwn_freqlist *kwn_freq_list )
+{
+    int sk_fd = -1, i, num_chans = 0;
+    struct iwreq iwr;
+    struct ieee80211req_chaninfo *chans;
+    unsigned char buf[ 24 * 1024 ]  = { 0 };
+    char cmd[100], ifname[5];
+    int len;
+
+    sprintf( ifname, "ath%d", ind );
+    (void) strncpy( iwr.ifr_name, ifname, sizeof( iwr.ifr_name ) );
+
+    iwr.u.data.pointer = ( void *) buf;
+    iwr.u.data.length = sizeof( struct ieee80211req_chaninfo );
+    iwr.u.data.flags = 0;
+    sk_fd = socket( AF_INET, SOCK_DGRAM, 0 );
+
+    len = sizeof( struct ieee80211req_chaninfo );
+    if( sk_fd < 0 ) {
+        sk_fd = -1;
+        return -1;
+    }
+    if( ioctl( sk_fd, IEEE80211_IOCTL_GETCHANINFO, &iwr ) < 0 )
+    {
+        close( sk_fd );
+        return -1;
+    }
+    else
+    {
+        chans = ( struct ieee80211req_chaninfo * ) buf;
+        for( i = 0; i < chans->ic_nchans; i++ )
+        {
+            kwn_freq_list->array[i].mhz = chans->ic_chans[i].ic_freq;
+            kwn_freq_list->array[i].channel = chans->ic_chans[i].ic_ieee;
+            num_chans++;
+        }
+    }
+    kwn_freq_list->num_chans = num_chans; 
+    close( sk_fd );
+    return 0;
+}
+
+int get_assoclist( int radio_ind )
+{
+    int sk_fd = -1;
+    struct ieee80211req_sta_info *si;
+    struct iwreq iwr;
+    unsigned char *cp = NULL;
+    unsigned char buf[ 24 * 1024 ]  = { 0 };
+    int len = 0;
+    int num = 0;
+    char cmd[100];
+
+    kwn_assoc_list.no_of_links = 0;
+    (void) memset( &iwr, 0, sizeof( iwr ) );
+    (void) strncpy( iwr.ifr_name, "ath1", sizeof( iwr.ifr_name ) );
+    iwr.u.data.pointer = ( void * ) buf;
+    iwr.u.data.length = sizeof( buf );
+    sk_fd = socket( AF_INET, SOCK_DGRAM, 0 );
+
+    if( sk_fd < 0 ) {
+        sk_fd = -1;
+        return -1;
+    }
+    if( ioctl( sk_fd, IEEE80211_IOCTL_STA_INFO, &iwr ) < 0 ) {
+        close( sk_fd );
+        return -1;
+    }
+    len = iwr.u.data.length;
+    if( len < sizeof( struct ieee80211req_sta_info ) ) {
+        close( sk_fd );
+        return -1;
+    }
+    cp = buf;
+    do {
+        si = ( struct ieee80211req_sta_info * ) cp;
+        memcpy( kwn_assoc_list.sta[num].mac, &si->isi_macaddr, KWN_MAC_ADDR_LEN );
+        memcpy( kwn_assoc_list.sta[num].l_latitude, si->isi_l_latitude + 5, sizeof( kwn_assoc_list.sta[num].l_latitude ) );
+        memcpy( kwn_assoc_list.sta[num].l_longitude, si->isi_l_longitude + 5, sizeof( kwn_assoc_list.sta[num].l_longitude ) );
+        memcpy( kwn_assoc_list.sta[num].r_latitude, si->isi_r_latitude + 5, sizeof( kwn_assoc_list.sta[num].r_latitude ) );
+        memcpy( kwn_assoc_list.sta[num].r_longitude, si->isi_r_longitude + 5, sizeof( kwn_assoc_list.sta[num].r_longitude ) );
+        kwn_assoc_list.sta[ num ].tx_rate = ( long ) ( si->isi_txratekbps / 1000 );
+        kwn_assoc_list.sta[ num ].rx_rate = ( long ) ( si->isi_rxratekbps / 1000 );
+        kwn_assoc_list.sta[ num ].tx_tput = ( long ) ( si->isi_tx_tput / 1000 );
+        kwn_assoc_list.sta[ num ].rx_tput = ( long ) ( si->isi_rx_tput / 1000 );
+        kwn_assoc_list.sta[ num ].local_snr_a1 = ( long ) si->isi_local_snr_a1;
+        kwn_assoc_list.sta[ num ].remote_snr_a1 = ( long ) si->isi_remote_snr_a1;
+        kwn_assoc_list.sta[ num ].local_snr_a2 = ( long ) si->isi_local_snr_a2;
+        kwn_assoc_list.sta[ num ].remote_snr_a2 = ( long ) si->isi_remote_snr_a2;
+        kwn_assoc_list.sta[ num ].local_phy_err = ( long ) si->isi_local_phy_err;
+        kwn_assoc_list.sta[ num ].remote_phy_err = ( long ) si->isi_remote_phy_err;
+        kwn_assoc_list.sta[ num ].local_mpdu_err = ( long ) si->isi_local_mpdu_err;
+        kwn_assoc_list.sta[ num ].remote_mpdu_err = ( long ) si->isi_remote_mpdu_err;
+        kwn_assoc_list.sta[ num ].local_retries = ( long ) si->isi_local_retries;
+        kwn_assoc_list.sta[ num ].remote_retries = ( long ) si->isi_remote_retries;
+        kwn_conv_str_to_ip( &si->isi_ip_addr[0], &kwn_assoc_list.sta[num].ip );
+        kwn_assoc_list.sta[num].ip = ntohl( kwn_assoc_list.sta[num].ip );
+        kwn_assoc_list.sta[ num ].local_noise_floor = (long) si->isi_l_noise_floor;
+        kwn_assoc_list.sta[ num ].remote_noise_floor = (long) si->isi_r_noise_floor;
+        memcpy( kwn_assoc_list.sta[ num ].l_customername, si->isi_l_customer_name, sizeof( kwn_assoc_list.sta[num].l_customername ) );
+        memcpy( kwn_assoc_list.sta[ num ].r_customername, si->isi_r_customer_name, sizeof( kwn_assoc_list.sta[num].r_customername ) );
+        memcpy( kwn_assoc_list.sta[ num ].l_linkid, si->isi_l_link_id, sizeof( kwn_assoc_list.sta[num].l_linkid ) );
+        memcpy( kwn_assoc_list.sta[ num ].r_linkid, si->isi_r_link_id, sizeof( kwn_assoc_list.sta[num].r_linkid ) );
+        num ++;
+        cp += si->isi_len, len -= si->isi_len;
+    } while( len >= sizeof( struct ieee80211req_sta_info ) );
+    close( sk_fd );
+    kwn_assoc_list.no_of_links = num;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_WlanTable() -                                                      *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_WlanTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method )
+{
+    char cmd[100];
+    int ind;
+    char *ptr;
+
+    ind = ( int ) name[ 13 ];
+    if( ind < 1 || ind > 2 )
+        return NULL;
+    ind = ind - 1;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = wlanwriteMethod;
+
+    switch ( (char) name[12] ) {
+        case KWN_WLAN_INDEX:
+            {
+                *write_method = NULL;
+                res_val = ind + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_RADIOMODE:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].mode", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_SSID:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].ssid", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_COUNTRY:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.country", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_OPMODE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.hwmode", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_SUPPORTED_BANDWIDTHS:
+            {
+                memset( res_str, '\0', sizeof( res_str ) );
+                res_val = 0;
+                sprintf( cmd, "uci get wireless.wifi%d.hwmode", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, &kwn_wireless_opmode );
+                if( ind == 0 )
+                {
+                    /* 2.4GHz Radio */
+                    if( res_val == kwn_wireless_opmode.array[0].value )
+                        sprintf( res_str, "20" );
+                    else if( res_val == kwn_wireless_opmode.array[1].value )
+                        sprintf( res_str, "20,40" );
+                    else
+                        sprintf( res_str, "-NA-" );
+                }
+                else
+                {
+                    /* 5GHz Radio */
+                    if( res_val == kwn_wireless_opmode.array[2].value )
+                        sprintf( res_str, "20" );
+                    else if( res_val == kwn_wireless_opmode.array[3].value )
+                        sprintf( res_str, "20,40" );
+                    else if( res_val == kwn_wireless_opmode.array[4].value )
+                        sprintf( res_str, "20,40,80" );
+                    else
+                        sprintf( res_str, "-NA-" );
+                }
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_BANDWIDTH:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.htmode", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_SUPPORTED_CHANNELS:
+            {
+                kwn_freqlist kwn_freq_list;
+                int i = 0, commaneed = 0;
+                char temp[30];
+               
+                get_supported_channels( ind, &kwn_freq_list );
+                for( i = 0; i < kwn_freq_list.num_chans; i++ )
+                {
+                    if( commaneed )
+                        strcat( res_str, "," );
+                    sprintf( temp, "%d (%d MHz)", kwn_freq_list.array[i].channel, kwn_freq_list.array[i].mhz );
+                    strcat( res_str, temp );
+                    commaneed = 1;
+                }
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_CHANNEL:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.channel", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_AMSDU:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].amsdu", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_UPLINK_LIMIT:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].ullmt", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_DOWNLINK_LIMIT:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].dllmt", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_HIDE_ESSID:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].hidden", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_CUSTOMER_NAME:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.customername", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_LINKID:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.linkid", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_SECURITY_ENC:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].encryption", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_SECURITY_KEY:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].key", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_MACFILTER:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].macfilter", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_MACLIST:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].maclist", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_DISTANCE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.distance", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return (u_char *) &res_val;
+            }
+        case KWN_WLAN_SHORTGI:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].shortgi", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_RXCHAINMASK:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.rxchainmask", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_ACTIVE_CHANNEL:
+            {
+                uint16_t freq = 0;
+                uint8_t chan = 0;
+                
+                res_val = 0;
+                get_active_frequency( ind, &freq, &chan );
+                if( freq != 0 ) {
+                    res_val = chan;
+                }
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_ANTENNA_GAIN:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.antennagain", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_ACTIVE_FREQUENCY:
+            {
+                uint16_t freq = 0;
+                uint8_t chan = 0;
+               
+                res_val = 0;
+                get_active_frequency( ind, &freq, &chan );
+                if( freq != 0 ) {
+                    res_val = freq;
+                }
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_TRAFFIC_SHAPING:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].shaping", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_AMPDU:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].ampdu", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_WIRELESS_INACTIVITY_TIMER:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.wifitimer", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_LINK_INACTIVITY_TIMER:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.linktimer", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_MAXIMUM_EIRP:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.maxeirp", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_RATE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.rate", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_DISABLE_LEGACY:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].dis_legacy", ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WLAN_RADIO_STATUS:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[%d].disabled", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_SU_SERVICE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.suservice", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WLAN_LINKTYPE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.linktype", ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_LinkProfileTable() -                                               *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_LinkProfileTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method )
+{
+    char cmd[100];
+    int ind1, ind2;
+    char *ptr;
+
+    ind1 = ( int ) name[ 13 ];
+    ind2 = ( int ) name[ 14 ];
+    /* Only second radio(5GHz) and one profile is supported */
+    if( ind1 != 2 || ind2 != 1 )
+        return NULL;
+    ind1 = ind1 - 1;
+    ind2 = ind2 - 1;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 2;
+    *write_method = linkprofilewriteMethod;
+
+    switch ( (char) name[12] ) {
+        case KWN_LINKPROFILE_INDEX:
+            {
+                *write_method = NULL;
+                res_val = ind1 + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_SECINDEX:
+            {
+                *write_method = NULL;
+                res_val = ind2 + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSSTATUS:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsstatus", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_SPATIALSTREAM:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.spatialstream", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSMINRATE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsminrate", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSMAXRATE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsmaxrate", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSINCTIMER:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsinctimer", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSDECTIMER:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsdectimer", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_TXRATE:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsrate", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_SUPPORTEDRATES:
+            {
+                long hwmode, bw;
+                sprintf( cmd, "uci get wireless.wifi%d.hwmode", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, &kwn_wireless_opmode );
+                hwmode = res_val;
+                memset( res_str, '\0', sizeof( res_str ) );
+                res_val = 0;
+                sprintf( cmd, "uci get wireless.wifi%d.htmode", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, &kwn_wireless_bandwidth );
+                bw = res_val;
+                /* 11A */
+                if( hwmode == kwn_wireless_opmode.array[2].value ) {
+                    /* 5MHz */
+                    if( bw == kwn_wireless_bandwidth.array[0].value ) {
+                        sprintf( res_str, "0-1.5Mbps,1-2.25Mbps,2-3Mbps,3-4.5Mbps,4-6Mbps,5-9Mbps,6-12Mbps,7-13.5Mbps" );
+                    }
+                    /* 10MHz */
+                    else if( bw == kwn_wireless_bandwidth.array[1].value ) {
+                        sprintf( res_str, "0-3Mbps,1-4.5Mbps,2-6Mbps,3-9Mbps,4-12Mbps,5-18Mbps,6-24Mbps,7-27Mbps" );
+                    }
+                    /* 20MHz */
+                    else if( bw == kwn_wireless_bandwidth.array[2].value ) {
+                        sprintf( res_str, "0-6Mbps,1-9Mbps,2-12Mbps,3-18Mbps,4-24Mbps,5-36Mbps,6-48Mbps,7-54Mbps" );
+                    }
+                    else {
+                        sprintf( res_str, "-NA-" );
+                    }
+                }
+                /* 11NA */
+                else if( hwmode == kwn_wireless_opmode.array[3].value ) {
+                    /* 5MHz */
+                    if( bw == kwn_wireless_bandwidth.array[0].value ) {
+                        sprintf( res_str, "0-1.8Mbps,1-3.6Mbps,2-5.4Mbps,3-7.2Mbps,4-10.8Mbps,5-14.4Mbps,6-16.2Mbps,7-18Mbps,8-3.6Mbps,9-7.2Mbps,10-10.8Mbps,11-14.4Mbps,12-21.7Mbps,13-28.9Mbps,14-32.5Mbps,15-36.1Mbps" );
+                    }
+                    /* 10MHz */
+                    if( bw == kwn_wireless_bandwidth.array[1].value ) {
+                        sprintf( res_str, "0-3.6Mbps,1-7.2Mbps,2-10.8Mbps,3-14.4Mbps,4-21.7Mbps,5-28.9Mbps,6-32.5Mbps,7-36.1Mbps,8-7.2Mbps,9-14.4Mbps,10-21.7Mbps,11-28.9Mbps,12-43.3Mbps,13-57.8Mbps,14-65Mbps,15-72.2Mbps" );
+                    }
+                    /* 20MHz */
+                    if( bw == kwn_wireless_bandwidth.array[2].value ) {
+                        sprintf( res_str, "0-7.2Mbps,1-14.4Mbps,2-21.7Mbps,3-28.9Mbps,4-43.3Mbps,5-57.8Mbps,6-65Mbps,7-72.2Mbps,8-14.4Mbps,9-28.9Mbps,10-43.3Mbps,11-57.8Mbps,12-86.7Mbps,13-115.6Mbps,14-130Mbps,15-144.4Mbps" );
+                    }
+                    /* 40MHz */
+                    else if( bw == kwn_wireless_bandwidth.array[3].value || bw == kwn_wireless_bandwidth.array[4].value ) {
+                        sprintf( res_str, "0-15Mbps,1-30Mbps,2-45Mbps,3-60Mbps,4-90Mbps,5-120Mbps,6-135Mbps,7-150Mbps,8-30Mbps,9-60Mbps,10-90Mbps,11-120Mbps,12-180Mbps,13-240Mbps,14-270Mbps,15-300Mbps" );
+                    }
+                    else {
+                        sprintf( res_str, "-NA-" );
+                    }
+                }
+                /* 11AC */
+                else if( hwmode == kwn_wireless_opmode.array[4].value ) {
+                    /* 5MHz */
+                    if( bw == kwn_wireless_bandwidth.array[0].value ) {
+                        sprintf( res_str, "0-1.8Mbps,1-3.6Mbps,2-5.4Mbps,3-7.2Mbps,4-10.8Mbps,5-14.4Mbps,6-16.2Mbps,7-18Mbps,8-3.6Mbps,9-7.2Mbps,10-10.8Mbps,11-14.4Mbps,12-21.7Mbps,13-28.9Mbps,14-32.5Mbps,15-36.1Mbps" );
+                    }
+                    /* 10MHz */
+                    if( bw == kwn_wireless_bandwidth.array[1].value ) {
+                        sprintf( res_str, "0-3.6Mbps,1-7.2Mbps,2-10.8Mbps,3-14.4Mbps,4-21.7Mbps,5-28.9Mbps,6-32.5Mbps,7-36.1Mbps,8-7.2Mbps,9-14.4Mbps,10-21.7Mbps,11-28.9Mbps,12-43.3Mbps,13-57.8Mbps,14-65Mbps,15-72.2Mbps" );
+                    }
+                    /* 20MHz */
+                    if( bw == kwn_wireless_bandwidth.array[2].value ) {
+                        sprintf( res_str, "0-7.2Mbps,1-14.4Mbps,2-21.7Mbps,3-28.9Mbps,4-43.3Mbps,5-57.8Mbps,6-65Mbps,7-72.2Mbps,8-86.7Mbps,9-14.4Mbps,10-28.9Mbps,11-43.3Mbps,12-57.8Mbps,13-86.7Mbps,14-115.6Mbps,15-130Mbps,16-144.4Mbps,17-173.3Mbps" );
+                    }
+                    /* 40MHz */
+                    else if( bw == kwn_wireless_bandwidth.array[3].value || bw == kwn_wireless_bandwidth.array[4].value ) {
+                        sprintf( res_str, "0-15Mbps,1-30Mbps,2-45Mbps,3-60Mbps,4-90Mbps,5-120Mbps,6-135Mbps,7-150Mbps,8-180Mbps,9-200Mbps,10-30Mbps,11-60Mbps,12-90Mbps,13-120Mbps,14-180Mbps,15-240Mbps,16-270Mbps,17-300Mbps,18-360Mbps,19-400Mbps" );
+                    }
+                    /* 80MHz */
+                    else if( bw == kwn_wireless_bandwidth.array[5].value ) {
+                        sprintf( res_str, "0-32.5Mbps,1-65Mbps,2-97.5Mbps,3-130Mbps,4-195Mbps,5-260Mbps,6-292.5Mbps,7-325Mbps,8-390Mbps,9-433.3Mbps,10-65Mbps,11-130Mbps,12-195Mbps,13-260Mbps,14-390Mbps,15-520Mbps,16-585Mbps,17-650Mbps,18-780Mbps,19-866.7Mbps" );
+                    }
+                    else {
+                        sprintf( res_str, "-NA-" );
+                    }
+                }
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_LINKPROFILE_ATPCSTATUS:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.atpcstatus", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_POWER:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.atpcpower", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_TXCHAINMASK:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.txchainmask", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSRATEINCRTHRLD:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsincthrld", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSRATEINCRTXTHRLD:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsrtxinc", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_LINKPROFILE_DDRSRATEDECRTXTHRLD:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.ddrsrtxdec", ind1 );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_NwkIPTable() -                                                     *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_NwkIPTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( cmd, '\0', sizeof( cmd ) );
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = nwkwriteMethod;
+    switch ( (char) name[10] ) {
+        case KWN_NWK_ADRSTYPE:
+            {
+                sprintf( cmd, "uci get network.lan.proto" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_NWK_IP:
+            {
+                memset( cmd, '\0', sizeof( cmd ) );
+                sprintf( cmd, "uci get network.lan.proto" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                if( memcmp(res_str, "static", 6) == 0 )
+                {
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    sprintf( cmd, "uci get network.param.networkmode" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    if( res_val == 1 )
+                    {
+                        sprintf( cmd, "uci get network.lan.ipaddr" );
+                    }
+                    else
+                    {
+                        sprintf( cmd, "uci get network.kweth.ipaddr" );
+                    }
+                    kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                }
+                else
+                {
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    sprintf( cmd, "ifconfig br-lan" );
+                    kwn_dhcp_inet_handle( cmd );
+                }
+                *var_len = sizeof( in_addr_t );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_NWK_MASK:
+            {
+                memset( cmd, '\0', sizeof( cmd ) );
+                sprintf( cmd, "uci get network.lan.proto" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                if( memcmp(res_str, "static", 6) == 0 )
+                {
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    sprintf( cmd, "uci get network.param.networkmode" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    if( res_val == 1 )
+                    {
+                        sprintf( cmd, "uci get network.lan.netmask" );
+                    }
+                    else
+                    {
+                        sprintf( cmd, "uci get network.kweth.netmask" );
+                    }
+                    kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                }
+                else
+                {
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    sprintf( cmd, "ifconfig br-lan" );
+                    kwn_dhcp_mask_handle( cmd );
+                }
+                *var_len = sizeof( in_addr_t );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_NWK_GATEWAY:
+            {
+                memset( cmd, '\0', sizeof( cmd ) );
+                sprintf( cmd, "uci get network.lan.proto" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                memset( cmd, '\0', sizeof( cmd ) );
+                if( memcmp(res_str, "static", 6) == 0 )
+                {
+                    sprintf( cmd, "uci get network.lan.gateway" );
+                    kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                }
+                else
+                {
+                    sprintf( cmd, "ip route | grep default" );
+                    kwn_dhcp_gateway_handle( cmd );
+                    *var_len = sizeof( in_addr_t );
+                }
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_NWK_DNS:
+            {
+                sprintf( cmd, "uci get network.lan.dns" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_NWK_CLEARSTATS:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_NWK_NETWORKMODE:
+            {
+                sprintf( cmd, "uci get network.param.networkmode" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_NWK_NATSTATUS:
+            {
+                sprintf( cmd, "uci get network.param.natstatus" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_NWK_WIRELESS_IP:
+            {
+                sprintf( cmd, "uci get network.lan.ipaddr" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_NWK_WIRELESS_MASK:
+            {
+                sprintf( cmd, "uci get network.lan.netmask" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_RadiusTable() -                                                     *
+ *                                                                           *
+ ****************************************************************************/
+unsigned char *
+var_RadiusTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = radiuswriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_RADIUS_STATUS:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.enableRadAuth" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_RADIUS_PRISERVER:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.primaryServer" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_RADIUS_PRIPORT:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.primaryPort" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_RADIUS_PRISECRET:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.primarySecret" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_RADIUS_SECSERVER:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.secondaryServer" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_RADIUS_SECPORT:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.secondaryPort" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_RADIUS_SECSECRET:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.secondarySecret" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_RADIUS_REAUTHTIME:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.reauthTime" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_RADIUS_RETRYTIME:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.retryTime" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_RADIUS_RETRYCOUNT:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.requestRetries" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_RADIUS_RETRYCOUNTPERIOD:
+            {
+                sprintf( cmd, "uci get wrt-radauth.sys.requestTimeout" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_VlanTable() -                                                       *
+ *                                                                           *
+ ****************************************************************************/
+unsigned char *
+var_VlanTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = vlanwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_VLAN_STATUS:
+            {
+                sprintf( cmd, "uci get vlan.vlan.status" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_MODE:
+            {
+                sprintf( cmd, "uci get vlan.vlan.mode" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_MGMTID:
+            {
+                sprintf( cmd, "uci get vlan.vlan.mgmtvlan" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_ACCESSID:
+            {
+                sprintf( cmd, "uci get vlan.vlan.accessvlan" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_TRUNKOPTION:
+            {
+                sprintf( cmd, "uci get vlan.vlan.trunkoption" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_TRUNKID:
+            {
+                sprintf( cmd, "uci get vlan.vlan.trunkvlan" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_VLAN_SVLAN:
+            {
+                sprintf( cmd, "uci get vlan.vlan.svlan" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_SVLAN_ETHERTYPE:
+            {
+                sprintf( cmd, "uci get vlan.vlan.svlanethertype" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_VLAN_BDA:
+            {
+                sprintf( cmd, "uci get vlan.vlan.bda" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_VLAN_BSA:
+            {
+                sprintf( cmd, "uci get vlan.vlan.bsa" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_VLAN_BVID:
+            {
+                sprintf( cmd, "uci get vlan.vlan.bvid" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_BISID:
+            {
+                sprintf( cmd, "uci get vlan.vlan.bisid" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_VLAN_ALLOW_TAG_MGMT:
+            {
+                sprintf( cmd, "uci get vlan.vlan.tagmgmt" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_EthernetTable() -                                                   *
+ *                                                                           *
+ ****************************************************************************/
+unsigned char *
+var_EthernetTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = ethernetwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_ETHERNET_MODE:
+            {
+                sprintf( cmd, "uci get ethernet.ethernet.mode" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ETHERNET_INACTIVITY:
+            {
+                sprintf( cmd, "uci get ethernet.ethernet.ethtimer" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ETHERNET_MTU:
+            {
+                sprintf( cmd, "uci get network.lan.mtu" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ETHERNET_CABLE_LENGTH:
+            {
+                char *tok;
+                sprintf( cmd, "ssdk_sh port cdt run 5 0 | grep cable" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+
+                tok=strtok(res_str,":");
+
+                while( tok != NULL)
+                {
+                    res_val = atoi(tok);
+                    tok = strtok(NULL, ":");
+                }
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_DhcpTable() -                                                       *
+ *                                                                           *
+ ****************************************************************************/
+unsigned char *
+var_DhcpTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+
+    *length = vp->namelen + 1;
+    *write_method = dhcpwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_DHCP_SERVER:
+            {
+                sprintf( cmd, "uci get dhcp.lan.ignore" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_DHCP_START_IP:
+            {
+                sprintf( cmd, "uci get dhcp.lan.start" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_DHCP_END_IP:
+            {
+                sprintf( cmd, "uci get dhcp.lan.limit" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_DHCP_LEASE_TIME:
+            {
+                sprintf( cmd, "uci get dhcp.lan.leasetime" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                           *
+ *   var_FilterTable() -                                                     *
+ *                                                                           *
+ ****************************************************************************/
+unsigned char *
+var_FilterTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+
+    *length = vp->namelen + 1;
+    *write_method = filterwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_FILTER_STATUS:
+            {
+                sprintf( cmd, "uci get filter.filter.status" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_FILTER_L2MCAST:
+            {
+                sprintf( cmd, "uci get filter.filter.l2mcast" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_FILTER_L3MCAST:
+            {
+                sprintf( cmd, "uci get filter.filter.l3mcast" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_FILTER_L2BCAST:
+            {
+                sprintf( cmd, "uci get filter.filter.l2bcast" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_FILTER_L3BCAST:
+            {
+                sprintf( cmd, "uci get filter.filter.l3bcast" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemManagmentTable() -                                           *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemMgmtTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemmgmtwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_MGMT_APPLY:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_MGMT_RESET:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_MGMT_REBOOT:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_MGMT_DYNAMIC_APPLY:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_MGMT_RESET_RETAINIP:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemInfoTable() -                                                *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemInfoTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+    char *lat_long_token;
+    char model[20],product[6],buildno[10];
+    long a=0 ,b=0;
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    memset( model, '\0', sizeof( model ) );
+    memset( product, '\0', sizeof( product ) );
+    memset( buildno, '\0', sizeof( buildno ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = systeminfowriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_INFO_NAME:
+            {
+                sprintf( cmd, "uci get system.@system[0].hostname" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_LOCATION:
+            {
+                sprintf( cmd, "uci get system.@system[0].location" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_CONTACT:
+            {
+                sprintf( cmd, "uci get system.@system[0].contact" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_DESCRIPTION:
+            {
+                sprintf( cmd, "fw_printenv -n model" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if( res_val == -1 )
+                {
+                    memset( cmd, '\0', sizeof( cmd ) );
+                    sprintf( cmd, "uci get variant.variant.model" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                }
+                if( res_val == 1 )
+                    strncpy(model, "API-18-5G-AC2x2-W2", 18);
+                else if( res_val == 3 )
+                    strncpy(model, "SUI-18-5G-AC2x2-W2", 18);
+                else
+                    strncpy(model, "SUI-23-5G-AC2x2-W2", 18);
+
+                memset( cmd, '\0', sizeof( cmd ) );
+                sprintf( cmd, "fw_printenv -n producttype" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.productid" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                }
+                if( res_val == 1 )
+                    strncpy(product, "PTP", 3);
+                else if( res_val == 2 )
+                    strncpy(product, "PTMP", 4);
+                
+                memset( cmd, '\0', sizeof( cmd ) );
+                sprintf( cmd, "uci get variant.variant.majnum" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                a = res_val;
+
+                memset( cmd, '\0', sizeof( cmd ) );
+                res_val = 0;
+                sprintf( cmd, "uci get variant.variant.minnum" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                b = res_val;
+
+                memset( cmd, '\0', sizeof( cmd ) );
+                sprintf( cmd, "uci get variant.variant.buildno" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                memcpy(buildno, res_str, *var_len);
+                
+                sprintf(res_str, "%s - %s - %d.%d ( %s )",model,product,a,b,buildno);
+                res_str[ strlen( res_str ) ] = '\0';
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_GEO_LATITUDE:
+            {
+                sprintf( cmd, "uci get system.gps.latitude" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                lat_long_token = strtok( res_str, " ");
+                strncpy(res_str, lat_long_token, strlen(lat_long_token) );
+                res_str[ strlen( res_str ) ] = '\0';
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_GEO_LONGITUDE:
+            {
+                sprintf( cmd, "uci get system.gps.longitude" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                lat_long_token = strtok( res_str, " ");
+                strncpy(res_str, lat_long_token, strlen(lat_long_token) );
+                res_str[ strlen( res_str ) ] = '\0';
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_TEMPERATURE:
+            {
+                sprintf( cmd, "uci get system.@system[0].temperature" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_EMAIL:
+            {
+                sprintf( cmd, "uci get system.@system[0].email" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INFO_BASESTATIONID:
+            {
+                sprintf( cmd, "uci get system.@system[0].bstid" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemInventoryTable() -                                           *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemInvTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = NULL;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_INV_SERIALNO:
+            {
+                sprintf( cmd, "fw_printenv -n amigoserial" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INV_MODEL:
+            {
+                sprintf( cmd, "fw_printenv -n model" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.model" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_RELNUM:
+            {
+                res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_MAJNUM:
+            {
+                sprintf( cmd, "uci get variant.variant.majnum" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_MINNUM:
+            {
+                sprintf( cmd, "uci get variant.variant.minnum" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_PRODUCTID:
+            {
+                sprintf( cmd, "fw_printenv -n producttype" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.productid" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_BUILDNO:
+            {
+                sprintf( cmd, "uci get variant.variant.buildno" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INV_MAXSU:
+            {
+                sprintf( cmd, "fw_printenv -n maxsu" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.maxsu" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_HARDWAREVERSION:
+            {
+                strncpy(res_str, "VER 3.0", 7);
+                res_str[ strlen( res_str ) ] = '\0';
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_INV_ANTENNAGAIN1:
+            {
+                sprintf( cmd, "fw_printenv -n antgain1" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.antgain1" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_ANTENNAGAIN2:
+            {
+                sprintf( cmd, "fw_printenv -n antgain2" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.antgain2" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_ANTENNATYPE1:
+            {
+                sprintf( cmd, "fw_printenv -n anttype1" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.anttype1" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_INV_ANTENNATYPE2:
+            {
+                sprintf( cmd, "fw_printenv -n anttype2" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                if ( res_val == -1 )
+                {
+                    sprintf( cmd, "uci get variant.variant.anttype2" );
+                    kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                    return ( u_char * ) &res_val;
+                }
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemTftpTable() -                                                *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemTftpTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemtftpwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_TFTP_FILENAME:
+            {
+                sprintf( cmd, "uci get tftp.tftp.filename" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_TFTP_FILETYPE:
+            {
+                sprintf( cmd, "uci get tftp.tftp.filetype" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TFTP_SERVERIP:
+            {
+                sprintf( cmd, "uci get tftp.tftp.serverip" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_SYSTEM_TFTP_OPSTATUS:
+            {
+                sprintf( cmd, "uci get tftp.tftp.opstatus" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TFTP_OPTYPE:
+            {
+                sprintf( cmd, "uci get tftp.tftp.optype" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TFTP_KEEPSET:
+            {
+                sprintf( cmd, "uci get tftp.tftp.keepset" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemNtpTable() -                                                 *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemNtpTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemntpwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_NTP_STATUS:
+            {
+                sprintf( cmd, "uci get system.ntp.enabled" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_NTP_SERVERIP:
+            {
+                sprintf( cmd, "uci get system.ntp.server" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_SYSTEM_NTP_TIMEZONE:
+            {
+                sprintf( cmd, "uci get system.@system[0].timezone" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_NTP_LOCALTIME:
+            {
+                sprintf( cmd, "date" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemGpsTable() -                                                 *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemGpsTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemgpswriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_GPSSTATUS:
+            {
+                sprintf( cmd, "uci get system.gps.status" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_GPSINTERVAL:
+            {
+                sprintf( cmd, "uci get system.gps.interval" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemDyingGaspTable() -                                           *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemDyingGaspTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemdyinggaspwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_DYINGGASPSTATUS:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[1].dyinggasp" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_DYINGGASPACK:
+            {
+                sprintf( cmd, "uci get wireless.@wifi-iface[1].dgackdisable" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemLedsTable() -                                                *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemLedsTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemledswriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_LEDSSTATUS:
+            {
+                sprintf( cmd, "uci get system.led.status" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemLoggingTable() -                                             *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemLoggingTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemlogwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_SYSLOGSERVERIP:
+            {
+                sprintf( cmd, "uci get system.@system[0].log_ip" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }        
+        case KWN_SYSTEM_SYSLOGSERVERPORT:
+            {
+                sprintf( cmd, "uci get system.@system[0].log_port" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }        
+        case KWN_SYSTEM_TEMPLOGSTATUS:
+            {
+                sprintf( cmd, "uci get system.@system[0].templogstatus" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }        
+        case KWN_SYSTEM_TEMPLOGINTERVAL:
+            {
+                sprintf( cmd, "uci get system.@system[0].temploginterval" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemHttpTable() -                                                *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemHttpTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemhttpwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_HTTP_ADMINPASS:
+            {
+                sprintf( res_str, "******" );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_HTTP_USERPASS:
+            {
+                sprintf( res_str, "******" );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_HTTP_SUPERUSERPASS:
+            {
+                sprintf( res_str, "******" );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_HTTP_HTTPSTATUS:
+            {
+                sprintf( cmd, "uci get uhttpd.main.listen_http" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                if( memcmp( res_str, "-NA-", 4 ) != 0 )
+                    res_val = 1;    
+                else
+                    res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_HTTP_HTTPPORT:
+            {
+                uint8_t  *token;
+                sprintf( cmd, "uci get uhttpd.main.listen_http" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                token = strtok( res_str , ":" );
+                while( token != NULL)
+                {
+                    res_val = (long)atoi(token);
+                    token = strtok(NULL, ":");
+                }
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_HTTP_HTTPSSTATUS:
+            {
+                sprintf( cmd, "uci get uhttpd.main.listen_https" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                if( memcmp( res_str, "-NA-", 4 ) != 0 )
+                    res_val = 1;    
+                else
+                    res_val = 0;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_HTTP_HTTPSPORT:
+            {
+                uint8_t  *token;
+                sprintf( cmd, "uci get uhttpd.main.listen_https" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                token = strtok( res_str , ":" );
+                while( token != NULL)
+                {
+                    res_val = (long)atoi(token);
+                    token = strtok(NULL, ":");
+                }
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemTelnetSSHTable() -                                           *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemTelnetSSHTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemtelnetsshwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_TELNETSSH_TELNETSTATUS:
+            {
+                sprintf( cmd, "uci get telnetssh.telnet.status" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TELNETSSH_TELNETPORT:
+            {
+                sprintf( cmd, "uci get telnetssh.telnet.port" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TELNETSSH_TELNETSESSIONS:
+            {
+                sprintf( cmd, "uci get telnetssh.telnet.sessions" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TELNETSSH_SSHSTATUS:
+            {
+                sprintf( cmd, "uci get telnetssh.ssh.status" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TELNETSSH_SSHPORT:
+            {
+                sprintf( cmd, "uci get telnetssh.ssh.port" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_SYSTEM_TELNETSSH_SSHSESSIONS:
+            {
+                sprintf( cmd, "uci get telnetssh.ssh.sessions" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_SystemSnmpTable() -                                                *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_SystemSnmpTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+
+    if ( header_generic ( vp, name, length, exact, var_len, write_method )
+            == MATCH_FAILED )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = systemsnmpwriteMethod;
+
+    switch ( (char) name[10] ) {
+        case KWN_SYSTEM_SNMP_STATUS:
+            {
+                sprintf( cmd, "uci get snmpd.public_access.version" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_SNMP_VERSION:
+            {
+                sprintf( cmd, "uci get snmpd.public_access.version" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_SNMP_READPWD:
+            {
+                sprintf( res_str, "******" );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_SNMP_TRAPHOSTIPADDRESS:
+            {
+                sprintf( cmd, "uci get snmpd.trapaddress.host" );
+                kwn_get_value( KWN_TYPE_IP_ADDRESS, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_ip;
+            }
+        case KWN_SYSTEM_SNMP_TRAPHOSTPASS:
+            {
+                sprintf( res_str, "******" );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_SYSTEM_SNMP_READWRITEPWD:
+            {
+                sprintf( res_str, "******" );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_WirelessStatsTable() -                                             *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_WirelessStatsTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[200];
+    int radio_ind;
+
+    radio_ind = ( int )name[12];
+    if( radio_ind < 1 || radio_ind > 2 )
+        return NULL;
+    radio_ind = radio_ind - 1;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = NULL;
+
+    /* Get Associated list */
+    get_assoclist( radio_ind );
+    switch ( (char) name[11] ) {
+        case KWN_WIRELESSSTATS_RADIO_INDEX:
+            {
+                res_val = radio_ind + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MACADDRESS:
+            {
+                sprintf( cmd, "uci get wireless.wifi%d.macaddr", radio_ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WIRELESSSTATS_REMOTEPARTNERS:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.no_of_links;
+            }
+        case KWN_WIRELESSSTATS_DATA_TXTOTALPACKETS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep tx: | sed 's/tx://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_DATA_RXTOTALPACKETS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep rx: | sed 's/rx://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_DATA_TXMULTICASTPACKETS:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep 'Multicast packets sent:' | sed 's/ Multicast packets sent:            //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_DATA_RXMULTICASTPACKETS:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep 'Multicast packets received:' | sed 's/ Multicast packets received:         //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_DATA_TXUNICASTPACKETS:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep 'Unicast packets sent:' | sed 's/ Unicast packets sent:               //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_DATA_RXUNICASTPACKETS:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep 'Unicast packets received:' | sed 's/ Unicast packets received:          //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_TXPACKETS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep ast_tx_packets: | sed 's/ast_tx_packets://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_RXPACKETS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep ast_rx_packets: | sed 's/ast_rx_packets://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_TXBEACONS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep ast_be_xmit: | sed 's/ast_be_xmit://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_RXBEACONS:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Beacons received:' | sed 's/ Beacons received:                   //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_AUTHREQSENT:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Authentication requests sent:' | sed 's/ Authentication requests sent:       //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_AUTHREQRECV:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Authentication requests received:' | sed 's/ Authentication requests received:   //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_AUTHCNF:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Authentication confirms:' | sed 's/ Authentication confirms:            //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_AUTHREJ:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Authentication rejects:' | sed 's/ Authentication rejects:             //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_DEAUTHREQSENT:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Deauthentication requests sent:' | sed 's/ Deauthentication requests sent:     //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_DEAUTHREQRECV:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Deauthentication requests received:' | sed 's/ Deauthentication requests received: //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_AUTHRESLAST:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Authentication result last:' | sed 's/ Authentication result last:         //'", radio_ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WIRELESSSTATS_MGMT_ASSOCREQSENT:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Association requests sent:' | sed 's/ Association requests sent:          //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_ASSOCREQRECV:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Association requests received:' | sed 's/ Association requests received:      //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_ASSOCCNF:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Association confirms' | sed 's/ Association confirms:               //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_ASSOCREJ:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Association rejects:' | sed 's/ Association rejects:                //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_DEASSOCREQSENT:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Disassociation requests sent:' | sed 's/ Disassociation requests sent:       //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_DEASSOCREQRECV:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Disassociation requests received:' | sed 's/ Disassociation requests received:   //'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_MGMT_ASSOCRESLAST:
+            {
+                sprintf( cmd, "80211stats -i ath%d | grep  'Association result last:' | sed 's/ Association result last:            //'", radio_ind );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_WIRELESSSTATS_MPDU_ERRORS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep mpdu_errs | sed 's/mpdu_errs://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_WIRELESSSTATS_PHY_ERRORS:
+            {
+                sprintf( cmd, "athstats -i wifi%d | grep phy_errors | sed 's/phy_errors://'", radio_ind );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_EthernetStatsTable() -                                             *
+ *                                                                          *
+ ****************************************************************************/
+    unsigned char *
+var_EthernetStatsTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+    int radio_ind;
+
+    radio_ind = ( int )name[12];
+    /* Ethernet Statistics are not handled for eth1*/
+    if( radio_ind != 1 )
+        return NULL;
+
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 1;
+    *write_method = NULL;
+
+    switch ( (char) name[11] ) {
+        case KWN_ETHSTATS_INDEX:
+            {
+                res_val = radio_ind + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ETHSTATS_STATUS:
+            {
+                sprintf( cmd, "cat /sys/class/net/eth0/operstate" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_ETHSTATS_MACADDRESS:
+            {
+                sprintf( cmd, "cat /sys/class/net/eth0/address" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_ETHSTATS_SPEED:
+            {
+                sprintf( cmd, "ethtool eth0 | grep 'Speed' | sed 's/\tSpeed: //'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return ( u_char * ) res_str;
+            }
+        case KWN_ETHSTATS_DUPLEX:
+            {
+                sprintf( cmd, "ethtool eth0 | grep 'Duplex' | sed 's/\tDuplex: //'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TXTOTALPACKETS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwn_ethtxpkt | sed 's/ath1      g_kwn_ethtxpkt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RXTOTALPACKETS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwn_ethrxpkt | sed 's/ath1      g_kwn_ethrxpkt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TXTOTALBYTES:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwn_ethtxbyt | sed 's/ath1      g_kwn_ethtxbyt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RXTOTALBYTES:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwn_ethrxbyt   | sed 's/ath1      g_kwn_ethrxbyt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TXERRORS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwn_ethtxerr | sed 's/ath1      g_kwn_ethtxerr://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RXERRORS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwn_ethrxerr | sed 's/ath1      g_kwn_ethrxerr://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_L2MCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwtxl2mdrpcnt | sed 's/ath1      g_kwtxl2mdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_L2MCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwrxl2mdrpcnt | sed 's/ath1      g_kwrxl2mdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_L3MCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwtxl3mdrpcnt | sed 's/ath1      g_kwtxl3mdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_L3MCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwrxl3mdrpcnt | sed 's/ath1      g_kwrxl3mdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_L2BCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwtxl2bdrpcnt | sed 's/ath1      g_kwtxl2bdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_L2BCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwrxl2bdrpcnt | sed 's/ath1      g_kwrxl2bdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_L3BCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwtxl3bdrpcnt | sed 's/ath1      g_kwtxl3bdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_L3BCASTDROPCNT:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwrxl3bdrpcnt | sed 's/ath1      g_kwrxl3bdrpcnt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_DROPPED:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwnethtxfail | sed 's/ath1      g_kwnethtxfail://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_DROPPED:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwnethrxfail | sed 's/ath1      g_kwnethrxfail://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_MULTICAST:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwnethtxmcpkt | sed 's/ath1      g_kwnethtxmcpkt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_MULTICAST:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwnethrxmcpkt | sed 's/ath1      g_kwnethrxmcpkt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_TX_UNICAST:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwnethtxucpkt | sed 's/ath1      g_kwnethtxucpkt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_UNICAST:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwnethrxucpkt | sed 's/ath1      g_kwnethrxucpkt://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_CRC_ERRORS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwethcrcerrs | sed 's/ath1      g_kwethcrcerrs://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_OVERSIZE_ERRORS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwethoversize | sed 's/ath1      g_kwethoversize://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        case KWN_ETHSTATS_RX_OVERRUN_ERRORS:
+            {
+                sprintf( cmd, "iwpriv ath1 g_kwethoverrun | sed 's/ath1      g_kwethoverrun://'" );
+                kwn_get_value( KWN_TYPE_DISPLAY_STRING, &cmd[0], var_len, NULL );
+                kwn_rm_str_space(var_len);
+                return (u_char *) res_str;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+/****************************************************************************
+ *                                                                          *
+ *   var_AssocTable() -                                                     *
+ *                                                                          *
+ ****************************************************************************/
+unsigned char *
+var_AssocTable ( struct variable *vp, 
+        oid     *name, 
+        size_t  *length, 
+        int     exact, 
+        size_t  *var_len, 
+        WriteMethod **write_method)
+{
+    char cmd[100];
+    int radio_ind, sec_ind;
+
+    radio_ind = ( int )name[12];
+    sec_ind = ( int )name[13];
+    memset( res_str, '\0', sizeof( res_str ) );
+    res_val = 0;
+    res_ip = 0;
+    *length = vp->namelen + 2;
+    *write_method = NULL;
+
+    radio_ind = radio_ind - 1;
+    sec_ind = sec_ind - 1;
+    /* Get Associated list */
+    if( get_assoclist( radio_ind ) < 0 ) {
+        return SNMP_ERR_NOERROR;
+    }
+    /* If no links, return error */
+    if( kwn_assoc_list.no_of_links <= 0 ) {
+        return SNMP_ERR_NOERROR;
+    }
+    /* TODO: Assoc List for second radio to be supported */
+    if( radio_ind != 1 ) {
+        return SNMP_ERR_NOERROR;
+    }
+
+    /* If req index is <1 or >no.of links, return error */
+    if( sec_ind < 0 || sec_ind >= kwn_assoc_list.no_of_links ) {
+        return SNMP_ERR_NOERROR;
+    }
+    switch ( (char) name[11] ) {
+        case KWN_ASSOC_RADIO_INDEX:
+            {
+                res_val = radio_ind + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ASSOC_SEC_INDEX:
+            {
+                res_val = sec_ind + 1;
+                *var_len = sizeof ( long );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ASSOC_MAC:
+            {
+                sprintf( res_str, "%02x:%02x:%02x:%02x:%02x:%02x",
+                        kwn_assoc_list.sta[sec_ind].mac[0],
+                        kwn_assoc_list.sta[sec_ind].mac[1],
+                        kwn_assoc_list.sta[sec_ind].mac[2],
+                        kwn_assoc_list.sta[sec_ind].mac[3],
+                        kwn_assoc_list.sta[sec_ind].mac[4],
+                        kwn_assoc_list.sta[sec_ind].mac[5] );
+                *var_len = strlen( res_str );
+                return ( u_char * ) res_str;
+            }
+        case KWN_ASSOC_IP:
+            {
+                *var_len = sizeof( in_addr_t );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].ip;
+            }
+        case KWN_ASSOC_REMOTE_LAT:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].r_latitude );
+                return ( u_char * ) kwn_assoc_list.sta[sec_ind].r_latitude;
+            }
+        case KWN_ASSOC_REMOTE_LONG:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].r_longitude );
+                return ( u_char * ) kwn_assoc_list.sta[sec_ind].r_longitude;
+            }
+        case KWN_ASSOC_LOCAL_LAT:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].l_latitude );
+                return ( u_char * ) kwn_assoc_list.sta[sec_ind].l_latitude;
+            }
+        case KWN_ASSOC_LOCAL_LONG:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].l_longitude );
+                return ( u_char * ) kwn_assoc_list.sta[sec_ind].l_longitude;
+            }
+        case KWN_ASSOC_RX_RATE:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].rx_rate;
+            }
+        case KWN_ASSOC_TX_RATE:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].tx_rate;
+            }
+        case KWN_ASSOC_RX_TPUT:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].rx_tput;
+            }
+        case KWN_ASSOC_TX_TPUT:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].tx_tput;
+            }
+        case KWN_ASSOC_LOCAL_SNR_A1:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].local_snr_a1;
+            }
+        case KWN_ASSOC_LOCAL_SNR_A2:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].local_snr_a2;
+            }
+        case KWN_ASSOC_REMOTE_SNR_A1:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].remote_snr_a1;
+            }
+        case KWN_ASSOC_REMOTE_SNR_A2:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].remote_snr_a2;
+            }
+        case KWN_ASSOC_LOCAL_PHY_ERR:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].local_phy_err;
+            }
+        case KWN_ASSOC_REMOTE_PHY_ERR:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].remote_phy_err;
+            }
+        case KWN_ASSOC_LOCAL_MPDU_ERR:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].local_mpdu_err;
+            }
+        case KWN_ASSOC_REMOTE_MPDU_ERR:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].remote_mpdu_err;
+            }
+        case KWN_ASSOC_LOCAL_RETRIES:
+            {
+                *var_len = sizeof ( long );
+                return ( u_char * ) &kwn_assoc_list.sta[sec_ind].local_retries;
+            }
+        case KWN_ASSOC_REMOTE_RETRIES:
+            {
+                *var_len = sizeof ( long );
+                return (u_char *) &kwn_assoc_list.sta[sec_ind].remote_retries;
+            }
+        case KWN_ASSOC_LINKTEST_DUR:
+            {
+                *write_method = assocwriteMethod;
+                sprintf( cmd, "uci get tool.tool.dur" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ASSOC_LINKTEST_DIR:
+            {
+                *write_method = assocwriteMethod;
+                sprintf( cmd, "uci get tool.tool.dir" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ASSOC_LINKTEST_START_STOP:
+            {
+                *write_method = assocwriteMethod;
+                sprintf( cmd, "iwpriv ath1 g_kwn_tput_test | sed 's/ath1      g_kwn_tput_test://'" );
+                kwn_get_value( KWN_TYPE_INTEGER32, &cmd[0], var_len, NULL );
+                return ( u_char * ) &res_val;
+            }
+        case KWN_ASSOC_LOCAL_NOISE_FLOOR:
+            {
+                *var_len = sizeof ( long );
+                return (u_char *) &kwn_assoc_list.sta[sec_ind].local_noise_floor;
+            }
+        case KWN_ASSOC_REMOTE_NOISE_FLOOR:
+            {
+                *var_len = sizeof ( long );
+                return (u_char *) &kwn_assoc_list.sta[sec_ind].remote_noise_floor;
+            }
+        case KWN_ASSOC_LOCAL_CUSTOMERNAME:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].l_customername );
+                return (u_char *) kwn_assoc_list.sta[sec_ind].l_customername;
+            }
+        case KWN_ASSOC_REMOTE_CUSTOMERNAME:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].r_customername );
+                return (u_char *) kwn_assoc_list.sta[sec_ind].r_customername;
+            }
+        case KWN_ASSOC_LOCAL_LINKID:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].l_linkid );
+                return (u_char *) kwn_assoc_list.sta[sec_ind].l_linkid;
+            }
+        case KWN_ASSOC_REMOTE_LINKID:
+            {
+                *var_len = strlen( kwn_assoc_list.sta[sec_ind].r_linkid );
+                return (u_char *) kwn_assoc_list.sta[sec_ind].r_linkid;
+            }
+        default:
+            ERROR_MSG ( "" );
+    }
+    return NULL;
+}
+
+int
+wlanwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    int ind, radiomode;
+    long long_val;
+    char str_val[ KWN_UCI_STR_ENUM_LEN ];
+
+    memset( cmd, '\0', sizeof(cmd) );
+    memset( res_str, '\0', sizeof(res_str) );
+    sprintf( cmd, "uci get wireless.@wifi-iface[1].mode" );
+    kwn_sys_cmd( cmd, &res_str[0] );
+    if( strcmp( res_str, "ap" ) == 0 )
+        radiomode = 1;
+    else
+        radiomode = 2;
+
+    memset( cmd, '\0', sizeof(cmd) );
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+    var_val[ var_val_len ] = '\0';
+    ind = (int) name[13];
+    if( ind < 1 || ind > 2 )
+        return NULL;
+    ind = ind - 1;
+    switch ( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ( (char) name[12] ) {
+                    case KWN_WLAN_RADIOMODE:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].mode='%s'", ind, var_val );
+                        system( cmd );
+                        /* Change in Radiomode reset channel for 5GHz radio */
+                        if( ind == 1 )
+                            kwn_radiomode_change();
+                        break;
+                    case KWN_WLAN_SSID:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].ssid='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_COUNTRY:
+                        /* Configuration of country is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.country='%d'", ind, long_val );
+                        system( cmd );
+                        kwn_reset_channel();
+                        break;
+                    case KWN_WLAN_OPMODE:
+                        sprintf( cmd, "uci set wireless.wifi%d.hwmode='%s'", ind, var_val );
+                        system( cmd );
+                        kwn_reset_tx_params();
+                        break;
+                    case KWN_WLAN_BANDWIDTH:
+                        sprintf( cmd, "uci set wireless.wifi%d.htmode='%s'", ind, var_val );
+                        system( cmd );
+                        kwn_bw_change();
+                        break;
+                    case KWN_WLAN_CHANNEL:
+                        sprintf( cmd, "uci set wireless.wifi%d.channel='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_AMSDU:
+                        /* Configuration of AMSDU is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].amsdu='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_UPLINK_LIMIT:
+                        /* Configuration of uplink limit is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].ullmt='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_DOWNLINK_LIMIT:
+                        /* Configuration of downlink limit is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].dllmt='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_HIDE_ESSID:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].hidden='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_CUSTOMER_NAME:
+                        /* Configuration of customer name is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.customername='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_LINKID:
+                        /* Configuration of link id is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.linkid='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_SECURITY_ENC:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].encryption='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_SECURITY_KEY:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].key='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_MACFILTER:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].macfilter='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_MACLIST:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].maclist='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_DISTANCE:
+                        /* Configuration of distance is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.distance='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_SHORTGI:
+                        /* Configuration of short gi is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].shortgi='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_RXCHAINMASK:
+                        /* Configuration of rx chainmask is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.rxchainmask='%d'", ind, long_val );
+                        system( cmd );
+                        break;                    
+                    case KWN_WLAN_ANTENNA_GAIN:
+                        /* Configuration of Antenna Gain is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.antennagain='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_TRAFFIC_SHAPING:
+                        /* Configuration of traffic shaping is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].shaping='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_AMPDU:
+                        /* Configuration of AMSDU is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].ampdu='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_WIRELESS_INACTIVITY_TIMER:
+                        /* Configuration of Wireless Inactivity is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.wifitimer='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_LINK_INACTIVITY_TIMER:
+                        /* Configuration of Link Inactivity is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.linktimer='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_MAXIMUM_EIRP:
+                        /* Configuration of Maximum EIRP is not supported for 2.4 Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.maxeirp='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_RATE:
+                        /* Configuration of Rate is not supported for 5GHz Radio */
+                        if( ind == 1 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.rate='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_DISABLE_LEGACY:
+                        /* Configuration of Disable Legacy is not supported for 5GHz Radio */
+                        if( ind == 1 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].dis_legacy='%s'", ind, var_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_RADIO_STATUS:
+                        sprintf( cmd, "uci set wireless.@wifi-iface[%d].disabled='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_SU_SERVICE:
+                        /* Configuration of SU Service is not supported for 2.4GHz Radio 
+                         * and 5GHz Radio operating as ap */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        if( radiomode == 1 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.suservice='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_WLAN_LINKTYPE:
+                        /* Configuration of Linktype is not supported for 2.4GHz Radio */
+                        if( ind == 0 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set wireless.wifi%d.linktype='%d'", ind, long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+linkprofilewriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    int ind1, ind2;
+    long long_val;
+    char str_val[ KWN_UCI_STR_ENUM_LEN ];
+
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+    var_val[ var_val_len ] = '\0';
+    ind1 = (int) name[13];
+    ind2 = (int) name[14];
+    /* Only second radio(5GHz) and one profile is supported */
+    if( ind1 != 2 || ind2 != 1 )
+        return NULL;
+    ind1 = ind1 - 1;
+    ind2 = ind2 - 1;
+    switch ( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ( (char) name[12] ) {
+                    case KWN_LINKPROFILE_DDRSSTATUS:
+                        {
+                            long stream = 1;
+                            if( long_val == 1 )
+                                stream = 3; /* Auto */
+                            kwn_reset_datarate( stream );
+                            sprintf( cmd, "uci set wireless.wifi%d.ddrsstatus='%d'", ind1, long_val );
+                            system( cmd );
+                        }
+                        break;
+                    case KWN_LINKPROFILE_SPATIALSTREAM:
+                        kwn_reset_datarate( long_val );
+                        sprintf( cmd, "uci set wireless.wifi%d.spatialstream='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSMINRATE:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsminrate='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSMAXRATE:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsmaxrate='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSINCTIMER:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsinctimer='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSDECTIMER:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsdectimer='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_TXRATE:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsrate='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_ATPCSTATUS:
+                        sprintf( cmd, "uci set wireless.wifi%d.atpcstatus='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_POWER:
+                        sprintf( cmd, "uci set wireless.wifi%d.atpcpower='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_TXCHAINMASK:
+                        sprintf( cmd, "uci set wireless.wifi%d.txchainmask='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSRATEINCRTHRLD:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsincthrld='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSRATEINCRTXTHRLD:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsrtxinc='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    case KWN_LINKPROFILE_DDRSRATEDECRTXTHRLD:
+                        sprintf( cmd, "uci set wireless.wifi%d.ddrsrtxdec='%d'", ind1, long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+nwkwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char ip[30];
+    long long_val;
+    int radiomode, addrtype, networkmode;
+
+    memset( cmd, '\0', sizeof(cmd) );
+    memset( res_str, '\0', sizeof(res_str) );
+    sprintf( cmd, "uci get wireless.@wifi-iface[1].mode" );
+    kwn_sys_cmd( cmd, &res_str[0] );
+    if( strcmp( res_str, "ap" ) == 0 )
+        radiomode = 1;
+    else
+        radiomode = 2;
+    
+    memset( cmd, '\0', sizeof(cmd) );
+    memset( res_str, '\0', sizeof(res_str) );
+    sprintf( cmd, "uci get network.lan.proto" );
+    kwn_sys_cmd( cmd, &res_str[0] );
+    if( strcmp( res_str, "static" ) == 0 )
+        addrtype = 1;
+    else
+        addrtype = 2;
+
+    memset( cmd, '\0', sizeof(cmd) );
+    memset( res_str, '\0', sizeof(res_str) );
+    sprintf( cmd, "uci get network.param.networkmode" );
+    kwn_sys_cmd( cmd, &res_str[0] );
+    networkmode = atoi( res_str );
+    
+    memset( cmd, '\0', sizeof(cmd) );
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch (action) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_NWK_ADRSTYPE:
+                        if( networkmode == 2 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set network.lan.proto='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_NWK_IP:
+                        if( addrtype == 2 )
+                            return SNMP_ERR_GENERR;
+                        else
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            if( networkmode == 1 )
+                            {
+                                sprintf( cmd, "uci set network.lan.ipaddr='%s'", ip );
+                            }
+                            else
+                            {
+                                sprintf( cmd, "uci set network.kweth.ipaddr='%s'", ip );
+                            }
+                        }
+                        system( cmd );
+                        break;
+                    case KWN_NWK_MASK:
+                        if( addrtype == 2 )
+                            return SNMP_ERR_GENERR;
+                        else
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            if( networkmode == 1 )
+                            {
+                                sprintf( cmd, "uci set network.lan.netmask='%s'", ip );
+                            }
+                            else
+                            {
+                                sprintf( cmd, "uci set network.kweth.netmask='%s'", ip );
+
+                            }
+                        }
+                        system( cmd );
+                        break;
+                    case KWN_NWK_GATEWAY:
+                        if( addrtype == 2 )
+                            return SNMP_ERR_GENERR;
+                        else
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            sprintf( cmd, "uci set network.lan.gateway='%s'", ip );
+                        }
+                        system( cmd );
+                        break;
+                    case KWN_NWK_DNS:
+                        sprintf( cmd, "uci set network.lan.dns='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_NWK_CLEARSTATS:
+                        if ( long_val == 1 )
+                        {
+                            system("iwpriv ath1 kwnclrethstats 1");
+                        }
+                        if ( long_val == 2 )
+                        {
+                            system("athstatsclr -i wifi1");
+                            system("80211stats -i ath1 -e 1");
+                        }
+                        if ( long_val == 3 )
+                        {
+                            system("athstatsclr -i wifi0");
+                            system("80211stats -i ath0 -e 1");
+                        }
+                        break;
+                    case KWN_NWK_NETWORKMODE:
+                        if( radiomode == 1 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set network.param.networkmode='%d'", long_val );
+                        system( cmd );
+                        kwn_reset_nwkmode_params();
+                        break;
+                    case KWN_NWK_NATSTATUS:
+                        if( networkmode == 1 )
+                            return SNMP_ERR_GENERR;
+                        sprintf( cmd, "uci set network.param.natstatus='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_NWK_WIRELESS_IP:
+                        if( networkmode == 1 )
+                            return SNMP_ERR_GENERR;
+                        kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                        sprintf( cmd, "uci set network.lan.ipaddr='%s'", ip );
+                        system( cmd );
+                        break;
+                    case KWN_NWK_WIRELESS_MASK:
+                        if( networkmode == 1 )
+                            return SNMP_ERR_GENERR;
+                        kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                        sprintf( cmd, "uci set network.lan.netmask='%s'", ip );
+                        system( cmd );
+                        break;
+                            default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string ( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string ( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+radiuswriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char ip[30];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch ( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_RADIUS_STATUS:
+                        sprintf( cmd, "uci set wrt-radauth.sys.enableRadAuth='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_PRISERVER:
+                        kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                        sprintf( cmd, "uci set wrt-radauth.sys.primaryServer='%s'", ip );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_PRIPORT:
+                        sprintf( cmd, "uci set wrt-radauth.sys.primaryPort='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_PRISECRET:
+                        sprintf( cmd, "uci set wrt-radauth.sys.primarySecret='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_SECSERVER:
+                        kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                        sprintf( cmd, "uci set wrt-radauth.sys.secondaryServer='%s'", ip );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_SECPORT:
+                        sprintf( cmd, "uci set wrt-radauth.sys.secondaryPort='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_SECSECRET:
+                        sprintf( cmd, "uci set wrt-radauth.sys.secondarySecret='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_REAUTHTIME:
+                        sprintf( cmd, "uci set wrt-radauth.sys.reauthTime='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_RETRYTIME:
+                        sprintf( cmd, "uci set wrt-radauth.sys.retryTime='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_RETRYCOUNT:
+                        sprintf( cmd, "uci set wrt-radauth.sys.requestRetries='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_RADIUS_RETRYCOUNTPERIOD:
+                        sprintf( cmd, "uci set wrt-radauth.sys.requestTimeout='%d'", long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+vlanwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch ( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_VLAN_STATUS:
+                        sprintf( cmd, "uci set vlan.vlan.status='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_MODE:
+                        sprintf( cmd, "uci set vlan.vlan.mode='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_MGMTID:
+                        sprintf( cmd, "uci set vlan.vlan.mgmtvlan='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_ACCESSID:
+                        sprintf( cmd, "uci set vlan.vlan.accessvlan='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_TRUNKOPTION:
+                        sprintf( cmd, "uci set vlan.vlan.trunkoption='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_TRUNKID:
+                        sprintf( cmd, "uci set vlan.vlan.trunkvlan='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_SVLAN:
+                        sprintf( cmd, "uci set vlan.vlan.svlan='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_SVLAN_ETHERTYPE:
+                        sprintf( cmd, "uci set vlan.vlan.svlanethertype='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_BDA:
+                        sprintf( cmd, "uci set vlan.vlan.bda='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_BSA:
+                        sprintf( cmd, "uci set vlan.vlan.bsa='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_BVID:
+                        sprintf( cmd, "uci set vlan.vlan.bvid='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_BISID:
+                        sprintf( cmd, "uci set vlan.vlan.bisid='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_VLAN_ALLOW_TAG_MGMT:
+                        sprintf( cmd, "uci set vlan.vlan.tagmgmt='%d'", long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+ethernetwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch ( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_ETHERNET_MODE:
+                        sprintf( cmd, "uci set ethernet.ethernet.mode='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_ETHERNET_INACTIVITY:
+                        sprintf( cmd, "uci set ethernet.ethernet.ethtimer='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_ETHERNET_MTU:
+                        sprintf( cmd, "uci set network.lan.mtu='%d'", long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+dhcpwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char ip[30];
+    int val;
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_DHCP_SERVER:
+                        sprintf( cmd, "uci set dhcp.lan.ignore='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_DHCP_START_IP:
+                        kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                        sprintf( cmd, "uci set dhcp.lan.start='%s'", ip );
+                        system( cmd );
+                        break;
+                    case KWN_DHCP_END_IP:
+                        kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                        sprintf( cmd, "uci set dhcp.lan.limit='%s'", ip );
+                        system( cmd );
+                        break;
+                    case KWN_DHCP_LEASE_TIME:
+                        sprintf( cmd, "uci set dhcp.lan.leasetime='%d'", long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+filterwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    int val;
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_FILTER_STATUS:
+                        sprintf( cmd, "uci set filter.filter.status='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_FILTER_L2MCAST:
+                        sprintf( cmd, "uci set filter.filter.l2mcast='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_FILTER_L3MCAST:
+                        sprintf( cmd, "uci set filter.filter.l3mcast='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_FILTER_L2BCAST:
+                        sprintf( cmd, "uci set filter.filter.l2bcast='%d'", long_val );
+                        system( cmd );
+                        break;
+                    case KWN_FILTER_L3BCAST:
+                        sprintf( cmd, "uci set filter.filter.l3bcast='%d'", long_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemmgmtwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    int val;
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_MGMT_APPLY:
+                        if( long_val == 1 ) {
+                            system( "uci commit" );
+                            system( "reload_config" );
+                        }
+                        break;
+                    case KWN_SYSTEM_MGMT_RESET:
+                        if( long_val == 1 ) {
+                            system( "sh /usr/sbin/retainip.sh" );
+                        }
+                        break;
+                    case KWN_SYSTEM_MGMT_REBOOT:
+                        if( long_val == 1 ) {
+                            system( "reboot" );
+                        }
+                        break;
+                    case KWN_SYSTEM_MGMT_DYNAMIC_APPLY:
+                        /* Updating Rate dynamically for 5GHz Radio */
+                        if( long_val == 1 ) {
+                            system("/usr/sbin/rate.sh");
+                        }
+                        break;
+                    case KWN_SYSTEM_MGMT_RESET_RETAINIP:
+                        {
+                            sprintf( cmd, "uci set tftp.retip.retainip='%d'", long_val );
+                            system( cmd );
+                            system( "sh /usr/sbin/retainip.sh" );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systeminfowriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    int val;
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_INFO_NAME:
+                        sprintf( cmd, "uci set system.@system[0].hostname='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_SYSTEM_INFO_LOCATION:
+                        sprintf( cmd, "uci set system.@system[0].location='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_SYSTEM_INFO_CONTACT:
+                        sprintf( cmd, "uci set system.@system[0].contact='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_SYSTEM_INFO_EMAIL:
+                        sprintf( cmd, "uci set system.@system[0].email='%s'", var_val );
+                        system( cmd );
+                        break;
+                    case KWN_SYSTEM_INFO_BASESTATIONID:
+                        sprintf( cmd, "uci set system.@system[0].bstid='%s'", var_val );
+                        system( cmd );
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemtftpwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char cmd1[100];
+    char ip[30];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_TFTP_FILENAME:
+                        {
+                            sprintf( cmd, "uci set tftp.tftp.filename='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TFTP_FILETYPE:
+                        {
+                            sprintf( cmd, "uci set tftp.tftp.filetype='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TFTP_SERVERIP:
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            sprintf( cmd, "uci set tftp.tftp.serverip='%s'", ip );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TFTP_KEEPSET:
+                        {
+                            sprintf( cmd, "uci set tftp.tftp.keepset='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TFTP_OPTYPE:
+                        {
+                            sprintf( cmd, "uci set tftp.tftp.optype='%d'", long_val );
+                            system( cmd );
+                            sprintf(cmd1,"/usr/sbin/kwn_tftp");
+                            system(cmd1);
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemntpwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char ip[30];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_NTP_STATUS:
+                        {
+                            sprintf( cmd, "uci set system.ntp.enabled='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_NTP_SERVERIP:
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            sprintf( cmd, "uci set system.ntp.server='%s'", ip );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_NTP_TIMEZONE:
+                        {
+                            sprintf( cmd, "uci set system.@system[0].timezone='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemgpswriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_GPSSTATUS:
+                        {
+                            sprintf( cmd, "uci set system.gps.status='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_GPSINTERVAL:
+                        {
+                            sprintf( cmd, "uci set system.gps.interval='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemdyinggaspwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_DYINGGASPSTATUS:
+                        {
+                            sprintf( cmd, "uci set wireless.@wifi-iface[1].dyinggasp='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_DYINGGASPACK:
+                        {
+                            sprintf( cmd, "uci set wireless.@wifi-iface[1].dgackdisable='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemledswriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_LEDSSTATUS:
+                        {
+                            sprintf( cmd, "uci set system.led.status='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemlogwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char ip[30];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_SYSLOGSERVERIP:
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            sprintf( cmd, "uci set system.@system[0].log_ip='%s'", ip );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_SYSLOGSERVERPORT:
+                        {
+                            sprintf( cmd, "uci set system.@system[0].log_port='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TEMPLOGSTATUS:
+                        {
+                            sprintf( cmd, "uci set system.@system[0].templogstatus='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TEMPLOGINTERVAL:
+                        {
+                            sprintf( cmd, "uci set system.@system[0].temploginterval='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemhttpwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_HTTP_ADMINPASS:
+                        {
+                            system("uci set uhttpd.main.pwdmodified='1'");
+                            sprintf( cmd, "uci set uhttpd.main.adminpwd='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_HTTP_USERPASS:
+                        {
+                            system("uci set uhttpd.main.pwdmodified='1'");
+                            sprintf( cmd, "uci set uhttpd.main.userpwd='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_HTTP_SUPERUSERPASS:
+                        {
+                            system("uci set uhttpd.main.pwdmodified='1'");
+                            sprintf( cmd, "uci set uhttpd.main.superpwd='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_HTTP_HTTPSTATUS:
+                        {
+                            if( long_val == 0 ) {
+                                sprintf( cmd, "uci delete uhttpd.main.listen_http");
+                            }
+                            else {
+                                sprintf( cmd, "uci set uhttpd.main.listen_http='0.0.0.0:80'");
+                            }
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_HTTP_HTTPPORT:
+                        {
+                            sprintf( cmd, "uci set uhttpd.main.listen_http='0.0.0.0:%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_HTTP_HTTPSSTATUS:
+                        {
+                            if( long_val == 0 ) {
+                                sprintf( cmd, "uci delete uhttpd.main.listen_https");
+                            }
+                            else {
+                                sprintf( cmd, "uci set uhttpd.main.listen_https='0.0.0.0:443'");
+                            }
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_HTTP_HTTPSPORT:
+                        {
+                            sprintf( cmd, "uci set uhttpd.main.listen_https='0.0.0.0:%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemtelnetsshwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_TELNETSSH_TELNETSTATUS:
+                        {
+                            sprintf( cmd, "uci set telnetssh.telnet.status='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TELNETSSH_TELNETPORT:
+                        {
+                            sprintf( cmd, "uci set telnetssh.telnet.port='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TELNETSSH_TELNETSESSIONS:
+                        {
+                            sprintf( cmd, "uci set telnetssh.telnet.sessions='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TELNETSSH_SSHSTATUS:
+                        {
+                            sprintf( cmd, "uci set telnetssh.ssh.status='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TELNETSSH_SSHPORT:
+                        {
+                            sprintf( cmd, "uci set telnetssh.ssh.port='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_TELNETSSH_SSHSESSIONS:
+                        {
+                            sprintf( cmd, "uci set telnetssh.ssh.sessions='%d'", long_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+
+int
+systemsnmpwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    char ip[30];
+    long long_val;
+    
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+
+    var_val[var_val_len] = '\0';
+    switch( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch( (char) name[10] ) {
+                    case KWN_SYSTEM_SNMP_STATUS:
+                        {
+                            sprintf( cmd, "uci set snmpd.public_access.version='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_SNMP_VERSION:
+                        {
+                            sprintf( cmd, "uci set snmpd.public_access.version='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_SNMP_READPWD:
+                        {
+                            sprintf( cmd, "uci set snmpd.public.community='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_SNMP_TRAPHOSTIPADDRESS:
+                        {
+                            kwn_conv_uint32_to_ip( var_val, var_val_len, &ip[0] );
+                            sprintf( cmd, "uci set snmpd.trapaddress.host='%s'", ip );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_SNMP_TRAPHOSTPASS:
+                        {
+                            sprintf( cmd, "uci set snmpd.trapaddress.paswd='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    case KWN_SYSTEM_SNMP_READWRITEPWD:
+                        {
+                            sprintf( cmd, "uci set snmpd.private.community='%s'", var_val );
+                            system( cmd );
+                            break;
+                        }
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
+int
+assocwriteMethod( int action,
+        u_char * var_val,
+        u_char var_val_type,
+        size_t var_val_len,
+        u_char * statP, oid * name, size_t name_len )
+{
+    char cmd[100];
+    int radio_ind, sec_ind;
+    long long_val;
+    
+    radio_ind = ( int )name[12];
+    sec_ind = ( int )name[13];
+    radio_ind = radio_ind - 1;
+    sec_ind = sec_ind - 1;
+    if ( var_val_type == ASN_INTEGER ) {
+        long_val = *( (long *) var_val );
+    }
+    var_val[ var_val_len ] = '\0';
+    if( radio_ind != 1 )
+        return NULL;
+    /* Get Associated list */
+    if( get_assoclist( radio_ind ) < 0 ) {
+        return SNMP_ERR_NOERROR;
+    }
+    if( sec_ind >= kwn_assoc_list.no_of_links ) {
+        return SNMP_ERR_NOERROR;
+    }
+    switch ( action ) {
+        case RESERVE1:             /* Check values for acceptability */
+            break;
+        case RESERVE2:             /* Allocate memory and similar resources */
+            break;
+        case ACTION:               /* Perform the SET action (if reversible) */
+            {
+                switch ( (char) name[11] ) {
+                    case KWN_ASSOC_LINKTEST_DUR:
+                        sprintf( cmd, "uci set tool.tool.dur='%d'",long_val );
+                        system( cmd );
+                        break;
+                    case KWN_ASSOC_LINKTEST_DIR:
+                        sprintf( cmd, "uci set tool.tool.dir='%d'",long_val );
+                        system( cmd );
+                        break;
+                    case KWN_ASSOC_LINKTEST_START_STOP:
+                        if( long_val == 1 ) {
+                            char mac[100];
+                            sprintf( mac, "%02x:%02x:%02x:%02x:%02x:%02x",
+                                    kwn_assoc_list.sta[sec_ind].mac[0], kwn_assoc_list.sta[sec_ind].mac[1], 
+                                    kwn_assoc_list.sta[sec_ind].mac[2], kwn_assoc_list.sta[sec_ind].mac[3],
+                                    kwn_assoc_list.sta[sec_ind].mac[4], kwn_assoc_list.sta[sec_ind].mac[5] );
+                            sprintf( cmd, "uci set tool.tool.cnt='1'" );
+                            system( cmd );
+                            sprintf( cmd, "uci set tool.tool.mac='%s'", mac);
+                            system( cmd );
+                            sprintf( cmd, "/etc/init.d/KWtool start" );
+                            system( cmd );
+                            sprintf( cmd, "iwpriv ath1 kwn_tput_test 1" );
+                            system( cmd );
+                        }
+                        else {
+                            sprintf( cmd, "iwpriv ath1 kwn_tput_test 0");
+                            system( cmd );
+                        }
+                        break;
+                    default:
+                        return SNMP_ERR_GENERR;
+                }
+            }
+            break;
+        case UNDO:                 /* Reverse the SET action and free resources */
+            break;
+        case COMMIT:
+            snmp_save_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            (void) snmp_call_callbacks( SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL );
+            snmp_clean_persistent( netsnmp_ds_get_string( NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE ) );
+            break;
+        case FREE:                 /* Free any resources allocated */
+            break;
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -urN net-snmp-5.4.4-org/agent/mibgroup/kwnmib.h net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.h
--- net-snmp-5.4.4-org/agent/mibgroup/kwnmib.h	1970-01-01 05:30:00.000000000 +0530
+++ net-snmp-5.4.4-mod/agent/mibgroup/kwnmib.h	2019-02-06 20:02:18.071632131 +0530
@@ -0,0 +1,529 @@
+/****************************************************************************
+*                                                                           *
+*  File Name:           kwnmib.h                                      *
+*  Used By:                                                                 *
+*                                                                           *
+*  Operating System:                                                        *
+*  Purpose:                                                                 *
+*                                                                           *
+*  Comments:                                                                *
+*                                                                           *
+*  Author:              Srilatha                                            *
+*                                                                           *
+*                                                                           *
+****************************************************************************/
+#ifndef _MIBGROUP_KWNMIB_H
+#define _MIBGROUP_KWNMIB_H
+
+/****************************************************************************
+*                               Includes                                    *
+****************************************************************************/
+
+config_require(util_funcs)
+
+/* Macros */
+#define KWN_PRIVATE_MIB_OID              52619
+#define KWN_UCI_CMD_OUTPUT_LEN_MAX       255 * 15
+#define KWN_MAC_ADDR_LEN                 6
+#define KWN_GPS_LEN                      16
+#define KWN_CUSTNAME_LEN                 33
+#define KWN_LINKID_LEN                   16
+#define KWN_LINKS_MAX                    20
+#define KWN_UCI_STR_ENUM_LEN             10
+
+/* Function Prototypes */
+
+void   init_kwnmib ( void );
+FindVarMethod var_WlanTable;
+FindVarMethod var_LinkProfileTable;
+FindVarMethod var_NwkIPTable;
+FindVarMethod var_RadiusTable;
+FindVarMethod var_VlanTable;
+FindVarMethod var_EthernetTable;
+FindVarMethod var_DhcpTable;
+FindVarMethod var_FilterTable;
+FindVarMethod var_SystemMgmtTable;
+FindVarMethod var_SystemInfoTable;
+FindVarMethod var_SystemInvTable;
+FindVarMethod var_SystemTftpTable;
+FindVarMethod var_SystemNtpTable;
+FindVarMethod var_SystemGpsTable;
+FindVarMethod var_SystemDyingGaspTable;
+FindVarMethod var_SystemLedsTable;
+FindVarMethod var_SystemLoggingTable;
+FindVarMethod var_SystemHttpTable;
+FindVarMethod var_SystemTelnetSSHTable;
+FindVarMethod var_SystemSnmpTable;
+FindVarMethod var_WirelessStatsTable;
+FindVarMethod var_EthernetStatsTable;
+FindVarMethod var_AssocTable;
+
+/* Enum Types */
+enum KWN_TYPE {
+    KWN_TYPE_INTEGER32 = 1,
+    KWN_TYPE_DISPLAY_STRING = 2,
+    KWN_TYPE_IP_ADDRESS = 3
+};
+
+enum KWN_MIB {
+    KWN_SMAC = 1
+};
+
+enum KWN_SMAC {
+    KWN_CONFIGURATION = 1,
+    KWN_MANAGEMENT = 2,
+    KWN_MONITOR = 3
+};
+
+enum KWN_CONFIGURATION {
+    KWN_WIRELESS = 1,
+    KWN_NETWORK = 2,
+    KWN_RADIUS = 3,
+    KWN_VLAN = 4,
+    KWN_ETHERNET = 5,
+    KWN_DHCP = 6,
+    KWN_FILTER = 7
+};
+
+enum KWN_WIRELESS {
+    KWN_WLANTABLE = 1,
+    KWN_LINKPROFILETABLE = 2
+};
+
+enum KWN_WLANTABLE {
+    KWN_WLANENTRY = 1
+};
+
+enum KWN_WLANENTRY {
+    KWN_WLAN_INDEX = 1,
+    KWN_WLAN_RADIOMODE = 2,
+    KWN_WLAN_SSID = 3,
+    KWN_WLAN_COUNTRY = 4,
+    KWN_WLAN_OPMODE = 5,
+    KWN_WLAN_SUPPORTED_BANDWIDTHS = 6,
+    KWN_WLAN_BANDWIDTH            = 7,
+    KWN_WLAN_SUPPORTED_CHANNELS = 8,
+    KWN_WLAN_CHANNEL = 9,
+    KWN_WLAN_AMSDU = 10,
+    KWN_WLAN_UPLINK_LIMIT = 11,
+    KWN_WLAN_DOWNLINK_LIMIT = 12,
+    KWN_WLAN_HIDE_ESSID = 13,
+    KWN_WLAN_CUSTOMER_NAME = 14,
+    KWN_WLAN_LINKID = 15,
+    KWN_WLAN_SECURITY_ENC = 16,
+    KWN_WLAN_SECURITY_KEY = 17,
+    KWN_WLAN_MACFILTER = 18,
+    KWN_WLAN_MACLIST = 19,
+    KWN_WLAN_DISTANCE = 20,
+    KWN_WLAN_SHORTGI = 21,
+    KWN_WLAN_RXCHAINMASK = 22,
+    KWN_WLAN_ACTIVE_CHANNEL = 23,
+    KWN_WLAN_ANTENNA_GAIN = 24,
+    KWN_WLAN_ACTIVE_FREQUENCY = 25,
+    KWN_WLAN_TRAFFIC_SHAPING = 26,
+    KWN_WLAN_AMPDU = 27,
+    KWN_WLAN_WIRELESS_INACTIVITY_TIMER = 28,
+    KWN_WLAN_LINK_INACTIVITY_TIMER = 29,
+    KWN_WLAN_MAXIMUM_EIRP = 30,
+    KWN_WLAN_RATE = 31,
+    KWN_WLAN_DISABLE_LEGACY = 32,
+    KWN_WLAN_RADIO_STATUS = 33,
+    KWN_WLAN_SU_SERVICE = 34,
+    KWN_WLAN_LINKTYPE = 35
+};
+
+enum KWN_LINKPROFILETABLE {
+    KWN_LINKPROFILEENTRY = 1
+};
+
+enum KWN_LINKPROFILEENTRY {
+    KWN_LINKPROFILE_INDEX = 1,
+    KWN_LINKPROFILE_SECINDEX = 2,
+    KWN_LINKPROFILE_DDRSSTATUS = 3,
+    KWN_LINKPROFILE_SPATIALSTREAM = 4,
+    KWN_LINKPROFILE_DDRSMINRATE = 5,
+    KWN_LINKPROFILE_DDRSMAXRATE = 6,
+    KWN_LINKPROFILE_DDRSINCTIMER = 7,
+    KWN_LINKPROFILE_DDRSDECTIMER    = 8,
+    KWN_LINKPROFILE_TXRATE = 9,
+    KWN_LINKPROFILE_SUPPORTEDRATES = 10,
+    KWN_LINKPROFILE_ATPCSTATUS = 11,
+    KWN_LINKPROFILE_POWER = 12,
+    KWN_LINKPROFILE_TXCHAINMASK = 13,
+    KWN_LINKPROFILE_DDRSRATEINCRTHRLD = 14,
+    KWN_LINKPROFILE_DDRSRATEINCRTXTHRLD = 15,
+    KWN_LINKPROFILE_DDRSRATEDECRTXTHRLD = 16
+};
+
+enum KWN_NETWORK {
+    KWN_NWK_ADRSTYPE = 1,
+    KWN_NWK_IP = 2,
+    KWN_NWK_MASK = 3,
+    KWN_NWK_GATEWAY = 4,
+    KWN_NWK_DNS = 5,
+    KWN_NWK_CLEARSTATS = 6,
+    KWN_NWK_NETWORKMODE = 7,
+    KWN_NWK_NATSTATUS = 8,
+    KWN_NWK_WIRELESS_IP = 9,
+    KWN_NWK_WIRELESS_MASK = 10
+};
+
+enum KWN_RADIUS {
+    KWN_RADIUS_STATUS = 1,
+    KWN_RADIUS_PRISERVER = 2,
+    KWN_RADIUS_PRIPORT = 3,
+    KWN_RADIUS_PRISECRET = 4,
+    KWN_RADIUS_SECSERVER = 5,
+    KWN_RADIUS_SECPORT = 6,
+    KWN_RADIUS_SECSECRET = 7,
+    KWN_RADIUS_REAUTHTIME = 8,
+    KWN_RADIUS_RETRYTIME = 9,
+    KWN_RADIUS_RETRYCOUNT = 10,
+    KWN_RADIUS_RETRYCOUNTPERIOD = 11
+};
+
+enum KWN_VLAN {
+    KWN_VLAN_STATUS = 1,
+    KWN_VLAN_MODE = 2,
+    KWN_VLAN_MGMTID = 3,
+    KWN_VLAN_ACCESSID = 4,
+    KWN_VLAN_TRUNKOPTION = 5,
+    KWN_VLAN_TRUNKID = 6,
+    KWN_VLAN_SVLAN = 7,
+    KWN_VLAN_SVLAN_ETHERTYPE = 8,
+    KWN_VLAN_BDA = 9,
+    KWN_VLAN_BSA = 10,
+    KWN_VLAN_BVID = 11,
+    KWN_VLAN_BISID = 12,
+    KWN_VLAN_ALLOW_TAG_MGMT = 13
+};
+
+enum KWN_ETHERNET {
+    KWN_ETHERNET_MODE = 1,
+    KWN_ETHERNET_INACTIVITY = 2,
+    KWN_ETHERNET_MTU = 3,
+    KWN_ETHERNET_CABLE_LENGTH = 4
+};
+
+enum KWN_DHCP {
+    KWN_DHCP_SERVER = 1,
+    KWN_DHCP_START_IP = 2,
+    KWN_DHCP_END_IP = 3,
+    KWN_DHCP_LEASE_TIME = 4
+};
+
+enum KWN_FILTER {
+    KWN_FILTER_STATUS = 1,
+    KWN_FILTER_L2MCAST = 2,
+    KWN_FILTER_L3MCAST = 3,
+    KWN_FILTER_L2BCAST = 4,
+    KWN_FILTER_L3BCAST = 5
+};
+
+enum KWN_MANAGEMENT {
+    KWN_SYSTEM_MGMT = 1,
+    KWN_SYSTEM_INFO = 2,
+    KWN_SYSTEM_INV = 3,
+    KWN_TRAP_CTRL = 4,
+    KWN_SYSTEM_TFTP = 5,
+    KWN_SYSTEM_NTP = 6,
+    KWN_SYSTEM_GPS = 7,
+    KWN_SYSTEM_DYING_GASP = 8,
+    KWN_SYSTEM_LEDS = 9,
+    KWN_SYSTEM_LOG = 10,
+    KWN_SYSTEM_HTTP = 11,
+    KWN_SYSTEM_TELNETSSH = 12,
+    KWN_SYSTEM_SNMP = 13
+};
+
+enum KWN_SYSTEM_MGMT {
+    KWN_SYSTEM_MGMT_APPLY = 1,
+    KWN_SYSTEM_MGMT_RESET = 2,
+    KWN_SYSTEM_MGMT_REBOOT = 3,
+    KWN_SYSTEM_MGMT_DYNAMIC_APPLY = 4,
+    KWN_SYSTEM_MGMT_RESET_RETAINIP = 5
+};
+
+enum KWN_SYSTEM_INFO {
+    KWN_SYSTEM_INFO_NAME = 1,
+    KWN_SYSTEM_INFO_LOCATION = 2,
+    KWN_SYSTEM_INFO_CONTACT = 3,
+    KWN_SYSTEM_INFO_DESCRIPTION = 4,
+    KWN_SYSTEM_INFO_GEO_LATITUDE = 5,
+    KWN_SYSTEM_INFO_GEO_LONGITUDE = 6,
+    KWN_SYSTEM_INFO_TEMPERATURE = 7,
+    KWN_SYSTEM_INFO_EMAIL = 8,
+    KWN_SYSTEM_INFO_BASESTATIONID = 9
+};
+
+enum KWN_SYSTEM_INV {
+    KWN_SYSTEM_INV_SERIALNO = 1,
+    KWN_SYSTEM_INV_MODEL = 2,
+    KWN_SYSTEM_INV_RELNUM = 3,
+    KWN_SYSTEM_INV_MAJNUM = 4,
+    KWN_SYSTEM_INV_MINNUM = 5,
+    KWN_SYSTEM_INV_PRODUCTID = 6,
+    KWN_SYSTEM_INV_BUILDNO = 7,
+    KWN_SYSTEM_INV_MAXSU = 8,
+    KWN_SYSTEM_INV_HARDWAREVERSION = 9,
+    KWN_SYSTEM_INV_ANTENNAGAIN1 = 10,
+    KWN_SYSTEM_INV_ANTENNAGAIN2 = 11,
+    KWN_SYSTEM_INV_ANTENNATYPE1 = 12,
+    KWN_SYSTEM_INV_ANTENNATYPE2 = 13
+};
+
+enum KWN_TRAP_CTRL {
+    KWN_GENERIC_TRAP = 1
+};
+
+enum KWN_SYSTEM_TFTP {
+    KWN_SYSTEM_TFTP_FILENAME = 1,
+    KWN_SYSTEM_TFTP_FILETYPE = 2,
+    KWN_SYSTEM_TFTP_SERVERIP = 3,
+    KWN_SYSTEM_TFTP_OPSTATUS = 4,
+    KWN_SYSTEM_TFTP_OPTYPE = 5,
+    KWN_SYSTEM_TFTP_KEEPSET = 6
+};
+
+enum KWN_SYSTEM_NTP {
+    KWN_SYSTEM_NTP_STATUS = 1,
+    KWN_SYSTEM_NTP_SERVERIP = 2,
+    KWN_SYSTEM_NTP_TIMEZONE = 3,
+    KWN_SYSTEM_NTP_LOCALTIME = 4
+};
+
+enum KWN_SYSTEM_GPS {
+    KWN_SYSTEM_GPSSTATUS = 1,
+    KWN_SYSTEM_GPSINTERVAL = 2
+};
+
+enum KWN_SYSTEM_DYING_GASP {
+    KWN_SYSTEM_DYINGGASPSTATUS = 1,
+    KWN_SYSTEM_DYINGGASPACK = 2
+};
+
+enum KWN_SYSTEM_LEDS {
+    KWN_SYSTEM_LEDSSTATUS = 1
+};
+
+enum KWN_SYSTEM_LOG {
+    KWN_SYSTEM_SYSLOGSERVERIP = 1,
+    KWN_SYSTEM_SYSLOGSERVERPORT = 2,
+    KWN_SYSTEM_TEMPLOGSTATUS = 3,
+    KWN_SYSTEM_TEMPLOGINTERVAL = 4
+};
+
+enum KWN_SYSTEM_HTTP {
+    KWN_SYSTEM_HTTP_ADMINPASS = 1,
+    KWN_SYSTEM_HTTP_USERPASS = 2,
+    KWN_SYSTEM_HTTP_SUPERUSERPASS = 3,
+    KWN_SYSTEM_HTTP_HTTPSTATUS = 4,
+    KWN_SYSTEM_HTTP_HTTPPORT = 5,
+    KWN_SYSTEM_HTTP_HTTPSSTATUS = 6,
+    KWN_SYSTEM_HTTP_HTTPSPORT = 7
+};
+
+enum KWN_SYSTEM_TELNETSSH {
+    KWN_SYSTEM_TELNETSSH_TELNETSTATUS = 1,
+    KWN_SYSTEM_TELNETSSH_TELNETPORT = 2,
+    KWN_SYSTEM_TELNETSSH_TELNETSESSIONS = 3,
+    KWN_SYSTEM_TELNETSSH_SSHSTATUS = 4,
+    KWN_SYSTEM_TELNETSSH_SSHPORT = 5,
+    KWN_SYSTEM_TELNETSSH_SSHSESSIONS = 6
+};
+
+enum KWN_SYSTEM_SNMP {
+    KWN_SYSTEM_SNMP_STATUS = 1,
+    KWN_SYSTEM_SNMP_VERSION = 2,
+    KWN_SYSTEM_SNMP_READPWD = 3,
+    KWN_SYSTEM_SNMP_TRAPHOSTIPADDRESS = 4,
+    KWN_SYSTEM_SNMP_TRAPHOSTPASS = 5,
+    KWN_SYSTEM_SNMP_READWRITEPWD = 6
+};
+
+enum KWN_MONITOR {
+    KWN_WIRELESSSTATS = 1,
+    KWN_ETHERNETSTATS = 2,
+    KWN_ASSOCLIST = 3,
+    KWN_TRAPS = 4
+};
+
+enum KWN_WIRELESSSTATS {
+    KWN_WIRELESSSTATSENTRY = 1
+};
+
+enum KWN_WIRELESSSTATSENTRY {
+    KWN_WIRELESSSTATS_RADIO_INDEX = 1,
+    KWN_WIRELESSSTATS_MACADDRESS = 2,
+    KWN_WIRELESSSTATS_REMOTEPARTNERS = 3,
+    KWN_WIRELESSSTATS_DATA_TXTOTALPACKETS = 4,
+    KWN_WIRELESSSTATS_DATA_RXTOTALPACKETS = 5,
+    KWN_WIRELESSSTATS_DATA_TXMULTICASTPACKETS = 6,
+    KWN_WIRELESSSTATS_DATA_RXMULTICASTPACKETS = 7,
+    KWN_WIRELESSSTATS_DATA_TXUNICASTPACKETS = 8,
+    KWN_WIRELESSSTATS_DATA_RXUNICASTPACKETS = 9,
+    KWN_WIRELESSSTATS_MGMT_TXPACKETS = 10,
+    KWN_WIRELESSSTATS_MGMT_RXPACKETS = 11,
+    KWN_WIRELESSSTATS_MGMT_TXBEACONS = 12,
+    KWN_WIRELESSSTATS_MGMT_RXBEACONS = 13,
+    KWN_WIRELESSSTATS_MGMT_AUTHREQSENT = 14,
+    KWN_WIRELESSSTATS_MGMT_AUTHREQRECV = 15,
+    KWN_WIRELESSSTATS_MGMT_AUTHCNF = 16,
+    KWN_WIRELESSSTATS_MGMT_AUTHREJ = 17,
+    KWN_WIRELESSSTATS_MGMT_DEAUTHREQSENT = 18,
+    KWN_WIRELESSSTATS_MGMT_DEAUTHREQRECV = 19,
+    KWN_WIRELESSSTATS_MGMT_AUTHRESLAST = 20,
+    KWN_WIRELESSSTATS_MGMT_ASSOCREQSENT = 21,
+    KWN_WIRELESSSTATS_MGMT_ASSOCREQRECV = 22,
+    KWN_WIRELESSSTATS_MGMT_ASSOCCNF = 23,
+    KWN_WIRELESSSTATS_MGMT_ASSOCREJ = 24,
+    KWN_WIRELESSSTATS_MGMT_DEASSOCREQSENT = 25,
+    KWN_WIRELESSSTATS_MGMT_DEASSOCREQRECV = 26,
+    KWN_WIRELESSSTATS_MGMT_ASSOCRESLAST = 27,
+    KWN_WIRELESSSTATS_MPDU_ERRORS = 28,
+    KWN_WIRELESSSTATS_PHY_ERRORS = 29
+};
+
+enum KWN_ETHERNETSTATS {
+    KWN_ETHERNETSTATSENTRY = 1
+};
+
+enum KWN_ETHERNETSTATSENTRY {
+    KWN_ETHSTATS_INDEX = 1,
+    KWN_ETHSTATS_STATUS = 2,
+    KWN_ETHSTATS_MACADDRESS = 3,
+    KWN_ETHSTATS_SPEED = 4,
+    KWN_ETHSTATS_DUPLEX = 5,
+    KWN_ETHSTATS_TXTOTALPACKETS = 6,
+    KWN_ETHSTATS_RXTOTALPACKETS = 7,
+    KWN_ETHSTATS_TXTOTALBYTES = 8,
+    KWN_ETHSTATS_RXTOTALBYTES = 9,
+    KWN_ETHSTATS_TXERRORS = 10,
+    KWN_ETHSTATS_RXERRORS = 11,
+    KWN_ETHSTATS_TX_L2MCASTDROPCNT = 12,
+    KWN_ETHSTATS_RX_L2MCASTDROPCNT = 13,
+    KWN_ETHSTATS_TX_L3MCASTDROPCNT = 14,
+    KWN_ETHSTATS_RX_L3MCASTDROPCNT = 15,
+    KWN_ETHSTATS_TX_L2BCASTDROPCNT = 16,
+    KWN_ETHSTATS_RX_L2BCASTDROPCNT = 17,
+    KWN_ETHSTATS_TX_L3BCASTDROPCNT = 18,
+    KWN_ETHSTATS_RX_L3BCASTDROPCNT = 19,
+    KWN_ETHSTATS_TX_DROPPED = 20,
+    KWN_ETHSTATS_RX_DROPPED = 21,
+    KWN_ETHSTATS_TX_MULTICAST = 22,
+    KWN_ETHSTATS_RX_MULTICAST = 23,
+    KWN_ETHSTATS_TX_UNICAST = 24,
+    KWN_ETHSTATS_RX_UNICAST = 25,
+    KWN_ETHSTATS_RX_CRC_ERRORS = 26,
+    KWN_ETHSTATS_RX_OVERSIZE_ERRORS = 27,
+    KWN_ETHSTATS_RX_OVERRUN_ERRORS = 28
+};
+
+enum KWN_ASSOCLIST {
+    KWN_ASSOCENTRY = 1
+};
+
+enum KWN_ASSOCENTRY {
+    KWN_ASSOC_RADIO_INDEX = 1,
+    KWN_ASSOC_SEC_INDEX = 2,
+    KWN_ASSOC_MAC = 3,
+    KWN_ASSOC_IP = 4,
+    KWN_ASSOC_REMOTE_LAT = 5,
+    KWN_ASSOC_REMOTE_LONG = 6,
+    KWN_ASSOC_LOCAL_LAT = 7,
+    KWN_ASSOC_LOCAL_LONG = 8,
+    KWN_ASSOC_RX_RATE = 9,
+    KWN_ASSOC_TX_RATE = 10,
+    KWN_ASSOC_RX_TPUT = 11,
+    KWN_ASSOC_TX_TPUT = 12,
+    KWN_ASSOC_LOCAL_SNR_A1 = 13,
+    KWN_ASSOC_LOCAL_SNR_A2 = 14,
+    KWN_ASSOC_REMOTE_SNR_A1 = 15,
+    KWN_ASSOC_REMOTE_SNR_A2 = 16,
+    KWN_ASSOC_LOCAL_PHY_ERR = 17,
+    KWN_ASSOC_REMOTE_PHY_ERR = 18,
+    KWN_ASSOC_LOCAL_MPDU_ERR = 19,
+    KWN_ASSOC_REMOTE_MPDU_ERR = 20,
+    KWN_ASSOC_LOCAL_RETRIES = 21,
+    KWN_ASSOC_REMOTE_RETRIES = 22,
+    KWN_ASSOC_LINKTEST_DUR = 23,
+    KWN_ASSOC_LINKTEST_DIR = 24,
+    KWN_ASSOC_LINKTEST_START_STOP = 25,
+    KWN_ASSOC_LOCAL_NOISE_FLOOR = 26,
+    KWN_ASSOC_REMOTE_NOISE_FLOOR = 27,
+    KWN_ASSOC_LOCAL_CUSTOMERNAME = 28,
+    KWN_ASSOC_REMOTE_CUSTOMERNAME = 29,
+    KWN_ASSOC_LOCAL_LINKID = 30,
+    KWN_ASSOC_REMOTE_LINKID = 31
+};
+
+enum KWN_TRAPS {
+    KWN_ASSOCIATED_TRAP = 1,
+    KWN_DISASSOCIATED_TRAP = 2,
+    KWN_DYINGGASP_REMOTE_DEVICE_TRAP = 3,
+    KWN_DYINGGASP_BSU_TRAP = 4,
+    KWN_SU_SERVICE = 5
+};
+
+/* Structure Definitions */
+typedef struct
+{
+    uint8_t  mac[ KWN_MAC_ADDR_LEN ];
+    uint32_t ip;
+    char  r_latitude[ KWN_GPS_LEN ];
+    char  r_longitude[ KWN_GPS_LEN ];
+    char  l_latitude[ KWN_GPS_LEN ];
+    char  l_longitude[ KWN_GPS_LEN ];
+    long tx_rate;
+    long rx_rate;
+    long tx_tput;
+    long rx_tput;
+    long local_snr_a1;
+    long local_snr_a2;
+    long remote_snr_a1;
+    long remote_snr_a2;
+    long local_phy_err;
+    long remote_phy_err;
+    long local_mpdu_err;
+    long remote_mpdu_err;
+    long local_retries;
+    long remote_retries;
+    long local_noise_floor;
+    long remote_noise_floor;
+    char l_customername[ KWN_CUSTNAME_LEN ];
+    char r_customername[ KWN_CUSTNAME_LEN ];
+    char l_linkid[ KWN_LINKID_LEN ];
+    char r_linkid[ KWN_LINKID_LEN ];
+}kwn_link_stats;
+
+typedef struct
+{
+    int no_of_links;
+    kwn_link_stats sta[ KWN_LINKS_MAX ];
+}kwn_wireless_stats;
+
+typedef struct
+{
+    long value;
+    char str[KWN_UCI_STR_ENUM_LEN];
+}kwn_array;
+
+typedef struct
+{
+    int len;
+    kwn_array array[KWN_UCI_STR_ENUM_LEN];
+}kwn_snmp_array;
+
+typedef struct 
+{
+    uint8_t channel;
+    uint32_t mhz;
+}kwn_arraylist;
+
+typedef struct
+{
+    long num_chans;
+    kwn_arraylist array[ 255 ];
+}kwn_freqlist;
+
+#endif /* _MIBGROUP_KWNMIB_H */
diff -urN net-snmp-5.4.4-org/agent/snmp_agent.c net-snmp-5.4.4-mod/agent/snmp_agent.c
--- net-snmp-5.4.4-org/agent/snmp_agent.c	2011-02-20 14:54:29.000000000 +0530
+++ net-snmp-5.4.4-mod/agent/snmp_agent.c	2018-10-02 16:53:19.741319737 +0530
@@ -116,7 +116,7 @@
 #include "smux/smux.h"
 #endif
 
-oid      version_sysoid[] = { NETSNMP_SYSTEM_MIB };
+oid      version_sysoid[] = { NETSNMP_ENTERPRISE_MIB };
 int      version_sysoid_len = OID_LENGTH(version_sysoid);
 
 #define SNMP_ADDRCACHE_SIZE 10
diff -urN net-snmp-5.4.4-org/include/net-snmp/net-snmp-config.h.in net-snmp-5.4.4-mod/include/net-snmp/net-snmp-config.h.in
--- net-snmp-5.4.4-org/include/net-snmp/net-snmp-config.h.in	2011-06-24 18:08:14.000000000 +0530
+++ net-snmp-5.4.4-mod/include/net-snmp/net-snmp-config.h.in	2018-10-02 16:52:10.453208468 +0530
@@ -1531,7 +1531,7 @@
 /* company/organization has been allocated.                     */
 /* The assigned enterprise number for the NET_SNMP MIB modules. */
 #define NETSNMP_ENTERPRISE_OID			8072
-#define NETSNMP_ENTERPRISE_MIB			1,3,6,1,4,1,8072
+#define NETSNMP_ENTERPRISE_MIB			1,3,6,1,4,1,52619
 #define NETSNMP_ENTERPRISE_DOT_MIB		1.3.6.1.4.1.8072
 #define NETSNMP_ENTERPRISE_DOT_MIB_LENGTH	7
 
diff -urN net-snmp-5.4.4-org/mibs/KEYWEST-MIB.mib net-snmp-5.4.4-mod/mibs/KEYWEST-MIB.mib
--- net-snmp-5.4.4-org/mibs/KEYWEST-MIB.mib	1970-01-01 05:30:00.000000000 +0530
+++ net-snmp-5.4.4-mod/mibs/KEYWEST-MIB.mib	2019-02-06 20:02:01.351760354 +0530
@@ -0,0 +1,3021 @@
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+--
+-- Copyright (C) 2018 by KeyWest Networks. All rights reserved
+-- Enterprise MIB definition to manage MAP100 product.
+--
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+
+KEYWEST-MIB DEFINITIONS ::= BEGIN
+
+
+IMPORTS
+    MODULE-IDENTITY, OBJECT-IDENTITY,
+    NOTIFICATION-TYPE, OBJECT-TYPE,
+    Integer32, enterprises,
+    IpAddress
+        FROM SNMPv2-SMI
+
+    DisplayString, DateAndTime,
+    RowStatus
+        FROM SNMPv2-TC;
+
+
+keywest MODULE-IDENTITY
+        LAST-UPDATED "201809030000Z"
+        ORGANIZATION "KeyWest Networks."
+        CONTACT-INFO "www.keywestnetworks.com"
+        DESCRIPTION  "KeyWest Networks private enterprise MIB definition"
+        REVISION     "201809030000Z"
+        DESCRIPTION  "First Release"
+::= { enterprises 52619 }
+
+
+objects OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION "Root Node for KeyWest Networks MAP100 product."
+::= { keywest 1 }
+
+configuration OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "Configuration"
+::= { objects 1 }
+
+management OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "Management"
+::= { objects 2 }
+
+monitor OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "Monitor"
+::= { objects 3 }
+
+products OBJECT-IDENTITY
+    STATUS      current
+    DESCRIPTION "Products of KeyWest Networks"
+::= { keywest 2 }
+
+ptp         OBJECT-IDENTITY 
+    STATUS      current
+    DESCRIPTION "Outdoor Point-to-Point Product."
+::= { products 1 }
+ptmp        OBJECT-IDENTITY 
+    STATUS      current
+    DESCRIPTION "Outdoor Point-to-MultiPoint Product."
+::= { products 2 }
+indoorap    OBJECT-IDENTITY 
+    STATUS      current
+    DESCRIPTION "Indoor Access-Point Product."
+::= { products 3 }
+outdoorap   OBJECT-IDENTITY 
+    STATUS      current
+    DESCRIPTION "Outdoor Access-Point Product."
+::= { products 4 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+wireless OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "Wireless configuration"
+::= { configuration 1 }
+
+
+wirelessTable OBJECT-TYPE
+        SYNTAX SEQUENCE OF WirelessEntry
+        MAX-ACCESS         not-accessible
+        STATUS             current
+        DESCRIPTION        "This table is used to specify Wireless
+                            Configuration."
+::= { wireless 1 }
+
+
+wirelessEntry OBJECT-TYPE
+        SYNTAX      WirelessEntry
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents an entry in the 
+                     Wireless Configuration table."
+        INDEX       { wirelessIndex }
+::= { wirelessTable 1 }
+
+
+WirelessEntry ::=
+        SEQUENCE {
+                wirelessIndex
+                    Integer32,
+                wirelessRadioMode
+                    DisplayString,
+                wirelessSSID
+                    DisplayString,
+                wirelessCountry
+                    Integer32,
+                wirelessOpmode
+                    DisplayString,
+                wirelessSupportedBandwidths
+                    DisplayString,
+                wirelessBandwidth
+                    DisplayString,
+                wirelessSupportedChannels
+                    DisplayString,
+                wirelessChannel
+                    DisplayString,
+                wirelessAMSDU
+                    Integer32,
+                wirelessUplinkLimit
+                    Integer32,
+                wirelessDownlinkLimit
+                    Integer32,
+                wirelessHideESSID
+                    INTEGER,
+                wirelessCustomerName
+                    DisplayString,
+                wirelessLinkId
+                    DisplayString,
+                wirelessSecurityEncryption
+                    DisplayString,
+                wirelessSecurityKey
+                    DisplayString,
+                wirelessMACFilter
+                    DisplayString,
+                wirelessMACList
+                    DisplayString,
+                wirelessDistance
+                    Integer32,
+                wirelessShortGI
+                    INTEGER,
+                wirelessRxChainmask
+                    Integer32,
+                wirelessActiveChannel
+                    Integer32,
+                wirelessAntennaGain
+                    Integer32,
+                wirelessActiveFrequency
+                    Integer32,
+                wirelessTrafficShaping
+                    INTEGER,
+                wirelessAMPDU
+                    Integer32,
+                wirelessInactivityTimer
+                    Integer32,
+                wirelessLinkInactivityTimer
+                    Integer32,
+                wirelessMaximumEIRP
+                    Integer32,
+                wirelessRate
+                    Integer32,
+                wirelessDisableLegacy
+                    DisplayString,
+                wirelessRadioStatus
+                    INTEGER,
+                wirelessSUService
+                    INTEGER,
+                wirelessLinktype
+                    INTEGER
+        }
+
+
+wirelessIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..2)
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents the Radio Index 
+                     for Wireless Configuration table
+                     For 2.4 GHz radio - '1'
+                     For   5 GHz radio - '2'."
+::= { wirelessEntry 1 }
+
+wirelessRadioMode OBJECT-TYPE
+        SYNTAX      DisplayString 
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents Wireless Radio Mode.
+                     It can be configured as
+                     For 2.4 GHz radio - 'ap'  - Access Point
+                                         'sta' - Client
+                     For   5 GHz radio - 'ap'  - Outdoor Base
+                                         'sta' - Outdoor Subscriber."
+::= { wirelessEntry 2 }
+
+wirelessSSID OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure SSID."
+::= { wirelessEntry 3 }
+
+wirelessCountry OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Country.
+                     It can be configured as
+                     For 2.4 GHz radio - '643'  - INDIA
+                     For   5 GHz radio - '5018' - INDIA
+                                         '5019' - 5GHz."
+::= { wirelessEntry 4 }
+
+wirelessOpmode OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Operational Mode.
+                     It can be configured as
+                     For 2.4 GHz radio - '11g'  - Legacy (11G)
+                                         '11ng' - 11NG
+                     For   5 GHz radio - '11a'  - Legacy (11A)
+                                         '11na' - 11NA
+                                         '11ac' - 11AC."
+::= { wirelessEntry 5 }
+
+wirelessSupportedBandwidths OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the supported 
+                     Bandwidths."
+::= { wirelessEntry 6 }
+
+wirelessBandwidth OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the bandwidth.
+                     It can be configured as
+                     For 2.4 GHz - 'HT20'  - 20  MHz
+                                   'HT40+' - 40  MHz
+                                   'HT40-' - 40- MHz
+                     For   5 GHz - 'HT20'  - 20  MHz
+                                   'HT40+' - 40+ MHz
+                                   'HT40-' - 40- MHz
+                                   'HT80'  - 80  MHz."
+::= { wirelessEntry 7 }
+
+wirelessSupportedChannels OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the supported 
+                     channel list."
+::= { wirelessEntry 8 }
+
+wirelessChannel OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the channel.
+                     It can be configured as 'auto' or any other
+                     channel from the supported channel list based on
+                     country selected."
+::= { wirelessEntry 9 }
+
+wirelessAMSDU OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the AMSDU.
+                     It can be configured as
+                     For 2.4 GHz - NA
+                     For   5 GHz - 1 to 4."
+::= { wirelessEntry 10 }
+
+wirelessUplinkLimit OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Uplink Limit.
+                     It can be configured as
+                     For 2.4 GHz - NA
+                     For   5 GHz - ( 1024 - 887000 ) Kbps."
+::= { wirelessEntry 11 }
+
+wirelessDownlinkLimit OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Downlink Limit.
+                     It can be configured as
+                     For 2.4 GHz - NA
+                     For   5 GHz - ( 1024 - 887000 ) Kbps."
+::= { wirelessEntry 12 }
+
+wirelessHideESSID OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the HideESSID.
+                     It can be configured as
+                     For 2.4 / 5 GHz - 0 - uncheck (disable)
+                                       1 - check   (enable)."
+::= { wirelessEntry 13 }
+
+wirelessCustomerName OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents CustomerName.
+                     It is configured only for 5 GHz radio."
+::= { wirelessEntry 14 }
+
+wirelessLinkId OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents LinkId in 1 to 15 digits.
+                     It can be configured only for 5 GHz radio
+                     in Outdoor Subscriber mode."
+::= { wirelessEntry 15 }
+
+wirelessSecurityEncryption OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Encryption
+                     type. It can be cofigured as
+                     For 2.4 / 5 GHz - 'none'      - None
+                                       'psk2+ccmp' - WPA2/PSK."
+::= { wirelessEntry 16 }
+
+wirelessSecurityKey OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Security Key."
+::= { wirelessEntry 17 }
+
+wirelessMACFilter OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the MAC Filter.
+                     It can be configured as
+                     For 2.4 / 5 GHz - 'disable' - Disable
+                                         'allow' - Allow
+                                          'deny' - Deny."
+::= { wirelessEntry 18 }
+
+wirelessMACList OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the MAC List.
+                     It can be configured as
+                     For 2.4 / 5 GHz - mac '<mac address>'."
+::= { wirelessEntry 19 }
+
+wirelessDistance OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Distance."
+::= { wirelessEntry 20 }
+
+wirelessShortGI OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the short Guard
+                     Interval.It is configured only for 5 GHz 
+                     radio as '0' - Disable
+                              '1' - Enable."
+::= { wirelessEntry 21 }
+
+wirelessRxChainmask OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the 
+                     Rx Chainmask."
+::= { wirelessEntry 22 }
+
+wirelessActiveChannel OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is used to get the current
+                     Operating channel."
+::= { wirelessEntry 23 }
+
+wirelessAntennaGain OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the 
+                     Antenna Gain."
+::= { wirelessEntry 24 }
+
+wirelessActiveFrequency OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is used to get the current
+                     Operating frequency."
+::= { wirelessEntry 25 }
+
+wirelessTrafficShaping OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter enable or disable the traffic
+                     Shaping based on configured uplink downlink limit.
+                     It is configured only for 5 GHz 
+                     radio as '0' - Disable
+                              '1' - Enable."
+::= { wirelessEntry 26 }
+
+wirelessAMPDU OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the AMPDU.
+                     It can be configured as
+                     For 2.4 GHz - NA
+                     For   5 GHz - 1 to 64."
+::= { wirelessEntry 27 }
+
+wirelessInactivityTimer OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Wireless Inactivity Timer in Minutes.
+                     For 2.4 GHz - NA"
+::= { wirelessEntry 28 }
+
+wirelessLinkInactivityTimer OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Wireless Link Inactivity Timer in Minutes.
+                     For 2.4 GHz - NA"
+::= { wirelessEntry 29 }
+
+wirelessMaximumEIRP OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Maximum EIRP in dBm.
+                     For 2.4 GHz - NA"
+::= { wirelessEntry 30 }
+
+wirelessRate OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rate.
+                     For 5 GHz - NA"
+::= { wirelessEntry 31 }
+
+wirelessDisableLegacy OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DisplayLegacy.
+                     For   5 GHz - NA
+                         2.4 GHz -     0 - disable
+                                  0x000F - enable."
+::= { wirelessEntry 32 }
+
+wirelessRadioStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (1),
+            enable  (0)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter enable or disable the radio
+                     as '1' - Disable
+                        '0' - Enable."
+::= { wirelessEntry 33 }
+
+wirelessSUService OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter enable or disable the SU Service
+                     as '0' - Disable
+                        '1' - Enable."
+::= { wirelessEntry 34 }
+
+wirelessLinktype OBJECT-TYPE
+        SYNTAX      INTEGER {
+            ptp      (1),
+            backhaul (2),
+            ptmp     (3)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Linktype.
+                     It can be configured as
+                     '1' - PTP
+                     '2' - Backhaul
+                     '3' - PTMP."
+::= { wirelessEntry 35 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+linkProfileTable OBJECT-TYPE
+        SYNTAX SEQUENCE OF LinkProfileEntry
+        MAX-ACCESS         not-accessible
+        STATUS             current
+        DESCRIPTION        "This table is used to specify Link Profile
+                            Configuration."
+::= { wireless 2 }
+
+
+linkProfileEntry OBJECT-TYPE
+        SYNTAX      LinkProfileEntry
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents an entry in the 
+                     Link Profile Configuration table."
+        INDEX       { linkProfileIndex, linkProfileSecIndex }
+::= { linkProfileTable 1 }
+
+
+LinkProfileEntry ::=
+        SEQUENCE {
+                linkProfileIndex
+                    Integer32,
+                linkProfileSecIndex
+                    Integer32,
+                linkProfileDDRSStatus
+                    Integer32,
+                linkProfileSpatialStream
+                    Integer32,
+                linkProfileDDRSMinRate
+                    Integer32,
+                linkProfileDDRSMaxRate
+                    Integer32,
+                linkProfileDDRSRateIncTimer
+                    Integer32,
+                linkProfileDDRSRateDecTimer
+                    Integer32,
+                linkProfileTxRate
+                    Integer32,
+                linkProfileSupportedRates
+                    DisplayString,
+                linkProfileATPCStatus
+                    Integer32,
+                linkProfilePower
+                    Integer32,
+                linkProfileTxChainMask
+                    Integer32,
+                linkProfileDDRSRateIncrThrld
+                    Integer32,
+                linkProfileDDRSRateIncRTXThrld
+                    Integer32,
+                linkProfileDDRSRateDecRTXThrld
+                    Integer32
+        }
+
+
+linkProfileIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..2)
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents the Radio Index 
+                     for link profile Configuration table.
+                     It is supported only for 5GHz radio. For 5 GHz radio - '2'."
+::= { linkProfileEntry 1 }
+
+linkProfileSecIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..1)
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents the link profile Index 
+                     for link profile Configuration table."
+::= { linkProfileEntry 2 }
+
+linkProfileDDRSStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            enable (1),
+            disable (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DDRS Status."
+::= { linkProfileEntry 3 }
+
+linkProfileSpatialStream OBJECT-TYPE
+        SYNTAX      INTEGER {
+            single (1),
+            dual (2),
+            auto (3)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Spatial stream."
+::= { linkProfileEntry 4 }
+
+linkProfileDDRSMinRate OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DDRS Minimum Rate."
+::= { linkProfileEntry 5 }
+
+linkProfileDDRSMaxRate OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DDRS Maximum Rate."
+::= { linkProfileEntry 6 }
+
+linkProfileDDRSRateIncTimer OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DDRS Rate Increment Timer."
+::= { linkProfileEntry 7 }
+
+linkProfileDDRSRateDecTimer OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DDRS Rate decrement timer."
+::= { linkProfileEntry 8 }
+
+linkProfileTxRate OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx rate."
+::= { linkProfileEntry 9 }
+
+linkProfileSupportedRates OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the supported rates."
+::= { linkProfileEntry 10 }
+
+linkProfileATPCStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            enable (1),
+            disable (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the ATPC status."
+::= { linkProfileEntry 11 }
+
+linkProfilePower OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the fixed power."
+::= { linkProfileEntry 12 }
+
+linkProfileTxChainMask OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the TxChainMask."
+::= { linkProfileEntry 13 }
+
+linkProfileDDRSRateIncrThrld OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rate Increment
+                     Threshold."
+::= { linkProfileEntry 14 }
+
+linkProfileDDRSRateIncRTXThrld OBJECT-TYPE
+        SYNTAX      Integer32 (1..100)
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rate Increment 
+                     RTX Threshold."
+::= { linkProfileEntry 15 }
+
+linkProfileDDRSRateDecRTXThrld OBJECT-TYPE
+        SYNTAX      Integer32 (1..100)
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rate Decrement
+                     RTX Threshold."
+::= { linkProfileEntry 16 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+network OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "Network Parameters"
+::= { configuration 2 }
+
+
+networkAddressType OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Address Type.
+                     It can be configured as 
+                     'static' - Static
+                       'dhcp' - Dynamic."
+::= { network 1 }
+
+networkIPAddress OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     IP Address. Default value 192.168.1.1."
+::= { network 2 }
+
+networkNetMask OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the 
+                     Subnet Mask. Default value 255.255.255.0"
+::= { network 3 }
+
+networkGateway OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Gateway IP Addres. Default value 192.168.1.1."
+::= { network 4 }
+
+networkDNSIP OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the DNS
+                     Server IP Address. Multiple DNS IP Addresses
+                     can be configured with a space between IPs.
+                     Ex:- '192.168.1.1 192.168.1.2'"
+::= { network 5 }
+
+networkclearStatistics OBJECT-TYPE
+        SYNTAX      INTEGER {
+            ethernet   (1),
+            wireless5g (2),
+            wireless2g (3)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to clear the ethernet,
+                     Wireless 5GHz and wireless 2.4GHz statistics."
+::= { network 6 }
+
+networkMode OBJECT-TYPE
+        SYNTAX      INTEGER {
+            bridge  (1),
+            routing (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Network Mode.
+                     It is configurable when radio mode of the 
+                     device is station(SU). It can be configured as
+                     '1' - Bridge
+                     '2' - Routing."
+::= { network 7 }
+
+networkNatStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Nat Status.
+                     It is configurable when network mode is set 
+                     to routing. It can be configured as
+                     '0' - Disable
+                     '1' - Enable."
+::= { network 8 }
+
+networkWirelessIPAddress OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Wireless IP Address. Default value is 
+                     192.168.3.1. It is applicable when network 
+                     mode is set to routing."
+::= { network 9 }
+
+networkWirelessNetMask OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the 
+                     Wireless Subnet Mask. Default value is 
+                     255.255.255.0. It is applicable when network
+                     mode is set to routing"
+::= { network 10 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+radius OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "RADIUS Parameters."
+::= { configuration 3 }
+
+radiusStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Radius Server
+                     Status. It can be configured as
+                     '0' - Disable
+                     '1' - Enable"
+        DEFVAL      { disable }
+::= { radius 1 }
+
+radiusPrimaryServer OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Primary Server IP Address. Default value is 
+                     192.168.1.100."
+::= { radius 2 }
+
+radiusPrimaryPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Primary Port. Default value is 1812."
+::= { radius 3 }
+
+radiusPrimarySecret OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Primary Secret."
+        DEFVAL      { "public" }
+::= { radius 4 }
+
+radiusSecondaryServer OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Secondary Server IP Address. Default value is
+                     192.168.1.100."
+::= { radius 5 }
+
+radiusSecondaryPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Secondary Port. Default value is 1812."
+::= { radius 6 }
+
+radiusSecondarySecret OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Secondary Secret."
+        DEFVAL      { "public" }
+::= { radius 7 }
+
+radiusAuthenticationTime OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     ReAuthentication Time in seconds. Default value
+                     is 21600."
+::= { radius 8 }
+
+radiusRetryTime OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Retry Time in seconds. Default value is 300."
+::= { radius 9 }
+
+radiusRetryCount OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Retry Count. Default value is 3."
+::= { radius 10 }
+
+radiusRetryCountPeriod OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the Radius
+                     Retry Count Period in seconds. Default value is 
+                     3."
+::= { radius 11 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+vlan OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "VLAN Parameters"
+::= { configuration 4 }
+
+vlanStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            enable  (1),
+            disable (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents VLAN status.
+                     It can be configured as 
+                     '1' - Enable
+                     '2' - Disable."
+        DEFVAL      { disable }
+::= { vlan 1 }
+
+vlanMode OBJECT-TYPE
+        SYNTAX      INTEGER {
+            transparent (0),
+            access      (1),
+            trunk       (2),
+            q-in-q      (3),
+            mac-in-mac  (4)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents VLAN mode.
+                     It can be configured as 
+                           Outdoor Base - '0' - Transparent
+                     Outdoor Subscriber - '0' - Transparent
+                                          '1' - Access
+                                          '2' - Trunk
+                                          '3' - Q-in-Q
+                                          '4' - MAC-in-MAC."
+        DEFVAL      { transparent }
+::= { vlan 2 }
+
+vlanMgmtId OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the Managment VLAN ID. Default value
+                     is 1."
+::= { vlan 3 }
+
+vlanAccessId OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the Access VLAN ID. Default value
+                     is -1."
+::= { vlan 4 }
+
+vlanTrunkOption OBJECT-TYPE
+        SYNTAX      INTEGER {
+            list (1),
+            all  (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the VLAN 
+                     Trunk option. It can be configured as
+                     '1' - List
+                     '2' - All."
+        DEFVAL      { all }
+::= { vlan 5 }
+
+vlanTrunkId OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure 
+                     the Trunk VLAN ID."
+::= { vlan 6 }
+
+vlanSvlanId OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure 
+                     the SVLAN ID. Default value is -1."
+::= { vlan 7 }
+
+vlanSVlanEtherType OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the 
+                     SVLAN Ether Type. It can be configured as
+                     '0x0081' - 0x8100
+                     '0xa888' - 0x88a8
+                     '0x0091' - 0x9100
+                     '0x0092' - 0x9200.
+                     Default value is 0x8100."
+::= { vlan 8 }
+
+vlanBackboneDestinationMAC OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Backbone Destination MAC Address. 
+                     Default value is 00:00:00:00:00:00."
+::= { vlan 9 }
+
+vlanBackboneSourceMAC OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Backbone Source MAC Address.
+                     Default value is 00:00:00:00:00:00."
+::= { vlan 10 }
+
+vlanBackboneVLANID OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure 
+                     the Backbone VLANID. Defult value 
+                     is -1."
+::= { vlan 11 }
+
+vlanBackboneServiceInstanceVLANID OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure 
+                     the Backbone Service Instance VLANID.
+                     Default value is -1."
+::= { vlan 12 }
+
+vlanAllowTagMgmt OBJECT-TYPE
+        SYNTAX      INTEGER {
+            enable  (1),
+            disable (0)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents VLAN Tagged management.
+                     It can be configured as 
+                     '1' - Enable
+                     '0' - Disable."
+        DEFVAL      { disable }
+::= { vlan 13 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+ethernet OBJECT-IDENTITY
+        STATUS      current
+        DESCRIPTION "Ethernet Parameters."
+::= { configuration 5 }
+
+ethernetMode OBJECT-TYPE
+        SYNTAX      INTEGER {
+            autoNegotation (0),
+            half10Mbps     (1),
+            full10Mbps     (2),
+            half100Mbps    (3),
+            full100Mbps    (4),
+            full1000Mbps   (5)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Ethernet 
+                     Mode and Speed. It can be configured as
+                     '0' - Auto Negotiation,
+                     '1' - 10Mbps-Half,
+                     '2' - 10Mbps-Full,
+                     '3' - 100Mbps-Half,
+                     '4' - 100Mbps-Full,
+                     '5' - 1000Mbps-Full."
+        DEFVAL      { autoNegotation }
+::= { ethernet 1 }
+
+ethernetInactivity OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to Configuration 
+                     the Ethernet Inactivity in minutes. 
+                     Default value is 0"
+::= { ethernet 2 }
+
+ethernetMTU OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure the
+                     Ethernet MTU Size in bytes"
+::= { ethernet 3 }
+
+ethernetCableLength OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is used to get the Ethernet
+                     Cable Length"
+::= { ethernet 4 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+dhcp OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "DHCP Parameters"
+::= { configuration 6 }
+
+dhcpServer OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (1),
+            enable  (0)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the DHCP Server
+                     Status. It can be configured as 
+                     '1' - Disable
+                     '0' - Enable."
+        DEFVAL      { disable }
+::= { dhcp 1 }
+
+dhcpStartIP OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure DHCP
+                     Server Start IP Address."
+::= { dhcp 2 }
+
+dhcpEndIP OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure DHCP
+                     Server End IP Address."
+::= { dhcp 3 }
+
+dhcpLeaseTime OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure DHCP 
+                     Server Lease Time in seconds."
+::= { dhcp 4 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+filtering OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "Filtering Parameters"
+::= { configuration 7 }
+
+filteringStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Filtering
+                     Status. It can be configured as 
+                     '0' - Disable
+                     '1' - Enable."
+        DEFVAL      { disable }
+::= { filtering 1 }
+
+filteringL2Multicast OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the L2Multicast
+                     Status. It can be configured as 
+                     '0' - Disable
+                     '1' - Enable."
+        DEFVAL      { disable }
+::= { filtering 2 }
+
+filteringL3Multicast OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the L3Multicast
+                     Status. It can be configured as 
+                     '0' - Disable
+                     '1' - Enable."
+        DEFVAL      { disable }
+::= { filtering 3 }
+
+filteringL2Broadcast OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the L2Broadcast
+                     Status. It can be configured as 
+                     '0' - Disable
+                     '1' - Enable."
+        DEFVAL      { disable }
+::= { filtering 4 }
+
+filteringL3Broadcast OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable (0),
+            enable  (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the L3Broadcast
+                     Status. It can be configured as 
+                     '0' - Disable
+                     '1' - Enable."
+        DEFVAL      { disable }
+::= { filtering 5 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+sysMgmt OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "System Management Parameters"
+::= { management 1 }
+
+sysMgmtApply OBJECT-TYPE
+        SYNTAX      INTEGER {
+            yes (1),
+            no  (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to Apply 
+                     changed configuration."
+::= { sysMgmt 1 }
+
+sysMgmtReset OBJECT-TYPE
+        SYNTAX      INTEGER {
+            yes (1),
+            no  (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to reset
+                     with default configuration."
+::= { sysMgmt 2 }
+
+sysMgmtReboot OBJECT-TYPE
+        SYNTAX      INTEGER {
+            yes (1),
+            no  (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to Reboot
+                     the device."
+::= { sysMgmt 3 }
+
+sysMgmtDynamicUpdate OBJECT-TYPE
+        SYNTAX      INTEGER {
+            yes (1),
+            no  (2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to apply
+                     Dynamic Configuration."
+::= { sysMgmt 4 }
+
+sysMgmtResetRetainip OBJECT-TYPE
+        SYNTAX      INTEGER {
+            no  (0),
+            yes (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to reset device
+                     to default configuration with retainig
+                     ip address.
+                     '0' - reset without retain IP
+                     '1' - reset with retain IP"
+::= { sysMgmt 5 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+sysInfo OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "System Information Parameters"
+::= { management 2 }
+
+sysInfoName OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the system name."
+::= { sysInfo 1 }
+
+sysInfoLocation OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the system Location."
+::= { sysInfo 2 }
+
+sysInfoContact OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the system Contact."
+::= { sysInfo 3 }
+
+sysInfoDescription OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the 
+                     system Description."
+::= { sysInfo 4 }
+
+sysInfoGeolat OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the 
+                     Latitude Coordinates."
+::= { sysInfo 5 }
+
+sysInfoGeolong OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the 
+                     Longitude Coordinates."
+::= { sysInfo 6 }
+
+sysInfoTemperature OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the 
+                     Temperature."
+::= { sysInfo 7 }
+
+sysInfoEmail OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the system email."
+::= { sysInfo 8 }
+
+sysInfoBaseStationID OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the system BaseStationID."
+::= { sysInfo 9 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+sysInventory OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "System Inventory Parameters"
+::= { management 3 }
+
+sysInventorySerialNo OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Serial Number."
+::= { sysInventory 1 }
+
+sysInventoryModel OBJECT-TYPE
+        SYNTAX      INTEGER {
+            aPI-18-5G-AC2x2-W2(1),
+            sUI-18-5G-AC2x2-W2(3),
+            sUI-23-5G-AC2x2-W2(4)
+        }
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Model."
+::= { sysInventory 2 }
+
+sysInventoryRelnum OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     firmware release number."
+::= { sysInventory 3 }
+
+sysInventoryMajnum OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     firmware major number."
+::= { sysInventory 4 }
+
+sysInventoryMinnum OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     firmware minor number."
+::= { sysInventory 5 }
+
+sysInventoryProductid OBJECT-TYPE
+        SYNTAX      INTEGER {
+            ptp(1),
+            ptmp(2),
+            indoorap(3),
+            outdoorap(4)
+        }
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     product ID
+                     '1' - PTP
+                     '2' - PTMP
+                     '3' - INDOORAP
+                     '4' - OUTDOORAP."
+::= { sysInventory 6 }
+
+sysInventoryBuildno OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     build number."
+::= { sysInventory 7 }
+
+sysInventoryMaxsu OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     maximum supported SUs."
+::= { sysInventory 8 }
+
+sysInventoryHardwareVersion OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Hardware Version."
+::= { sysInventory 9 }
+
+sysInventoryAntennagain1 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Antenna Gain of 5GHz radio."
+::= { sysInventory 10 }
+
+sysInventoryAntennagain2 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Antenna Gain of 2.4GHz radio."
+::= { sysInventory 11 }
+
+sysInventoryAntennatype1 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Antenna Type of 5GHz radio."
+::= { sysInventory 12 }
+
+sysInventoryAntennatype2 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is represents the 
+                     Antenna Type of 2.4GHz radio."
+::= { sysInventory 13 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+trapControl OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "Trap Parameters"
+::= { management 4 }
+
+
+genericTrap  OBJECT-TYPE
+        SYNTAX       DisplayString
+        MAX-ACCESS   accessible-for-notify
+        STATUS       current
+        DESCRIPTION  "This parameter is used to provide additional information on traps."
+
+::= { trapControl 1 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+tftp OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "Tftp Parameters"
+::= { management 5 }
+
+tftpFilename OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to 
+                     configure the tftp filename."
+::= { tftp 1 }
+
+tftpFiletype OBJECT-TYPE
+        SYNTAX      INTEGER {
+            configfile(1),
+            firmwareimage(2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to 
+                     configure the tftp filetype.
+                     It is configured as below
+                     '1' - Config File
+                     '2' - Firmware Image."
+::= { tftp 2 }
+
+tftpServerip OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to 
+                     configure the tftp serverip."
+::= { tftp 3 }
+
+tftpOperationStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            idle(1),
+            downloadInProgress(2),
+            downloadSuccess(3),
+            downloadFailure(4),
+            uploadInProgress(5),
+            uploadSuccess(6),
+            uploadFailure(7)
+        }
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is used to get the  
+                     tftp Operation Status. Enums
+                     '1' - IDLE
+                     '2' - DOWNLOAD_IN_PROGRESS
+                     '3' - DOWNLOAD_SUCCESS
+                     '4' - DOWNLOAD_FAILURE
+                     '5' - UPLOAD_IN_PROGRESS
+                     '6' - UPLOAD_SUCCESS
+                     '7' - UPLOAD_FAILURE."
+::= { tftp 4 }
+
+tftpOperationtype OBJECT-TYPE
+        SYNTAX      INTEGER {
+            none(0),
+            upload(1),
+            download(2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the tftp Operation Type. It is 
+                     configured as:-
+                     '0' - NONE
+                     '1' - UPLOAD
+                     '2' - DOWNLOAD."
+::= { tftp 5 }
+
+tftpKeepSet OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to check 
+                     Keepsettings enabled or disabled.
+                     It is configured as:-
+                     '0' - DISABLE
+                     '1' - ENABLE."
+::= { tftp 6 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+ntp OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "NTP Parameters"
+::= { management 6 }
+
+ntpStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the NTP Status."
+::= { ntp 1 }
+
+ntpServerIP OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to 
+                     configure the NTP ServerIP Address."
+::= { ntp 2 }
+
+ntpTimeZone OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to 
+                     configure the Timezone."
+::= { ntp 3 }
+
+ntpLocalTime OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter is used to 
+                     display the local time."
+::= { ntp 4 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+gps OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "GPS Parameters"
+::= { management 7 }
+
+gpsStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the GPS Status."
+::= { gps 1 }
+
+gpsInterval OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     GPS Interval in Seconds."
+::= { gps 2 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+dyingGasp OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "DYING GASP Parameters"
+::= { management 8 }
+
+dyingGaspStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            enable(1),
+            disable(2)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the Dying GASP Status."
+::= { dyingGasp 1 }
+
+dyingGaspAck OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(1),
+            enable(0)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the Dying GASP ACK ."
+::= { dyingGasp 2 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+leds OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "LED Parameters"
+::= { management 9 }
+
+ledsStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the LEDS."
+::= { leds 1 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+log OBJECT-IDENTITY
+    STATUS current
+    DESCRIPTION "Log Parameters"
+::= { management 10 }
+
+syslogServerIP OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the Syslog ServerIP Address."
+::= { log 1 }
+
+syslogServerPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the Syslog server Port number."
+::= { log 2 }
+
+tempLogStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the temperature log."
+::= { log 3 }
+
+tempLogInterval OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     Temperature Log Interval in Seconds."
+::= { log 4 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+http OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "HTTP/HTTPS Parameters"
+::= { management 11 }
+
+adminPassword OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     and retrieve the Http admin password."
+::= { http 1 }
+
+userPassword OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     and retrieve the Http user password."
+::= { http 2 }
+
+superUserPassword OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure and
+                     retrieve the Http super user password."
+::= { http 3 }
+
+httpStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the HTTP."
+::= { http 4 }
+
+httpPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the HTTP Port number."
+::= { http 5 }
+
+httpsStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the HTTPS."
+::= { http 6 }
+
+httpsPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the HTTPS Port number."
+::= { http 7 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+telnetssh OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "Telnet/SSH Parameters"
+::= { management 12 }
+
+telnetStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the Telnet."
+::= { telnetssh 1 }
+
+telnetPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the Telnet Port number."
+::= { telnetssh 2 }
+
+telnetSessions OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the Telnet Sessions."
+::= { telnetssh 3 }
+
+sshStatus OBJECT-TYPE
+        SYNTAX      INTEGER {
+            disable(0),
+            enable(1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the SSH."
+::= { telnetssh 4 }
+
+sshPort OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the SSH Port number."
+::= { telnetssh 5 }
+
+sshSessions OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the SSH Sessions."
+::= { telnetssh 6 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+snmp OBJECT-IDENTITY
+     STATUS current
+     DESCRIPTION "SNMP Parameters"
+::= { management 13 }
+
+snmpStatus OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to enable 
+                     or disable the SNMP. 
+                     It is configured as -
+                     any  - checked
+                     none - unchecked."
+::= { snmp 1 }
+
+snmpVersion OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure 
+                     the SNMP Version. 
+                     It is configured as -
+                     v1  - SNMPv1
+                     any - SNMPv1-v2c."
+::= { snmp 2 }
+
+snmpReadPassword OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     and retrieve the Read password."
+::= { snmp 3 }
+
+snmpTrapHostIPAddress OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     the SNMP Trap Host IP Address."
+::= { snmp 4 }
+
+snmpTrapHostPassword OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure and
+                     retrieve the SNMP Trap Host password."
+::= { snmp 5 }
+
+snmpReadWritePassword OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter is used to configure
+                     and retrieve the Read/Write password."
+::= { snmp 6 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+wirelessStatsTable OBJECT-TYPE
+        SYNTAX SEQUENCE OF WirelessStatsEntry
+        MAX-ACCESS         not-accessible
+        STATUS             current
+        DESCRIPTION        "This table is used to specify 
+                            Wireless Statistics."
+::= { monitor 1 }
+
+wirelessStatsEntry OBJECT-TYPE
+        SYNTAX      WirelessStatsEntry
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents an entry in the 
+                     Wireless Statistics Table."
+        INDEX       { wirelessStatsRadioIndex }
+::= { wirelessStatsTable 1 }
+
+
+WirelessStatsEntry ::=
+        SEQUENCE {
+                wirelessStatsRadioIndex
+                    Integer32,
+                wirelessStatsMACAddress
+                    DisplayString,
+                wirelessStatsRemotePartners
+                    Integer32,
+                wirelessStatsDataTxTotalPackets
+                    Integer32,
+                wirelessStatsDataRxTotalPackets
+                    Integer32,
+                wirelessStatsDataTxMulticastPackets
+                    Integer32,
+                wirelessStatsDataRxMulticastPackets
+                    Integer32,
+                wirelessStatsDataTxUnicastPackets
+                    Integer32,
+                wirelessStatsDataRxUnicastPackets
+                    Integer32,
+                wirelessStatsMgmtTxPackets
+                    Integer32,
+                wirelessStatsMgmtRxPackets
+                    Integer32,
+                wirelessStatsMgmtTxBeacons
+                    Integer32,
+                wirelessStatsMgmtRxBeacons
+                    Integer32,
+                wirelessStatsMgmtAuthReqSent
+                    Integer32,
+                wirelessStatsMgmtAuthReqRecv
+                    Integer32,
+                wirelessStatsMgmtAuthConfirm
+                    Integer32,
+                wirelessStatsMgmtAuthReject
+                    Integer32,
+                wirelessStatsMgmtDeAuthReqSent
+                    Integer32,
+                wirelessStatsMgmtDeAuthReqRecv
+                    Integer32,
+                wirelessStatsMgmtAuthResultLast
+                    DisplayString,
+                wirelessStatsMgmtAssocReqSent
+                    Integer32,
+                wirelessStatsMgmtAssocReqRecv
+                    Integer32,
+                wirelessStatsMgmtAssocConfirm
+                    Integer32,
+                wirelessStatsMgmtAssocReject
+                    Integer32,
+                wirelessStatsMgmtDeAssocReqSent
+                    Integer32,
+                wirelessStatsMgmtDeAssocReqRecv
+                    Integer32,
+                wirelessStatsMgmtAssocResultLast
+                    DisplayString,
+                wirelessStatsMPDUErrors
+                    Integer32,
+                wirelessStatsPhyErrors
+                    Integer32
+        }
+
+wirelessStatsRadioIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..2)
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the index for the 
+                     wireless Statistics table."
+::= { wirelessStatsEntry 1 }
+
+wirelessStatsMACAddress OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the MAC address of 
+                     in a wireless Statistics."
+::= { wirelessStatsEntry 2 }
+
+wirelessStatsRemotePartners OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Partners
+                     in Wireless Statistics."
+::= { wirelessStatsEntry 3 }
+
+wirelessStatsDataTxTotalPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx total packets
+                     in Wireless Statistics of type data."
+::= { wirelessStatsEntry 4 }
+
+wirelessStatsDataRxTotalPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx total packets
+                     in Wireless Statistics of type data."
+::= { wirelessStatsEntry 5 }
+
+wirelessStatsDataTxMulticastPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Multicast
+                     packets in Wireless Statistics of type data."
+::= { wirelessStatsEntry 6 }
+
+wirelessStatsDataRxMulticastPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Multicast
+                     packets in Wireless Statistics of type data."
+::= { wirelessStatsEntry 7 }
+
+wirelessStatsDataTxUnicastPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Multicast
+                     packets in Wireless Statistics of type data."
+::= { wirelessStatsEntry 8 }
+
+wirelessStatsDataRxUnicastPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Multicast
+                     packets in Wireless Statistics of type data."
+::= { wirelessStatsEntry 9 }
+
+wirelessStatsMgmtTxPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx packets
+                     in Wireless Statistics of type Managment."
+::= { wirelessStatsEntry 10 }
+
+wirelessStatsMgmtRxPackets OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx packets
+                     in Wireless Statistics of type Managment."
+::= { wirelessStatsEntry 11 }
+
+wirelessStatsMgmtTxBeacons OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Beacons
+                     in Wireless Statistics of type Managment."
+::= { wirelessStatsEntry 12 }
+
+wirelessStatsMgmtRxBeacons OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Beacons
+                     in Wireless Statistics of type Managment."
+::= { wirelessStatsEntry 13 }
+
+wirelessStatsMgmtAuthReqSent OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Authentication
+                     request sent in Wireless Statistics of type 
+                     Managment."
+::= { wirelessStatsEntry 14 }
+
+wirelessStatsMgmtAuthReqRecv OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Authentication
+                     request received in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 15 }
+
+wirelessStatsMgmtAuthConfirm OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Authentication
+                     confirm in Wireless Statistics of type 
+                     Managment."
+::= { wirelessStatsEntry 16 }
+
+wirelessStatsMgmtAuthReject OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Authentication
+                     reject in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 17 }
+
+wirelessStatsMgmtDeAuthReqSent OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the DeAuthentication
+                     request sent in Wireless Statistics of type 
+                     Managment."
+::= { wirelessStatsEntry 18 }
+
+wirelessStatsMgmtDeAuthReqRecv OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the DeAuthentication
+                     request received in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 19 }
+
+wirelessStatsMgmtAuthResultLast OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Authentication
+                     result last in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 20 }
+
+wirelessStatsMgmtAssocReqSent OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Association
+                     request sent in Wireless Statistics of type 
+                     Managment."
+::= { wirelessStatsEntry 21 }
+
+wirelessStatsMgmtAssocReqRecv OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Association
+                     request received in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 22 }
+
+wirelessStatsMgmtAssocConfirm OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Association
+                     confirm in Wireless Statistics of type 
+                     Managment."
+::= { wirelessStatsEntry 23 }
+
+wirelessStatsMgmtAssocReject OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Association
+                     reject in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 24 }
+
+wirelessStatsMgmtDeAssocReqSent OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the DeAssociation
+                     request sent in Wireless Statistics of type 
+                     Managment."
+::= { wirelessStatsEntry 25 }
+
+wirelessStatsMgmtDeAssocReqRecv OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the DeAssociation
+                     request received in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 26 }
+
+wirelessStatsMgmtAssocResultLast OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Association
+                     result last in Wireless Statistics of 
+                     type Managment."
+::= { wirelessStatsEntry 27 }
+
+wirelessStatsMPDUErrors OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the MPDU Errors
+                     in Wireless Statistcs."
+::= { wirelessStatsEntry 28 }
+
+wirelessStatsPhyErrors OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Phy Errors
+                     in Wireless Statistcs."
+::= { wirelessStatsEntry 29 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+ethernetStatsTable OBJECT-TYPE
+        SYNTAX SEQUENCE OF EthernetStatsEntry
+        MAX-ACCESS         not-accessible
+        STATUS             current
+        DESCRIPTION        "This table is used to specify 
+                            Ethernet Statistics."
+::= { monitor 2 }
+
+ethernetStatsEntry OBJECT-TYPE
+        SYNTAX      EthernetStatsEntry
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents an entry in the 
+                     Ethernet Statistics Table."
+        INDEX       { ethernetStatsIndex }
+::= { ethernetStatsTable 1 }
+
+
+EthernetStatsEntry ::=
+        SEQUENCE {
+                ethernetStatsIndex
+                    Integer32,
+                ethernetStatus
+                    DisplayString,
+                ethernetMACAddress
+                    DisplayString,
+                ethernetSpeed
+                    DisplayString,
+                ethernetDuplex
+                    DisplayString,
+                ethernetTxTotalPackets
+                    DisplayString,
+                ethernetRxTotalPackets
+                    DisplayString,
+                ethernetTxTotalBytes
+                    DisplayString,
+                ethernetRxTotalBytes
+                    DisplayString,
+                ethernetTxErrors
+                    DisplayString,
+                ethernetRxErrors
+                    DisplayString,
+                ethernetTxL2McastDropCount
+                    DisplayString,
+                ethernetRxL2McastDropCount
+                    DisplayString,
+                ethernetTxL3McastDropCount
+                    DisplayString,
+                ethernetRxL3McastDropCount
+                    DisplayString,
+                ethernetTxL2BcastDropCount
+                    DisplayString,
+                ethernetRxL2BcastDropCount
+                    DisplayString,
+                ethernetTxL3BcastDropCount
+                    DisplayString,
+                ethernetRxL3BcastDropCount
+                    DisplayString,
+                ethernetTxDropped
+                    DisplayString,
+                ethernetRxDropped
+                    DisplayString,
+                ethernetTxMulticast
+                    DisplayString,
+                ethernetRxMulticast
+                    DisplayString,
+                ethernetTxUnicast
+                    DisplayString,
+                ethernetRxUnicast
+                    DisplayString,
+                ethernetRxCRCErrors
+                    DisplayString,
+                ethernetRxFrameOverSizeErrors
+                    DisplayString,
+                ethernetRxFrameOverrunErrors
+                    DisplayString
+        }
+
+ethernetStatsIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..2)
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the index for the 
+                     ethernet Statistics table."
+::= { ethernetStatsEntry 1 }
+
+ethernetStatus OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Ethernet Status
+                     in ethernet Statistics table."
+::= { ethernetStatsEntry 2  }
+
+ethernetMACAddress OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the MAC address of 
+                     in ethernet Statistics table."
+::= { ethernetStatsEntry 3 }
+
+ethernetSpeed OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Ethernet Speed
+                     in ethernet Statistics table ."
+::= { ethernetStatsEntry 4  }
+
+ethernetDuplex OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Ethernet Duplex
+                     in ethernet Statistics table."
+::= { ethernetStatsEntry 5  }
+
+ethernetTxTotalPackets OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Total packets
+                     in ethernet statistics table."
+::= { ethernetStatsEntry 6  }
+
+ethernetRxTotalPackets OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Total packets
+                     in ethernet statistics table."
+::= { ethernetStatsEntry 7  }
+
+ethernetTxTotalBytes OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Total Bytes
+                     in ethernet statistics table."
+::= { ethernetStatsEntry 8 }
+
+ethernetRxTotalBytes OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Total Bytes
+                     in ethernet statistics table."
+::= { ethernetStatsEntry 9 }
+
+ethernetTxErrors OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Errors
+                     in ethernet statistics table."
+::= { ethernetStatsEntry 10 }
+
+ethernetRxErrors OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Errors
+                     in ethernet statistics table."
+::= { ethernetStatsEntry 11 }
+
+ethernetTxL2McastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx L2 Multicast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 12 }
+
+ethernetRxL2McastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx L2 Multicast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 13 }
+
+ethernetTxL3McastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx L3 Multicast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 14 }
+
+ethernetRxL3McastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx L3 Multicast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 15 }
+
+ethernetTxL2BcastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx L2 Broadcast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 16 }
+
+ethernetRxL2BcastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx L2 Broadcast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 17 }
+
+ethernetTxL3BcastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx L3 Broadcast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 18 }
+
+ethernetRxL3BcastDropCount OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx L3 Broadcast
+                     drop count in ethernet statistics table."
+::= { ethernetStatsEntry 19 }
+
+ethernetTxDropped OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx drop
+                     count in ethernet statistics table."
+::= { ethernetStatsEntry 20 }
+
+ethernetRxDropped OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx drop
+                     count in ethernet statistics table."
+::= { ethernetStatsEntry 21 }
+
+ethernetTxMulticast OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Multi
+                     -cast in ethernet statistics table."
+::= { ethernetStatsEntry 22 }
+
+ethernetRxMulticast OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Multi
+                     -cast in ethernet statistics table."
+::= { ethernetStatsEntry 23 }
+
+ethernetTxUnicast OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Uni
+                     -cast in ethernet statistics table."
+::= { ethernetStatsEntry 24 }
+
+ethernetRxUnicast OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Uni
+                     -cast in ethernet statistics table."
+::= { ethernetStatsEntry 25 }
+
+ethernetRxCRCErrors OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx CRC
+                     Errors in ethernet statistics table."
+::= { ethernetStatsEntry 26 }
+
+ethernetRxFrameOverSizeErrors OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Frame over
+                     Size Errors in ethernet statistics table."
+::= { ethernetStatsEntry 27 }
+
+ethernetRxFrameOverrunErrors OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Frame over
+                     Run Errors in ethernet statistics table."
+::= { ethernetStatsEntry 28 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+assocTable OBJECT-TYPE
+        SYNTAX SEQUENCE OF AssocEntry
+        MAX-ACCESS         not-accessible
+        STATUS             current
+        DESCRIPTION        "This table is used to specify
+                            Wireless Association Station"
+::= { monitor 3 }
+
+
+assocEntry OBJECT-TYPE
+        SYNTAX      AssocEntry
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents an entry in the
+                     Associated station Table"
+        INDEX   { assocRadioIndex, assocSecIndex }
+::= { assocTable 1 }
+
+
+AssocEntry ::=
+        SEQUENCE {
+                assocRadioIndex
+                    Integer32,
+                assocSecIndex
+                    Integer32,
+                assocMAC
+                    DisplayString,
+                assocIP
+                    IpAddress,
+                assocRemoteLat
+                    DisplayString,
+                assocRemoteLong
+                    DisplayString,
+                assocLocalLat
+                    DisplayString,
+                assocLocalLong
+                    DisplayString,
+                assocRxRate
+                    Integer32,
+                assocTxRate
+                    Integer32,
+                assocRxTput
+                    Integer32,
+                assocTxTput
+                    Integer32,
+                assocLocalSNRA1
+                    Integer32,
+                assocLocalSNRA2
+                    Integer32,
+                assocRemoteSNRA1
+                    Integer32,
+                assocRemoteSNRA2
+                    Integer32,
+                assocLocalPhyErr
+                    Integer32,
+                assocRemotePhyErr
+                    Integer32,
+                assocLocalMPDUErr
+                    Integer32,
+                assocRemoteMPDUErr
+                    Integer32,
+                assocLocalRetries
+                    Integer32,
+                assocRemoteRetries
+                    Integer32,
+                assocLinkTestDuration
+                    Integer32,
+                assocLinkTestDirection
+                    INTEGER,
+                assocLinkTestStartStop
+                    INTEGER,
+                assocLocalNoiseFloor
+                    Integer32,
+                assocRemoteNoiseFloor
+                    Integer32,
+                assocLocalCustomername
+                    DisplayString,
+                assocRemoteCustomername
+                    DisplayString,
+                assocLocalLinkid
+                    DisplayString,
+                assocRemoteLinkid
+                    DisplayString
+        }
+
+assocRadioIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..2)
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents the index for the 
+                     wireless Assoc Table."
+::= { assocEntry 1 }
+
+assocSecIndex OBJECT-TYPE
+        SYNTAX      Integer32 (1..2)
+        MAX-ACCESS  not-accessible
+        STATUS      current
+        DESCRIPTION "This parameter represents the Secondary index 
+                     for the wireless Assoc Table."
+::= { assocEntry 2 }
+
+
+assocMAC OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the MAC address of 
+                     associated station for a wireless interface."
+::= { assocEntry 3 }
+
+
+assocIP OBJECT-TYPE
+        SYNTAX      IpAddress
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the IP address of 
+                     associated station for a wireless interface."
+::= { assocEntry 4 }
+
+assocRemoteLat OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Latitude 
+                     of associated station for a wireless interface."
+::= { assocEntry 5 }
+
+assocRemoteLong OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Longitude 
+                     of associated station for a wireless interface."
+::= { assocEntry 6 }
+
+assocLocalLat OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Latitude 
+                     of associated station for a wireless interface."
+::= { assocEntry 7 }
+
+assocLocalLong OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Longitude 
+                     of associated station for a wireless interface."
+::= { assocEntry 8 }
+
+assocRxRate OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Rate 
+                     of associated station for a wireless interface."
+::= { assocEntry 9 }
+
+assocTxRate OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Rate 
+                     of associated station for a wireless interface."
+::= { assocEntry 10 }
+
+assocRxTput OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Rx Throughput 
+                     of associated station for a wireless interface."
+::= { assocEntry 11 }
+
+assocTxTput OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Tx Throughput 
+                     of associated station for a wireless interface."
+::= { assocEntry 12 }
+
+assocLocalSNRA1 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local SNR A1 
+                     of associated station for a wireless interface."
+::= { assocEntry 13 }
+
+assocLocalSNRA2 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local SNR A2 
+                     of associated station for a wireless interface."
+::= { assocEntry 14 }
+
+assocRemoteSNRA1 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote SNR A1 
+                     of associated station for a wireless interface."
+::= { assocEntry 15 }
+
+assocRemoteSNRA2 OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote SNR A2 
+                     of associated station for a wireless interface."
+::= { assocEntry 16 }
+
+assocLocalPhyErr OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Phy Errors 
+                     of associated station for a wireless interface."
+::= { assocEntry 17 }
+
+assocRemotePhyErr OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Phy Errors 
+                     of associated station for a wireless interface."
+::= { assocEntry 18 }
+
+assocLocalMPDUErr OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local MPDU Errors 
+                     of associated station for a wireless interface."
+::= { assocEntry 19 }
+
+assocRemoteMPDUErr OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote MPDU Errors 
+                     of associated station for a wireless interface."
+::= { assocEntry 20 }
+
+assocLocalRetries OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Retries
+                     of associated station for a wireless interface."
+::= { assocEntry 21 }
+
+assocRemoteRetries OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Retries
+                     of associated station for a wireless interface."
+::= { assocEntry 22 }
+
+assocLinkTestDuration OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Link test Duration."
+::= { assocEntry 23 }
+
+assocLinkTestDirection OBJECT-TYPE
+        SYNTAX      INTEGER {
+            uplink      (1),
+            downlink    (2),
+            bidirection (3)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Link test Direction."
+::= { assocEntry 24 }
+
+assocLinkTestStartStop OBJECT-TYPE
+        SYNTAX      INTEGER {
+            stop  (0),
+            start (1)
+        }
+        MAX-ACCESS  read-write
+        STATUS      current
+        DESCRIPTION "This parameter represents the Link test status as
+                     Start or Stop."
+::= { assocEntry 25 }
+
+assocLocalNoiseFloor OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Noise Floor
+                     of associated station for a wireless interface."
+::= { assocEntry 26 }
+
+assocRemoteNoiseFloor OBJECT-TYPE
+        SYNTAX      Integer32
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Noise Floor
+                     of associated station for a wireless interface."
+::= { assocEntry 27 }
+
+assocLocalCustomername OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Customer name
+                     of associated station for a wireless interface."
+::= { assocEntry 28 }
+
+assocRemoteCustomername OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Customer name
+                     of associated station for a wireless interface."
+::= { assocEntry 29 }
+
+assocLocalLinkid OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Local Linkid
+                     of associated station for a wireless interface."
+::= { assocEntry 30 }
+
+assocRemoteLinkid OBJECT-TYPE
+        SYNTAX      DisplayString
+        MAX-ACCESS  read-only
+        STATUS      current
+        DESCRIPTION "This parameter represents the Remote Linkid
+                     of associated station for a wireless interface."
+::= { assocEntry 31 }
+
+------------------------------------------------------------------------
+------------------------------------------------------------------------
+
+traps OBJECT-IDENTITY
+        STATUS current
+        DESCRIPTION "Trap Parameters"
+::= { monitor 4 }
+
+associatedTrap  NOTIFICATION-TYPE
+        OBJECTS { genericTrap }
+        STATUS       current
+        DESCRIPTION  "This trap is generated when 5GHz radio wireless link is up."
+::= { traps 1 }
+
+disassociatedTrap  NOTIFICATION-TYPE
+        OBJECTS { genericTrap }
+        STATUS       current
+        DESCRIPTION  "This trap is generated when 5GHz radio wireless link is down."
+::= { traps 2 }
+
+dyinggaspRemoteDeviceTrap  NOTIFICATION-TYPE
+        OBJECTS { genericTrap }
+        STATUS       current
+        DESCRIPTION  "This trap is generated when remote device is power off."
+::= { traps 3 }
+
+dyinggaspBSUTrap  NOTIFICATION-TYPE
+        OBJECTS { genericTrap }
+        STATUS       current
+        DESCRIPTION  "This trap is generated when Outdoor Base is power off."
+::= { traps 4 }
+
+suServiceTrap  NOTIFICATION-TYPE
+        OBJECTS { genericTrap }
+        STATUS       current
+        DESCRIPTION  "This trap is generated when Outdoor Subscriber Service is disabled."
+::= { traps 5 }
+
+END
